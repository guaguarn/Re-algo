# 零. 复杂度的计算
**复杂度分析法则  
> 1）单段代码看高频：比如循环。  
> 2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。  
> 3）嵌套代码求乘积：比如递归、多重循环等  
> 4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。
> ![[86662180565ace6565badeef427f4fd1.png]]
# 一.const关键字：【codeup1934】
- 最简单的用法

```cpp
const int MAX_SIZE = 100;        // 定义整数常量
const double PI = 3.14159;       // 定义浮点数常量
const std::string NAME = "Tom";  // 定义字符串常量
// MAX_SIZE = 200;  // 错误！不能修改常量
```

- 主要用途

1. 保护数据不被修改

```cpp
void printData(const int data) {
    // data = 10;  // 错误！不能修改const参数
    std::cout << data;
}
```

2. 指针与const（重要！）

```cpp
int value = 10;
const int* ptr1 = &value;  // 指向常量的指针：不能通过ptr1修改值
// *ptr1 = 20;  // 错误！
int* const ptr2 = &value;  // 常量指针：ptr2不能指向其他地址
// ptr2 = nullptr;  // 错误！
const int* const ptr3 = &value;  // 指向常量的常量指针：都不能改
```

3. 类中的const成员函数

```cpp
class Student {
    std::string name;
public:
    std::string getName() const {  // 承诺不修改对象
        return name;
    }
};
```

- 记忆技巧
 const在*左边*：指向的内容是常量const在*右边*：指针本身是常量
# 二.取整方法【PAT B1036】
## 1. 向下取整 (Floor)
向下取整是向==负无穷方向==取整。
### 方法：
```cpp
double floor(double x);
float floor(float x);
long double floor(long double x);
```
### 示例：
```cpp
int main() {
    std::cout << "floor(3.7) = " << std::floor(3.7) << std::endl;    // 3
    std::cout << "floor(-3.7) = " << std::floor(-3.7) << std::endl;  // -4
    std::cout << "floor(3.0) = " << std::floor(3.0) << std::endl;    // 3  
    return 0;
}
```
## 2. 向上取整 (Ceil)
向上取整是向==正无穷方向==取整。
### 方法：
```cpp
double ceil(double x);
float ceil(float x);
long double ceil(long double x);
```
### 示例：
```cpp
int main() {
    std::cout << "ceil(3.2) = " << std::ceil(3.2) << std::endl;     // 4
    std::cout << "ceil(-3.2) = " << std::ceil(-3.2) << std::endl;   // -3
    std::cout << "ceil(3.0) = " << std::ceil(3.0) << std::endl;     // 3
    return 0;
}
```
## 3. 四舍五入 (Round)
### 方法 1：使用 `round()` 函数
```cpp
double round(double x);
float round(float x);
long double round(long double x);
```
### 示例：
```cpp
int main() {
    std::cout << "round(3.4) = " << std::round(3.4) << std::endl;   // 3
    std::cout << "round(3.6) = " << std::round(3.6) << std::endl;   // 4
    std::cout << "round(-3.4) = " << std::round(-3.4) << std::endl; // -3
    std::cout << "round(-3.6) = " << std::round(-3.6) << std::endl; // -4
    return 0;
}
```
### 方法 2：手动实现四舍五入
```cpp
int main() {
    double num = 3.6;
    // 方法 1：加 0.5 后取整
    int result1 = (int)(num + 0.5);
    // 方法 2：使用 static_cast（更安全）
    int result2 = static_cast<int>(num + 0.5);
    // 方法 3：判断奇数偶数取整（处理整数，处理正好在中间的值（如 0.5）时）只需要一个简单的if语句，这里就不多赘述。
    std::cout << "手动四舍五入: " << result1 << std::endl;  // 4
    std::cout << "安全转换: " << result2 << std::endl;      // 4
    return 0;
}
```

## 4. 其他相关函数
### 截断取整 (Trunc)
向零方向取整（去掉小数部分）
```cpp
double trunc(double x);
std::cout << "trunc(3.7) = " << std::trunc(3.7) << std::endl;    // 3
std::cout << "trunc(-3.7) = " << std::trunc(-3.7) << std::endl;  // -3
```
### 就近取整 (rint)
使用当前的舍入模式
```cpp
double rint(double x);
```

## 5. 综合示例

```cpp
int main() {
    double numbers[] = {3.2, 3.7, -3.2, -3.7, 3.5, -3.5};
    
    std::cout << "数值\t向下\t向上\t四舍五入\t截断" << std::endl;
    std::cout << "----------------------------------------------" << std::endl;
    for(double num : numbers) {
        std::cout << num << "\t"
                  << std::floor(num) << "\t"
                  << std::ceil(num) << "\t"
                  << std::round(num) << "\t\t"
                  << std::trunc(num) << std::endl;
    }
    return 0;
}
```

输出结果：
```
数值    向下    向上    四舍五入    截断
----------------------------------------------
3.2     3       4       3           3
3.7     3       4       4           3
-3.2    -4      -3      -3          -3
-3.7    -4      -3      -4          -3
3.5     3       4       4           3
-3.5    -4      -3      -4          -3
```
## 6. 实用技巧
### 保留小数位数后的四舍五入
```cpp
double roundToDecimal(double value, int decimalPlaces) {
    double factor = std::pow(10, decimalPlaces);//幂运算
    return std::round(value * factor) / factor;
}
int main() {
    double num = 3.14159;
    std::cout << "保留2位小数: " << roundToDecimal(num, 2) << std::endl;  // 3.14
    std::cout << "保留3位小数: " << roundToDecimal(num, 3) << std::endl;  // 3.142
    return 0;
}
```
# 三.平年闰年相关问题
**平年和闰年是根据地球绕太阳公转周期来设定的历法调整，主要区别在于==二月的天数和全年的总天数。==**
## 主要区别对比

| 特征         | 平年      | 闰年           |
| ---------- | ------- | ------------ |
| **二月天数**   | 28天     | 29天          |
| **全年总天数**  | 365天    | 366天         |
| **出现频率**   | 每4年出现3次 | 每4年出现1次      |
| **公转周期补偿** | 未完全补偿   | 补偿0.2422天的差距 |
## 1.判断是否是闰年
**快速：格里高利历法**
```cpp
bool isLeapYear(int year) {
    // 规则1：能被4整除
    // 规则2：但不能被100整除，除非能被400整除
    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}
```
## 2.计算两个日期之间的天数差【力扣1360】
请你编写一个程序来计算两个日期之间隔了多少天。
日期以字符串形式给出，格式为 `YYYY-MM-DD`。
**前缀题目【力扣1154 一年中的第几天】**
给你一个字符串 `date` ，按 `YYYY-MM-DD` 格式表示一个 [现行公元纪年法](https://baike.baidu.com/item/%E5%85%AC%E5%85%83/17855) 日期。返回该日期是当年的第几天。
```cpp
class Solution {
public:
    int dayOfYear(string date) {
        // 直接提取子字符串并转换为整数
        int y = std::stoi(date.substr(0, 4));
        int m = std::stoi(date.substr(5, 2));
        int d = std::stoi(date.substr(8, 2));
        int v = y % 400 == 0 || (y % 4 == 0 && y % 100 != 0) ? 29 : 28;
        int days[] = {31, v, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        int ans = d;
        for (int i = 0; i < m - 1; ++i) {
            ans += days[i];
        }
        return ans;
    }
};
```
==substr函数：==
返回子串 `[pos, pos+count)` 。（左闭右开）
若请求的字串越过字符串的结尾，即 `count` 大于 size() - pos （例如若 count == npos ），则返回的子串为 `[pos, [size()]。
总代码:(暴力解法，其他解法我写不出来TT)
```cpp
class Solution {
public:
    int daysBetweenDates(string date1, string date2) {
        // 提取日期1的年月日
        int y1 = stoi(date1.substr(0, 4));
        int m1 = stoi(date1.substr(5, 2));
        int d1 = stoi(date1.substr(8, 2));
        // 提取日期2的年月日
        int y2 = stoi(date2.substr(0, 4));
        int m2 = stoi(date2.substr(5, 2));
        int d2 = stoi(date2.substr(8, 2));
        // 计算两个日期各自的总天数
        long long days1 = totalDays(y1, m1, d1);
        long long days2 = totalDays(y2, m2, d2);
        return abs(days2 - days1);
    }
private:
    // 判断闰年
    bool isLeapYear(int year) {
        return (year % 400 == 0) || (year % 4 == 0 && year % 100 != 0);
    }
    // 计算从公元元年到指定日期的总天数
    long long totalDays(int year, int month, int day) {
        long long total = 0;
        // 累加完整年份的天数
        for (int y = 1; y < year; y++) {
            total += isLeapYear(y) ? 366 : 365;
        }
        // 累加当年已过月份的天数
        for (int m = 1; m < month; m++) {
            total += daysInMonth(year, m);
        }
        // 加上当月的天数
        total += day;
        return total;
    }
    // 获取某月的天数
    int daysInMonth(int year, int month) {
        static const int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        if (month == 2 && isLeapYear(year)) {
            return 29;
        }
        return days[month - 1];
    }
};
```

# 四.进制转换
## 基本概念
- **十进制**：日常使用的数字系统（0-9）
- **二进制**：计算机使用的数字系统（0-1）
- **进制转换**：将数字从一种进制系统转换为另一种     
## 转换步骤（P进制 → Q进制）

### 第一步：P进制 → 十进制
**公式**：将每位数字乘以其位权后相加
```
十进制数 y = a₁×Pⁿ⁻¹ + a₂×Pⁿ⁻² + ... + aₙ₋₁×P¹ + aₙ×P⁰
```
**代码实现**：
```cpp
int y = 0, product = 1;
while (x != 0) {
    y = y + (x % 10) * product;  // 取个位数并乘位权
    x = x / 10;                  // 去掉个位
    product = product * P;       // 更新位权
}
```
### 第二步：十进制 → Q进制
**方法**：==除基取余法==（不断除以Q，记录余数）                
**代码实现**：
```cpp
int z[40], num = 0;
do {
    z[num++] = y % Q;  // 记录余数
    y = y / Q;         // 更新商
} while (y != 0);      // 商不为0继续
```
**关键点**：
- 余数从后往前读就是Q进制结果
- 必须用`do...while`而不是`while`，以正确处理数字0的情况
## 例子
十进制11 → 二进制：
```
11 ÷ 2 = 5 ... 1
5 ÷ 2 = 2 ... 1  
2 ÷ 2 = 1 ... 0
1 ÷ 2 = 0 ... 1
```
结果：1011（从最后一个余数往前读）


## 详细解释 `pre = pre << 1; pre += A[i];`

### 基本含义
这两行代码模拟了**二进制数的逐位构建过程**：

```cpp
pre = pre << 1;    // 相当于 pre = pre * 2
pre += A[i];       // 加上当前二进制位（0或1）
```

### 具体过程解析

**这相当于数学上的操作：**
- 如果当前数值是 `N`，二进制表示是 `...xyz`
- 左移一位后变成 `...xyz0`（相当于 ×2）
- 加上当前位 `A[i]` 后变成 `...xyzA[i]`

**举例说明：**
假设我们正在处理二进制数 `1011`：

1. **处理第1位 (1):**
   - `pre = 0 << 1 = 0` → `0`
   - `pre += 1 = 1` → 二进制: `1`

2. **处理第2位 (0):**
   - `pre = 1 << 1 = 2` → 二进制: `10`
   - `pre += 0 = 2` → 二进制: `10`

3. **处理第3位 (1):**
   - `pre = 2 << 1 = 4` → 二进制: `100`
   - `pre += 1 = 5` → 二进制: `101`

4. **处理第4位 (1):**
   - `pre = 5 << 1 = 10` → 二进制: `1010`
   - `pre += 1 = 11` → 二进制: `1011`

### 什么时候可以固定使用这个模式？

**适用场景：**
1. **二进制数处理** - 逐位构建二进制数值
2. **字符串转整数** - 处理数字字符串时
3. **进制转换** - 从低位到高位构建数值
4. **大数运算** - 逐位处理大数字
5. **状态机设计** - 状态转移计算

**通用模板：**
```cpp
int value = 0;
for (int i = 0; i < digits.length; i++) {
    value = value * base + digit_value;  // 通用形式
    // 或者对于二进制：
    // value = (value << 1) | bit_value;
}
```

### 具体应用示例

**1. 二进制字符串转整数：**
```cpp
string binary = "1101";
int num = 0;
for (char c : binary) {
    num = (num << 1) | (c - '0');
}
// 结果: num = 13
```

**2. 十进制字符串转整数：**
```cpp
string decimal = "123";
int num = 0;
for (char c : decimal) {
    num = num * 10 + (c - '0');
}
// 结果: num = 123
```

**3. 十六进制处理：**
```cpp
string hex = "1A3";
int num = 0;
for (char c : hex) {
    num = num * 16 + hex_digit_value(c);
}
```

### 在这个算法中的特殊考虑

```cpp
pre = pre % 5;  // 关键优化
```

这个算法在每次迭代后取模，利用了**模运算的分配律**：
- `(a + b) % m = (a % m + b % m) % m`
- `(a × b) % m = (a % m × b % m) % m`

这样就能**避免数值溢出**，同时保证结果的正确性。

### 总结
`pre = pre << 1; pre += A[i];` 是一个**处理二进制数逐位构建的经典模式**，在需要按位处理数值的场景中非常有用，特别是结合模运算可以高效解决大数整除性问题。
# 五.字符串
## 1.回文串

致命错误：没有创建对象
```cpp
class Solution {
bool isPalindrome(string s) {
        int n = s.size();
        for(int i = 0; i < n/2; i++){
            if(s[i] != s[n - 1 - i])
                return false;
        }
        return true;
    }
};
int main() {
    string s;
    isPalindrome(s); //没有创建对象，出错！ 
    return 0;  

}
```
修改后：
```cpp 
const int maxn = 256;//防止溢出
// 判断字符串 str 是否是"回文串"
bool judge(char str[]) {
    int len = strlen(str);    // 字符串长度
    for(int i = 0; i < len / 2; i++) {    // i 枚举字符串的前一半
        if(str[i] != str[len - 1 - i]) {    // 如果对称位置不同
            return false;    // 不是"回文串"
        }
    }
    return true;    // 是"回文串"
}
int main() {
    char str[maxn];
    while(gets(str)) {    // 输入字符串
        bool flag = judge(str);    // 判断字符串 str 是否是"回文串"
        if(flag == true) {    // "回文串"
            printf("YES\n");    // 输出 YES
        } else {    // 不是"回文串"
            printf("NO\n");    // 输出 NO
        }
    }
    return 0;
}
```
## 2.LCR 018. 验证回文串
给定一个字符串 `s` ，验证 `s` 是否是 **回文串** ，只考虑字母和数字字符，可以忽略字母的大小写。
本题中，将空字符串定义为有效的 **回文串** 。
```cpp
class Solution {
public:
    bool isPalindrome(string s) {
        int size = s.size();
        string ans = "";
        for(int i = 0 ; i < size; i++){
            if(s[i] >= 'a' && s[i] <= 'z'){
                ans += s[i];
            }else if(s[i] >= 'A' && s[i] <= 'Z'){
                ans += (s[i] + 32);
            }else if(s[i] >= '0' && s[i] <= '9'){
                ans += s[i];
            }
        }
        for(int i = 0; i < ans.size() / 2; i++){
            if(ans[i] != ans[ans.size() - i - 1]){
                return false;
            }
        }
        return true;
    }
};
```
**char字符对应ASCII码表**
大写小，小写大(+ 32)
![[Pasted image 20251105172557.png]]
![[Pasted image 20251105172610.png]]
**关于ASCII码**
在C++中，字符串是由字符组成的，而字符在内存中是以其ASCII码（或其他编码，但通常是ASCII）的数值形式存储的。因此，我们可以直接使用字符的ASCII码值。
例如，字符 'A' 的ASCII码是65，字符 'a' 的ASCII码是97。
在C++中，我们可以通过将字符赋值给整数类型来获取其ASCII码，也可以直接将字符作为整数来使用。
以下是一些示例：
1. 获取字符的ASCII码：  
    char c = 'A';  
    int ascii = c; // ascii 的值将是65
2. 在条件判断中直接使用字符的ASCII码：  
    if (c >= 65 && c <= 90) {  
    // 判断是否为大写字母  
    }
3. 也可以直接使用字符常量：  
    if (c >= 'A' && c <= 'Z') {  
    // 这样写更直观，不需要记住具体的ASCII码  
    }
4. 在算术运算中直接使用字符：  
    char c = 'A';  
    c = c + 1; // 现在c变成了'B'，因为66是'B'的ASCII码
5. 注意：字符字面量是用单引号括起来的，而字符串字面量是用双引号括起来的。字符串是由多个字符组成的，所以不能直接将字符串转换为一个ASCII码，但可以转换字符串中的每个字符。

因此，对于字符串，我们可以遍历其中的每个字符，然后使用每个字符的ASCII码。
例如，要将字符串中的每个字符转换为ASCII码，可以这样做：
```cpp
string s = "Hello";  
for (char c : s) {  
int ascii_value = c;  
// 使用ascii_value  
}
```
需要注意的是，C++中的字符类型默认是有符号的还是无符号的取决于编译器，但通常我们使用`int`来存储ASCII码值，因为ASCII码的范围是0到127，用`int`存储是安全的。
## 3.说反话【PAT B1009】
柳婼大神的做法：
```cpp
#include <iostream>
#include <stack>
using namespace std;
int main() {
    stack<string> v;//字符串栈
    string s;
    while(cin >> s) v.push(s);
    cout << v.top();
    v.pop();
    while(!v.empty()) {
        cout << " " << v.top();
        v.pop();
    }
    return 0;
}
```
简单优雅！用了栈的做法。