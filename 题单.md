# 前言
![[image-7.png]]
![[image-3.png]]
![[image-4.png]]
画图软件：[Excalidraw Whiteboard](https://excalidraw.com/)
重要！：在做题时需要注意[[算法复杂度]]，防止超时
常用：
[宫水三叶的刷题网站]([标签 - 宫水三叶的刷题日记](https://www.acoier.com/tags/))
[快速刷题]([罐装-蜜糖的个人空间-罐装-蜜糖个人主页-哔哩哔哩视频](https://space.bilibili.com/444731546/lists/2067482?type=season))
[柳婼]([liuchuo (柳婼)](https://github.com/liuchuo))
[鲤鱼笔记]([LeetCode 题目汇总 | 鲤鱼笔记](https://blog.lichangao.com/daily_practice/leetcode/overview/question_summary.html))
[算法通关手册]([0. 序言 | 算法通关手册（LeetCode）](https://algo.itcharge.cn/00_preface/))
[深度优化]([wangyuGithub01/Machine_Learning_Resources: :fish::fish::fish: 机器学习面试复习资源](https://github.com/wangyuGithub01/Machine_Learning_Resources))
[[算法图解.pdf]]
[yxc](https://blog.csdn.net/weixin_45629285/article/details/110350640?fromshare=blogdetail&sharetype=blogdetail&sharerId=110350640&sharerefer=PC&sharesource=weixin_58051254&sharefrom=from_link)
[董晓博客园]([董晓 - 博客园](https://www.cnblogs.com/dx123))
[董晓bilibili]([董晓算法视频专辑-董晓算法视频合集-哔哩哔哩视频](https://space.bilibili.com/517494241/lists))

### 5分钟原则
>**五分钟思考法**：如果一道题如果 5 分钟之内有思路，就立即动手写代码解题。如果 5 分钟之后还没有思路，就直接去看题解。然后根据题解的思路，自己去实现代码。如果发现自己看了题解也无法实现代码，就认真阅读题解的代码，并理解代码的逻辑。

刷算法题的过程和背英语单词很相似。
刚开始学英语时，先从最基础的字母学起，不必纠结每个字母的由来。接着学习简单的单词，也不用深究单词的含义，先记住再说。掌握了基础词汇后，再逐步学习词组、短句、长句，最后阅读文章。
背单词不是看一遍就能记住，而是需要不断重复练习、反复记忆来加深印象。
刷算法题也是如此。零基础时，不要纠结为什么自己想不出解法，或者为什么没想到更高效的方法。遇到没有思路的题目时，直接去看题解区的高赞解答，尽快积累经验，帮助自己快速入门。
### 重复刷题
>**重复刷题**：遇见不会的题，多刷几遍，不断加深理解。

刷算法题经常是做完一遍后，隔一段时间就忘记了，看到之前做过的题目也未必能立刻想起解题思路。所以，刷题并不是做完一遍就结束了，还需要定期回顾和复习。
此外，一道题往往有多种解法和不同的优化思路。第一次做时可能只想到一种方法，等到第二遍、第三遍时，可能会发现新的解法或更优的实现。
因此，对不会的题目多刷几遍，通过反复练习不断加深理解和记忆。

# 哈希
==**有限的空间来映射一个无限的空间，或在这个空间内实现有序化，来实现增速**==
- 提速
- 空间<->时间
- [ ] [[1. 【easy】Two Sum]]
- [ ] [[49. 【medium】Group Anagrams]]【标准化】
- [ ] [[128. 【medium】Longest Consecutive Sequence]]【头节点】
- [ ] [[CF44A Indian Summer]]【键值对】【不重复】
# 双指针
==**由于数据特征的有序性(大小或者正负)，所以可以证明当前节点一定是优于过往节点，从而可以通过数据的维度数量的指针，逐步的迭代收敛最终找到最优解。**==
- [ ] [[283. 【easy】Move Zeroes]]
- [ ] [[11.  【medium】Container With Most Water]]【左小左，右小右】
- [ ] [[15. 【medium】 3Sum]]
- [ ] [[42. 【hard】Trapping Rain Water]]【困难题的门槛】【单调栈】【前后缀】
### 二分查找
==**-处理查找元素是否存在用闭区间简单法：先写等，再写大小，最后写返回。求中间值下标的语句，不用 `int c = (l + r) / 2`，而采用`int c = l + (r - l) / 2` 的写法乃是为了防止「提前溢出」==
==-查找大于小于等于元素的第一个元素/最后一个元素用红蓝法：0.引入变量l=-1，r=N，此时使用中值为（l+r）/2 while后面跟着（l+1！=r）（有边界）1.划分蓝红区域，确定isBlue()  2。确定返回l还是r  3.套用模板（[[肆]]）  4.后处理**==
- [ ] [[35. 【eassy】Search Insert Position]]【超出时间限制】【left为下标】【插入元素】
- [ ] [[704.【easy】 Binary Search]]【最基础模板】【找不到返回-1】
- [ ] [[74.【medium】 Search a 2D Matrix]]【矩阵】
- [ ] [[34. 【medium】Find First and Last Position of Element in Sorted Array]]【Lower Bound】【查找第一个 ≥ x 的元素】【当数组中含有多个目标数字】
- [ ] [[153. 【medium】Find Minimum in Rotated Sorted Array]]【旋转】
- [ ] [[33. 【medium】Search in Rotated Sorted Array]]
- [ ] [[2054. 【medium】Two Best Non-Overlapping Events]]【找最大从后往前找】【后缀】【大了往左，小了往右】【返回红蓝边界右边界】
### 滑动窗口【滑动窗口 = 双指针 + 动态窗口状态维护】[[肆]]【题目我主要使用了python来写，187开始时Java】【其实就是窗口长度固定/不固定两种情况，换汤不换药】
[恩师Eason](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/876061/yi-ge-mo-ban-miao-sha-10dao-zhong-deng-n-sb0x)
[另一个比较多题的讲解](https://leetcode.cn/discuss/post/3164215/hua-dong-chuang-kou-zong-jie-by-edte-qao1/)
![[image-1.png]]
==**1.定义需要维护的变量们（最大长度/最小长度/哈希表）【注意初始化】**==
==**2.定义窗口的首尾端（start，end），然后滑动窗口**==
==**3.更新需要维护的变量（if）**==
==**4.1【窗口长度固定】**==
- 如果题目的窗口长度固定：用一个if语句判断一下当前窗口长度是否达到了限定长度 
- 如果达到了，窗口左指针前移一个单位，从而保证下一次右指针右移时，窗口长度保持不变, 
- 左指针移动之前, 先更新Step 1定义的(部分或所有)维护变量 
-  if 窗口长度达到了限定长度:
	    更新 (部分或所有) 维护变量 
	    窗口左指针前移一个单位保证下一次右指针右移时窗口长度保持不变
==**4.2【窗口长度不固定】**==
- 如果题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题
- 如果当前窗口不合法时, 用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法
- 在左指针移动之前更新Step 1定义的(部分或所有)维护变量 
- while 不合法:
        更新 (部分或所有) 维护变量 
	    不断移动窗口左指针直到窗口再次合法
==**5.return...**==
> 要计算有多少个元素和恰好等于k的子数组，可以把问题变成：
> - 计算有多少个元素和≥k的子数组。
> - 计算有多少个元素和>k，也就是≥k + 1的子数组。
> - > 答案就是元素和≥k的子数组个数，减去元素和≥k + 1的子数组个数。这里把>转换成≥，从而可以把滑窗逻辑封装成一个函数f，然后用f(k) - f(k + 1)计算，无需编写两份滑窗代码。
> 总结：「恰好」可以拆分成两个「至少」，也就是两个「越长越合法」的滑窗问题。
- [ ] [[643. 【easy】Maximum Average Subarray I]]【平均数】【python的字符缩进问题】
- [ ] [[3. 【medium】Longest Substring Without Repeating Characters]]【查找】【哈希表】
- [ ] [[159. 【medium】至多包含两个不同字符的最长子串 【会员题】]]【查找】【哈希表】
- [ ] [[209. 【medium】Minimum Size Subarray Sum]]【如何初始化】【sum >= target】
- [ ] [[1695. 【medium】Maximum Erasure Value]]【元素不重复】【查找】【哈希表】
- [ ] [[438. 【medium】Find All Anagrams in a String]]【异位词】【起始索引】【哈希表的比较】
- [ ] [[567. 【medium】Permutation in String]]【子字符串】
- [ ] [[487. 【medium】最大连续1的个数 II【会员题】]]【0的个数不能超过一个】
- [ ] [[1004. 【medium】Max Consecutive Ones III]]【0的个数不能超过k个】
- [ ] [[1208. 【medium】Get Equal Substrings Within Budget]]【绝对值abs】
- [ ] [[1052. 【medium】Grumpy Bookstore Owner]]【生气时的最大顾客数】【minutes时间内的生气时的最大顾客数】
- [ ] [[1423. 【medium】Maximum Points You Can Obtain from Cards]]
- [ ] [[1151. 【medium】最少交换次数来组合所有的 1【会员题】]]【返回长度为1的个数的窗口中0的最小个数】
- [ ] [[76. 【hard】Minimum Window Substring]]【不定长度】【成员函数是否覆盖】
- [ ] [[424. 【medium】Longest Repeating Character Replacement]]【end - start + 1 - max_n > k】【注意更新当前哈希表中最大频率的元素】
- [ ] [[930. 【medium】Binary Subarrays With Sum]]【前缀和】【恰好滑动型窗口】
- [ ] [[1876. 【easy】Substrings of Size Three with Distinct Characters]]【if的顺序】
- [ ] [[187. 【medium】Repeated DNA Sequences]]【固定长度】【分块判断】【哈希查找】【substr切割函数】【count查找函数】【Java与cpp调用函数的异同】

# 序列【线性表】
### 前缀和/后缀和[[拾]][[【模板】前缀和]]
==**快速计算区间和**==
==**子数组和等于k
先创建一个长度为原数组加一的数组，此时下标与第n个数不对应，在进行前缀和计算的时候调整，调整后中判断时，第n个下标就对于这第n个数**==
- [ ] [[560. 【medium】Subarray Sum Equals K]]【子串】【前缀和】【哈希表】
- [ ] [[53. 【medium】Maximum Subarray]]【前缀和】【动态规划】
- [ ] [[2483. 【medium】Minimum Penalty for a Shop]]【前后缀】【客人问题】
### 差分[[【模板】差分]]
### 数组/字符串
##### 普通数组
- [ ] [[53. 【medium】Maximum Subarray]]【前缀和】【动态规划】
- [ ] [[56. 【medium】Merge Intervals]]【排序】
- [ ] [[189. 【medium】Rotate Array]]【三步反转】【reverse】
- [ ] [[238. 【medium】Product of Array Except Self]]【前后缀】
- [ ] [[41. 【hard】First Missing Positive]]【换座位】
- [ ] [[数字反转]]
- [ ] [[【NOIP2005 普及组】校门外的树]]【重要！！！！！】【标记法】【差分】【双指针】【哈希】【set转化成】
##### 二维数组【矩阵】
- [ ] [[54. 【medium】Spiral Matrix]]【注意边界处理】【画图】【n = matrix[0].size()】
- [ ] [[48. Rotate Image]]【旋转】【数学问题】

##### 模运算    [灵神](https://leetcode.cn/discuss/post/3584387/fen-xiang-gun-mo-yun-suan-de-shi-jie-dan-7xgu/)
![[Pasted image 20251130134518.png]]
- [ ] [[1590. Make Sum Divisible by P]]【前缀和】
##### 字符串
- [ ] [[P1308 【NOIP 2011 普及组】统计单词数]]【getchar】【getline】【单双引号】
- [ ] [[P5587 打字练习]]
### 队列
##### 单队列:
==**包括顺序队列(数组)、链式队列(链表)、循环队列(链表+环形)、阻塞队列(消息队列)等，也可用于BFS算法；**==
##### 双队列
==**是一个主队列、一个辅助队列，可用来实现用队列实现栈问题；**==
##### 单调队列
==**适用于解决滑动窗口最大值/最小值的问题**==
##### 双端队列
==**实现有Deque、LinkedList、ArrayDeque等，这些类作为双端队列使用时，同时支持从队首(First)和队尾(Last)进行入栈offer、出栈poll/peek等操作，其操作方法只需要在普通队列方法后面加上First/Last即可，比如从双端队列头部插入元素offerFirst、从尾部取出元素pollLast/peekLast等；**==
- [ ] [[239. 【hard】Sliding Window Maximum]]【multiset】
### 栈
##### 单栈问题：
==**可以解决括号匹配、表达式求值的问题，也可以用作函数调用、递归的底层数据结构，比如常用的递归算法DFS等； **==

##### 双栈问题：
==**受限于FILO的特性，单栈无法解决的问题，需要额外增加一个栈来辅助解决，双栈问题中其中一个栈是主栈，另一个是辅助栈，包括用栈实现队列、最小栈问题等；**==
##### 单调栈问题：
 ==**单调栈适合解决下一个更大元素、上一个更小元素类问题，包括下一个更大元素、每日温度问题等;当遇到环形数组，可以使用%运算符取模的方式来模拟环形效果**==
### 链表
##### 环形链表问题：
==**利用快慢指针来解，有两种思路-① 快慢指针都从head起步，先移动指针再比较是否相遇；② 快慢指针从不同节点起步，先比较是否相遇再移动指针；**==
##### 合并链表问题：
==**利用并行指针来解，多个指针有序从前向后移动，边移动指针边比较/计算，分两种情况—①原地修改链表，只需维护新链表的指针，空间复杂度为O(1)；②生成新链表，需同时维护新链表的节点和指针，空间复杂度为O(N)；为了简化边界条件，头部都需要使用守卫节点，尾部需考虑链表长度不一致剩余节点合并的问题；**==
##### 反转链表问题：
==**支持递归和遍历，遍历是万能解法，空间O(1)，链表太长时递归可能出现栈溢出，空间O(N)；遍历实现需使用守卫节点简化边界条件；递归实现分三步：① 递归遍历下一个指针；② 反转指针(next → cur)，并删除原方向指针(cur → next)；③ 出栈时递归向上返回新的头结点；**==
##### 倒数第K个节点问题：
==**利用快慢指针来解，快指针先走K步，然后快慢指针同步移动，快指针到达链表结尾(NULL)时，慢指针就指向倒数第K个节点；如果要删除倒数第K个节点，可利用守卫节点走到倒数第K+1个节点，然后再执行删除；或者先把链表反转，再查找从头开始第K个节点**==
##### 删除链表节点问题：
==**包括①删除指定值的节点；②删除第K个、倒数第K个节点；③重复节点去重；④删除所有重复节点；其中③和④分排序和不排序两类，排序链表只需比较相邻节点，不排序链表需借助哈希表实现重复元素的O(1)查找；**==
##### 链表重组问题：
==**按照一定算法将链表拆分后再合并，可以解决链表的分割、相交、旋转等问题；**==
# 二叉树与哈夫曼树
## 二叉树结构问题：
==**依次判断当前节点、左右子节点、左右子节点的孙子节点是否相同或对称；**==
## 二叉树深度和节点数问题：
==**常规思路是DFS，完全二叉树需分析树的节点特征，优化算法时间；**==
## 二叉树路径问题：
==**路径问题一般用先序遍历，先right-left后root的后序遍历是先序遍历的反序，可变相实现先序遍历；**==
## 前中后序转换：
==**前序遍历特征：root-left-right，中序遍历特征：left-root-right，后序遍历特征：left-right-root 无论是数组还是链表存储，都满足以上特征。**==
## 层序遍历问题：
==**借助队列的先进先出特性实现按层遍历，遍历root节点时切记将root的左右子节点入队。**==
## 哈夫曼树：

# 并查集
# 堆
## 优先队列PriorityQueue
# 回溯算法
## 排列：
==**原始数组可能有重复元素，但是每个元素只出现一次，同一个元素出现的位置/顺序不同即为不同的排列；**==
## 组合：
==**原始数组可能有重复元素，但是每个元素只出现一次，同一个元素出现的位置/顺序不同即为同一个组合；**==
## 子集：
==**子集问题即满足指定条件的部分组合问题，但子集可能会包含重复元素，即同一个元素可以出现多次，解题思路和组合问题类似。**==
# 图论
### 传染成员函数infect
- [ ] [[200. 【medium】Number of Islands]]【连通区域】【标记】【种子填充法】【传染法】
### 最短路径
- [ ] [[994.【medium】 Rotting Oranges]]【BFS】
### 拓扑排序
- [ ] [[207. 【medium】Course Schedule]]【优先搜索】
- [ ] 210
- [ ] 329
### 字典树
- [ ] [[208. 【medium】Implement Trie (Prefix Tree)]]【设计】【前缀树】
- [ ] 211

# 动态规划【注意下标对应】[清楚的讲解！]([邋遢大哥233的个人空间-邋遢大哥233个人主页-哔哩哔哩视频](https://space.bilibili.com/490057508/search?keyword=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92))
**背包看容量，区间看长度，树上看子树，数位看位数，状压看掩码，斜率看单调
动态规划其实就是列表格
### **递推关系型**（状态转移基于固定公式）【dp[i] = f(dp[i-1], dp[i-2], ...)】（有关联性）
##### 斐波那契计数问题
==**并不是典型的最优解问题，而是求从A到B有多少种方法或路径，到达某个位置N只关注最近一次N-1或最近两次N-2的出发位置，这类问题可以抽象成斐波那契数公式，然后使用自下而上的遍历+备忘录消除重复子问题降低空间复杂度**==
- [ ] 509.斐波那契数【f(n) = f(n-1) + f(n-2)】
- [ ] [[118. 【easy】Pascal's Triangle]]【C(n,k) = C(n-1,k-1) + C(n-1,k)】
- [ ] 119.杨辉三角2
- [ ] [[70. 【easy】 Climbing Stairs]]
- [ ] 62.不同路径
- [ ] 63.不同路径2（带权）
- [ ] [[【NOIP2001 普及组】数的计算]]
##### 最长连续子串问题
==**求线性序列中满足连续条件的最长子串长度**==
- [ ] 5.最长回文子串
- [ ] 128.最长连续序列
##### 最长递增子序列问题
==**包括严格递增——要求目标子序列和原序列顺序保持一致，非严格递增——不要求目标子序列和原序列顺序保持一致，非严格递增问题可以通过排序转换为严格递增问题，然后用求最长严格递增子序列的思路解决问题**==
- [ ] 300.最长递增子序列
- [ ] 128.最长连续序列
- [ ] 354.俄罗斯套娃
- [ ] 信封问题

### **选择决策型**（每一步需要做选择）【dp[i] = max/min(选择A, 选择B, ...)】
##### 木桶短板问题
==**一个木桶能装多少水取决于木桶中最短的那块板。该类问题的共性是上一个状态到当前状态的距离固定（比如只走一步），但是上一个状态会有多种选择（A1，A2，A3），当前状态最优解取决于上一个状态（多种选择）中最大或最小的状态。**==
- [ ] 72.编辑距离
- [ ] 221.最大正方形
- [ ] 42.接雨水【多方法】
##### 最远跳跃距离问题
==**在一个线性的数组中根据跳跃规则求最远可以跳跃的距离，边跳边算可以跳到的最远距离，如何判断某个位置跳不到呢——maxJumpDistance < i，跳不到就停止跳跃；其变型问题是从A跳到B的最小跳跃次数，需要在最远跳跃距离问题的基础上，增加判断逻辑——如果当前位置抵达了（之前的）最远跳跃距离，跳跃次数加1，更新最远跳跃距离；**==
##### 打家劫舍问题【决策问题】
==**有线性、环形、二叉树三种变型，线性问题即求选A更赚还是选B更赚的问题；环形问题可以先一分为二——选首不选尾、选尾不选首，然后就转化为了线性问题；二叉树问题可以一分为二——选当前节点和左右子树的子孙节点，不选左右节点、选左右节点不选当前节点，再求选A更赚还是选B更赚的问题；**==
- [ ] [[198. 【medium】House Robber]]【线性】
- [ ]  [[53. 【medium】Maximum Subarray]]【前缀和】【动态规划】
##### 接雨水问题
- [ ] 11.盛最多雨水的容器(滑动窗口内的动态规划版本问题)
- [ ] 42.接雨水，(多维动态规划问题)
##### 股票问题
```cpp
dp[i][k][0 or 1]
0 <= i <= n - 1, 1 <= k <= K
n 为天数，大 K 为交易数的上限，0 和 1 代表是否持有股票。
```
- [ ] [[121. 【eassy】Best Time to Buy and Sell Stock]] 【k=1】
- [ ] [[可以买卖多次]]
- [ ] 
### **穷举优化型**（遍历所有可能性找最优）【遍历所有可能状态，用DP避免重复计算】
##### 最短路径和问题/最小花费
int size = cost.size();从这个楼梯往上爬花费
int size = cost.size() - 1;爬到这个楼梯花费
==**即在二维数组中求从A到B的最短路径和，该问题需考虑上下边界的特殊情况。路径问题一般只关注左边、上边相邻的元素，因此dp数组可以二维降一维优化存储空间；**==
- [ ] [[746. 【easy】Min Cost Climbing Stairs]]
- [ ] 64.最小路径和
- [ ] 120.三角形最小路径
- [ ] 
##### 最大子数组和问题
==**求连续子数组的最大和，属于最经典的动态规划问题**==
- [ ] 53.最大子数组和
- [ ] 918.环形子数组的最大和
- [ ] 121.买卖股票的最佳时机
##### 穷举类DP问题【完全背包/背包变种】
==**边穷举边求最优解，使用备忘录优化重叠子问题**==
- [ ] [[322. 【medium】Coin Change]]【零钱兑换】【完全背包】【求凑成amount的最少硬币数】
- [ ] 139.单词拆分【背包思想的字符串应用】【判断能否被拆分】
- [ ] [[279. 【medium】Perfect Squares]]【完全背包】【求凑成n的最少完全平方数个数】
# 贪心算法
### 最大和
- [ ] [[3075. Maximize Happiness of Selected Children]]【排序贪心】【应初始化为0】【第一个幸福数应为最大值减一】
### 最大子段和
- [ ] [[鼠鼠我鸭]]
# 数学问题
### 最大公约数和最小公倍数【欧几里得算法】【骨传导和李春梅】【!b ? a : gcd(b, a % b)】
- [ ] [[2447. 【medium】Number of Subarrays With GCD Equal to K]]
### 高精度算法【竖式】
### 余数问题/整除问题
- [ ] [[1018. 【easy】Binary Prefix Divisible By 5]]【左移运算符】【进制转换】【[[壹]]】
- [ ] [[1015. 【medium】Smallest Integer Divisible by K]]【超时问题】【剪枝】
### 位运算[[【模板】位运算]]
### 大小写(一定记清楚！！！！小写大大写小！！！)
```cpp
if(a[i]>='A'&&a[i]<='Z')//转小写			
	a[i]+=32;
```

### Cantor 表
- [ ] [[P1014 【普及】cantor表]]


# DFS与BFS特辑
### DFS
- [ ] 小e走迷宫
- [ ] [[AtCoder Beginner Contest 436【12.13】]]D
- [ ] 
### BFS
































**【算法笔记里的整理】【偏难】【暂时放一下】**
###  区间 DP

**定义**：`dp[l][r]` 表示区间 `[l, r]` 的最优值。  
**枚举长度 → 枚举左端点 → 枚举分割点**。

| 典型题      | 转移                                                           | 例题      |
| -------- | ------------------------------------------------------------ | ------- |
| **石子合并** | `dp[l][r] = min(dp[l][k] + dp[k+1][r] + sum[l..r])`          | LC 1000 |
| **矩阵链乘** | `dp[l][r] = min(dp[l][k] + dp[k+1][r] + p[l]*p[k+1]*p[r+1])` | 经典教材    |

```cpp
for (int len = 2; len <= n; ++len)           // 长度
    for (int l = 1; l + len - 1 <= n; ++l) { // 左端点
        int r = l + len - 1;
        for (int k = l; k < r; ++k)          // 枚举分割
            dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r] + cost(l,k,r));
    }
```

---

###  树形 DP

**两类**：  
1. **换根 DP**（先以任意根算，再换根）  
2. **背包式树上 DP**（子树背包合并）

| 典型题 | 状态 | 转移 | 例题 |
|--------|------|------|------|
| **树上最大独立集** | `dp[u][0/1]`：以 `u` 为根，选/不选 `u` 的最大值 | `dp[u][1] = val[u] + Σ dp[v][0]` <br> `dp[u][0] = Σ max(dp[v][0], dp[v][1])` | LC 337（打家劫舍 III） |
| **树上背包** | `dp[u][j]`：子树 `u` 选 `j` 个节点的方案数/价值 | 类似 01 背包合并 | LC 2787 变种 |

```cpp
void dfs(int u, int fa) {
    dp[u][1] = val[u];
    for (int v : adj[u]) if (v != fa) {
        dfs(v, u);
        // 合并：倒序防止覆盖
        for (int j = sz[u]; j >= 0; --j)
            for (int k = 0; k <= sz[v]; ++k)
                if (j >= k) dp[u][j] = max(dp[u][j], dp[u][j-k] + dp[v][k]);
        sz[u] += sz[v];
    }
}
```

---

###  数位 DP

**状态**：`dp[pos][tight][state]`  
- `pos`：当前填到第几位（从高到低）  
- `tight`：是否贴着上界（1=是，0=否）  
- `state`：题目特定限制（前导零、数字和、出现 4 等）

**记忆化搜索模板**

```cpp
using ll = long long;
ll dfs(int pos, bool tight, int state) {
    if (pos == -1) return state_ok(state) ? 1 : 0;
    if (!tight && memo[pos][state] != -1) return memo[pos][state];
    int up = tight ? digit[pos] : 9;
    ll res = 0;
    for (int d = 0; d <= up; ++d) {
        int nstate = update(state, d);
        res += dfs(pos-1, tight && (d==up), nstate);
    }
    if (!tight) memo[pos][state] = res;
    return res;
}
```

**例题**：LC 2376（统计特殊整数）

---

###  状态压缩 DP（状压 DP）

**适用**：`n ≤ 20`，状态可压缩成二进制掩码。

| 典型题 | 状态 | 转移 |
|--------|------|------|
| **旅行商 TSP** | `dp[mask][u]`：已访问集合 `mask`，当前在 `u` 的最短路径 | `dp[mask][u] = min over v in mask (dp[mask^1<<v][v] + dist[v][u])` |
| **子集和计数** | `dp[mask]`：子集 `mask` 的方案数 | 枚举子集 |

**位运算枚举子集**

```cpp
for (int mask = 0; mask < (1<<n); ++mask) {
    for (int sub = mask; sub; sub = (sub-1) & mask) {
        // sub 是 mask 的非空子集
    }
}
```

---

###  斜率优化 & 凸包技巧 DP

**适用**：转移形如 `dp[i] = min_j (b[j]*a[i] + c[j])`，`a[i]` 单调。

```cpp
// 维护下凸包，队首决策点
struct Line { ll k, b; };
deque<Line> q;
ll calc(const Line& l, ll x) { return l.k * x + l.b; }
```


