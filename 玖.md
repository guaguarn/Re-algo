# 动态规划【大部分为Hello算法笔记】
动态规划（Dynamic Programming, DP），这是算法竞赛（OI/ACM）中的核心优化技巧，用于解决具有“最优子结构”和“重叠子问题”的组合优化问题。DP通过状态定义、转移方程和边界条件，避免暴力枚举的指数时间复杂度，转为多项式时间（如O(n^2)）。本章从基础递归/递推入手，逐步引入经典模型如序列DP和背包DP。
==DP五步法：**定义dp数组含义、推导递推公式、初始化、确定遍历顺序和获取最终答案**==
==注意：先判断爬到第n个台阶需要花费 or 从第n个台阶往上爬需要花费==
### 什么是动态规划（基础引入）
**定义与性质**：  
动态规划（dynamic programming）是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并 通过存储子问题的解来避免重复计算，从而大幅提升时间效率。
**如何理解？从爬楼梯开始*
### 爬楼梯
##### ==从暴力开始==
爬楼梯：给定一个共有 𝑛 阶的楼梯，你每步可以上 1 阶或者 2 阶，请问有多少种方案可以爬到楼顶？
(回溯法)
![[Pasted image 20251117110808.png]]
```cpp
// == File: climbing_stairs_backtrack.cpp ==
/* 回溯 */
void backtrack(vector<int> &choices, int state, int n, vector<int> &res) {
    // 当爬到第 n 阶时，方案数量加 1
    if (state == n)
        res[0]++;
    // 遍历所有选择
    for (auto &choice : choices) {
        // 剪枝：不允许越过第 n 阶
        if (state + choice > n)
            continue;
        // 尝试：做出选择，更新状态
        backtrack(choices, state + choice, n, res);
        // 回退
    }
}

/* 爬楼梯：回溯 */
int climbingStairsBacktrack(int n) {
    vector<int> choices = {1, 2}; // 可选择向上爬 1 阶或 2 阶
    int state = 0; // 从第 0 阶开始爬
    vector<int> res = {0}; // 使用 res[0] 记录方案数量
    backtrack(choices, state, n, res);
    return res[0];
}
```
我们可以尝试从问题分解的角度分析这道题。设爬到第 𝑖 阶共有 𝑑𝑝[𝑖] 种方案，那么 𝑑𝑝[𝑖] 就是原问题，其 子问题包括：
<center>𝑑𝑝[𝑖 − 1], 𝑑𝑝[𝑖 − 2], … , 𝑑𝑝[2], 𝑑𝑝[1]</center>
由于每轮只能上 1 阶或 2 阶，因此当我们站在第 𝑖 阶楼梯上时，上一轮只可能站在第 𝑖 − 1 阶或第 𝑖 − 2 阶 上。
**换句话说，我们只能从第 𝑖 − 1 阶或第 𝑖 − 2 阶迈向第 𝑖 阶。**
由此便可得出一个重要推论：爬到第 𝑖 − 1 阶的方案数加上爬到第 𝑖 − 2 阶的方案数就等于爬到第 𝑖 阶的方案数。公式如下： 
<center>𝑑𝑝[𝑖] = 𝑑𝑝[𝑖 − 1] + 𝑑𝑝[𝑖 − 2]</center>
这意味着在爬楼梯问题中，各个子问题之间存在递推关系，原问题的解可以由子问题的解构建得来。下图展示了该递推关系。 
![[Pasted image 20251117111703.png]]
##### 方法一：暴力（回溯）
我们可以根据递推公式得到暴力搜索解法。
以 𝑑𝑝[𝑛] 为起始点，递归地将一个较大问题拆解为两个较小问 题的和，直至到达最小子问题 𝑑𝑝[1] 和 𝑑𝑝[2] 时返回。
其中，最小子问题的解是已知的，即 𝑑𝑝[1] = 1、 𝑑𝑝[2] = 2 ，表示爬到第 1、2 阶分别有 1、2 种方案。 观察以下代码，它和标准回溯代码都属于深度优先搜索，但更加简洁：
（递归）
```cpp
// == File: climbing_stairs_dfs.cpp ==

/* 搜索 */
int dfs(int i) {
    // 已知 dp[i] 和 dp[2]，返回之
    if (i == 1 || i == 2)
        return i;
    // dp[i] = dp[i-1] + dp[i-2]
    int count = dfs(i - 1) + dfs(i - 2);
    return count;
}

/* 爬楼梯：搜索 */
int climbingStairsDFS(int n) {
    return dfs(n);
}
```
![[Pasted image 20251117123155.png]]
<center>暴力搜索形成的递归树。</center>
对于问题 𝑑𝑝[𝑛] ，其递归树的深度为 𝑛 ，时间复杂度为 𝑂(2𝑛) 。指数阶属于爆炸式增长，如果我们输入一个比较大的 𝑛 ，则会陷入漫长的等待之中。 
指数阶的时间复杂度是“重叠子问题”导致的。例如 𝑑𝑝[9] 被分解为 𝑑𝑝[8] 和 𝑑𝑝[7] ，𝑑𝑝[8] 被分解为 𝑑𝑝[7] 和 𝑑𝑝[6] ，两者都包含子问题 𝑑𝑝[7] 
##### 方法二：记忆化搜索（剪枝）
为了提升算法效率，我们希望所有的重叠子问题都只被计算一次。为此，我们声明一个数组 mem 来记录每个子问题的解，并在搜索过程中将重叠子问题剪枝。
经过记忆化处理后，所有重叠子问题都只需计算一次，时间复杂度优化至 𝑂(𝑛)
```cpp
// == File: climbing_stairs_dfs_mem.cpp ==

/* 记忆化搜索 */
int dfs(int i, vector<int> &mem) {
    // 已知 dp[1] 和 dp[2]，返回之
    if (i == 1 || i == 2)
        return i;
    // 若存在记录 dp[i]，则直接返回之
    if (mem[i] != -1)
    //如果当前阶数 i 的结果已经在记忆数组mem中计算过
    //（值不为 -1）,直接返回存储的结果，避免重复计算
        return mem[i];
    // dp[i] = dp[i-1] + dp[i-2]
    int count = dfs(i - 1, mem) + dfs(i - 2, mem);
    // 记录 dp[i]
    mem[i] = count;
    return count;
}

/* 爬楼梯：记忆化搜索 */
int climbingStairsDFSMem(int n) {
    // mem[i] 记录爬到第 i 阶的方案总数，-1 代表无记录
    //这样可以方便地从第i阶楼梯开始
    vector<int> mem(n + 1, -1);
    return dfs(n, mem);
}
```
问：把mem[i] = count;改成mem[i] = 1;是不是也可以判断？
**不可以！** 这样修改会完全破坏算法的正确性。

![[Pasted image 20251117124015.png]]
##### 方法三：动态规划
与记忆化搜索相反，动态规划是一种“从底至顶”的方法：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解。
由于动态规划不包含回溯过程，因此只需使用循环迭代实现，无须使用递归。在以下代码中，我们初始化一 个数组 dp 来存储子问题的解，它起到了与记忆化搜索中数组 mem 相同的记录作用： 
```cpp
// == File: climbing_stairs_dp.cpp ===

/* 爬楼梯：动态规划 */
int climbingStairsDP(int n) {
    if (n == 1 || n == 2)
        return n;
    // 初始化 dp 表，用于存储子问题的解
    vector<int> dp(n + 1);
    // 初始状态：预设最小子问题的解
    dp[1] = 1;
    dp[2] = 2;
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];//在之前可能已经知道了dp[i - 1]的值
    }
    return dp[n];
}
```
![[Pasted image 20251117131430.png]]
总结：
- 将数组 dp 称为 dp 表，𝑑𝑝[𝑖] 表示状态 𝑖 对应子问题的解。 
- 将最小子问题对应的状态（第 1 阶和第 2 阶楼梯）称为初始状态。 
- 将递推公式 𝑑𝑝[𝑖] = 𝑑𝑝[𝑖 − 1] + 𝑑𝑝[𝑖 − 2] 称为状态转移方程
**算法步骤**（通用DP框架）：  
1. 定义状态：dp[i] 表示子问题规模i的最优值。  
2. 状态转移：dp[i] = f(dp[i-1], ..., dp[i-k])（f为转移函数）。  
3. 边界：dp[0]/dp[1] 初始化。  
4. 计算顺序：自底向上（递推）或自顶向下（递归+记忆化）。
##### 空间优化（“滚动变量”或“滚动数组”）
由于 𝑑𝑝[𝑖] 只与 𝑑𝑝[𝑖 − 1] 和 𝑑𝑝[𝑖 − 2] 有关，因此我们无须使用一个数组 dp 来存 储所有子问题的解
```cpp
// === File: climbing_stairs_dp.cpp ===

/* 爬楼梯：空间优化后的动态规划 */
int climbtingStairsDPComp(int n) {
    if (n == 1 || n == 2)
        return n;
    int a = 1, b = 2;
    for (int t = 3; t <= n; t++) {
        int tmp = b;
        b = a + b;
        a = tmp;
    }
    return b;
}
```
 分治算法递归地将原问题划分为多个相互独立的子问题，直至最小子问题，并在回溯中合并子问题的 解，最终得到原问题的解。 ‧ 动态规划也对问题进行递归分解，但与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在 分解过程中会出现许多重叠子问题。 ‧ 回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系 列决策步骤构成，我们可以将每个决策步骤之前的子序列看作一个子问题。
==最优子结构cost[0]为地面==
爬楼梯最小代价 给定一个楼梯，你每步可以上 1 阶或者 2 阶，每一阶楼梯上都贴有一个非负整数，表示你在该台阶 所需要付出的代价。给定一个非负整数数组 𝑐𝑜𝑠𝑡 ，其中 𝑐𝑜𝑠𝑡[𝑖] 表示在第 𝑖 个台阶需要付出的代价， 𝑐𝑜𝑠𝑡[0] 为地面（起始点）。请计算最少需要付出多少代价才能到达顶部？
![[Pasted image 20251117134727.png]]
原问题的最优解是从子问题的最优解构建得来的:
<center>𝑝[𝑖] = min(𝑑𝑝[𝑖 − 1], 𝑑𝑝[𝑖 − 2]) + 𝑐𝑜𝑠𝑡[𝑖]</center>
```cpp
// == File: min_cost_climbing_stairs_dp.cpp ==

/* 爬楼梯最小代价：动态规划 */
int minCostClimbingStairsDP(vector<int> &cost) {
    int n = cost.size() - 1;
    //cost 里面带着0
    if (n == 1 || n == 2)
        return cost[n];
    // 初始化 dp 表，用于存储子问题的解
    vector<int> dp(n + 1);
    // 初始状态：预设最小子问题的解
    dp[1] = cost[1];//dp从1开始，更清晰明了
    dp[2] = cost[2];
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i <= n; i++) {
        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
    }
    return dp[n];
}
```
![[Pasted image 20251117135346.png]]
优化：
```cpp
// === File: min_cost_climbing_stairs_dp.cpp ===

/* 爬楼梯最小代价：空间优化后的动态规划 */
int minCostClimbingStairsDPComp(vector<int> &cost) {
    int n = cost.size() - 1;
    if (n == 1 || n == 2)
        return cost[n];
    int a = cost[1], b = cost[2];
    for (int i = 3; i <= n; i++) {
        int tmp = b;
        b = min(a, b) + cost[i];
        a = tmp;
    }
    return b;
}
```
**为什么[LCR 088. 使用最小花费爬楼梯](https://leetcode.cn/problems/GzCJIP/)（746. 【easy】Min Cost Climbing Stairs）不能用以上的两个模板？**
**问题在于没有正确理解题目的起点选择和终点定义**
```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int size = cost.size();
        vector<int> dp(size + 1, 0);
        
        // 初始化：可以选择从位置0或位置1开始，花费为0
        dp[0] = 0;
        dp[1] = 0;
        
        for(int i = 2; i <= size; i++) {
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        
        return dp[size];  // 到达顶部的最小花费
    }
};
```
优化：
```cpp
int minCostClimbingStairs(vector<int> &cost) {
    int n = cost.size();
    if (n <= 1) return 0;
    
    // 正确的初始化：考虑从0或1开始
    int a = cost[0], b = cost[1];
    
    for (int i = 2; i < n; i++) {
        int tmp = b;
        b = min(a, b) + cost[i];
        a = tmp;
    }
    
    // 到达顶部：从最后两个台阶直接跨上去
    return min(a, b);
}
```
### 无后效性
给定一个确定的状态，它的未来发展只 与当前状态有关，而与过去经历的所有状态无关
以爬楼梯问题为例，给定状态 𝑖 ，它会发展出状态 𝑖 + 1 和状态 𝑖 + 2 ，分别对应跳 1 步和跳 2 步。在做出 这两种选择时，我们无须考虑状态 𝑖 之前的状态，它们对状态 𝑖 的未来没有影响。 然而，如果我们给爬楼梯问题添加一个约束，情况就不一样了
带约束爬楼梯 给定一个共有 𝑛 阶的楼梯，你每步可以上 1 阶或者 2 阶，==但不能连续两轮跳 1 阶，==请问有多少种方案 可以爬到楼顶？
不难发现，此问题已不满足无后效性，状态转移方程 𝑑𝑝[𝑖] = 𝑑𝑝[𝑖 − 1] + 𝑑𝑝[𝑖 − 2] 也失效了，因为 𝑑𝑝[𝑖 − 1] 代表本轮跳 1 阶，但其中包含了许多“上一轮是跳 1 阶上来的”方案，而为了满足约束，我们就不 能将 𝑑𝑝[𝑖 − 1] 直接计入 𝑑𝑝[𝑖] 中。 
为此，我们需要扩展状态定义：状态 [𝑖, 𝑗] 表示处在第 𝑖 阶并且上一轮跳了 𝑗 阶，其中 𝑗 ∈ {1, 2} 。此状态 定义有效地区分了上一轮跳了 1 阶还是 2 阶，我们可以据此判断当前状态是从何而来的。 
![[Pasted image 20251117140720.png]]
最终，返回 𝑑𝑝[𝑛, 1] + 𝑑𝑝[𝑛, 2] 即可，两者之和代表爬到第 𝑛 阶的方案总数：
- `dp[t][1]` 表示爬到第 t 阶且最后一步爬 1 阶的方案数
- `dp[t][2]` 表示爬到第 t 阶且最后一步爬 2 阶的方案数
```cpp
/* 带约束爬楼梯：动态规划 */
int climbingStairsConstraintDP(int n) {
    if (n == 1 || n == 2) {
        return 1;
    }

    // 初始化 dp 表，用于存储子问题的解
    vector<vector<int>> dp(n + 1, vector<int>(3, 0));
    // 初始状态：预设最小子问题的解
    dp[1][1] = 1;
    dp[1][2] = 0;
    dp[2][1] = 0;
    dp[2][2] = 1;

    // 状态转移：从较小子问题逐步求解较大子问题
    for (int t = 3; t <= n; t++) {
        dp[t][1] = dp[t - 1][2];//不能两次都爬1
        dp[t][2] = dp[t - 2][1] + dp[t - 2][2];
    }
    return dp[n][1] + dp[n][2];
}
```
动态规划不能解决障碍物问题
### 解题思路
##### 如何判断是不是动态规划问题？
先观察问题是否适合使用回溯（穷举）（暴力）解决。
适合用回溯解决的问题通常满足“决策树模型“（联想深度优先遍历）
在此基础上，动态规划问题还有一些判断的“加分项”。 
- 问题包含最大（小）或最多（少）等最优化描述。 
- 问题的状态能够使用一个列表、多维矩阵或树来表示，并且一个状态与其周围的状态存在递推关系。 
相应地，也存在一些“减分项”。 
- 问题的目标是找出所有可能的解决方案，而不是找出最优解。 
- 问题描述中有明显的排列组合的特征，需要返回具体的多个方案。
如果一个问题满足决策树模型，并具有较为明显的“加分项”，我们就可以假设它是一个动态规划问题，并在求解过程中验证它。 
##### 问题求解步骤
主要步骤：
- 描述决策
- 定义状态
- 建立 𝑑𝑝 表
- 推导状态转移方程
- 确定边界条件
主要题型
- **最小路径和**：网格路径，从左上到右下
- **0-1背包**：每个物品选一次，倒序遍历
- **完全背包**：物品可重复选，正序遍历
- **零钱兑换**：最小硬币数，恰好凑满
- **零钱兑换II**：组合数量，求和运算
- **编辑距离**：字符串操作，三种编辑方式
### 最短路径和（重点在首行首列和其他行列）
##### 思路
给定一个 𝑛 × 𝑚 的二维网格 grid ，网格中的每个单元格包含一个非负整数，表示该单元格的代价。 机器人以左上角单元格为起始点，每次只能向下或者向右移动一步，直至到达右下角单元格。请返回 从左上角到右下角的最小路径和。
![[Pasted image 20251117164506.png]]
**第一步：思考每轮的决策，定义状态，从而得到 𝑑𝑝 表**
![[Pasted image 20251117164719.png]]
**第二步：找出最优子结构，进而推导出状态转移方程**
<center>𝑝[𝑖, 𝑗] = min(𝑑𝑝[𝑖 − 1, 𝑗], 𝑑𝑝[𝑖, 𝑗 − 1]) + 𝑔𝑟𝑖𝑑[𝑖, 𝑗] </center>
**第三步：确定边界条件和状态转移顺序**
本题中，处在首行的状态只能从其左边的状态得来，处在首列的状态只能从其上边的状态得来，因此首行 𝑖 = 0 和首列 𝑗 = 0 是边界条件
**代码实现：**
##### 暴力：
- 递归参数：状态 `[i, j]` 表示当前网格位置
- 返回值：从 `[0,0]` 到 `[i,j]` 的最小路径和
- 终止条件：当到达左上角 `[0,0]` 时返回 `grid[0][0]`
- 剪枝：当索引越界时返回 `INT_MAX` 代表不可行
- 时间复杂度：最差为 `O(2^(m+n))`
```cpp
/* 最小路径和：暴力搜索 */
int minPathSumDFS(vector<vector<int>> &grid, int i, int j) {
    // 若为左上角单元格，则终止搜索
    if (i == 0 && j == 0) {
        return grid[0][0];
    }
    // 若行列索引越界，则返回 +∞ 代价
    if (i < 0 || j < 0) {
        return INT_MAX;
    }
    // 计算从左上角到 (i-1, j) 和 (i, j-1) 的最小路径代价
    int up = minPathSumDFS(grid, i - 1, j);
    int left = minPathSumDFS(grid, i, j - 1);
    // 返回从左上角到 (i, j) 的最小路径代价
    return min(left, up) != INT_MAX ? min(left, up) + grid[i][j] : INT_MAX;
}
```
##### 记忆化搜索
- 引入记忆列表 `mem` 记录子问题的解,`mem` 在包装函数 `minPathSum` 中初始化
- 如果某个状态已经计算过，直接返回结果
- 避免重复计算重叠子问题
- 时间复杂度：`O(nm)`，取决于网格尺寸
```cpp
/* 最小路径和：记忆化搜索 */
int minPathSumDFSMem(vector<vector<int>> &grid, vector<vector<int>> &mem, int i, int j) {
    // 若为左上角单元格，则终止搜索
    if (i == 0 && j == 0) {
        return grid[0][0];
    }
    // 若行列索引越界，则返回 +∞ 代价
    if (i < 0 || j < 0) {
        return INT_MAX;
    }
    // 若已有记录，则直接返回
    if (mem[i][j] != -1) {
        return mem[i][j];
    }
    // 左边和上边单元格的最小路径代价
    int up = minPathSumDFSMem(grid, mem, i - 1, j);
    int left = minPathSumDFSMem(grid, mem, i, j - 1);
    // 记录并返回左上角到 (i, j) 的最小路径代价
    mem[i][j] = min(left, up) != INT_MAX ? min(left, up) + grid[i][j] : INT_MAX;
    return mem[i][j];
}
```
##### 动态规划
- 初始化：`dp[0][0] = grid[0][0]`
- 首行：只能从左边来，`dp[0][j] = dp[0][j-1] + grid[0][j]`
- 首列：只能从上边来，`dp[i][0] = dp[i-1][0] + grid[i][0]`
- 其他位置：`dp[i][j] = min(左边, 上边) + grid[i][j]`
- 时间复杂度：`O(nm)`，空间复杂度：`O(nm)`
```cpp
/* 最小路径和：动态规划 */
int minPathSumDP(vector<vector<int>> &grid) {
    int n = grid.size(), m = grid[0].size();
    // 初始化 dp 表
    vector<vector<int>> dp(n, vector<int>(m));
    dp[0][0] = grid[0][0];
    // 状态转移：首行
    for (int j = 1; j < m; j++) {
        dp[0][j] = dp[0][j - 1] + grid[0][j];
    }
    // 状态转移：首列
    for (int i = 1; i < n; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }
    // 状态转移：其余行和列
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < m; j++) {
            dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];
        }
    }
    return dp[n - 1][m - 1];
}
```
##### 空间优化
- 只使用一维数组 `dp` 存储当前行的状态
- 每行处理时更新首列：`dp[0] = dp[0] + grid[i][0]`
- 其他列：`dp[j] = min(左边dp[j-1],上边dp[j]) + grid[i][j]`
- 空间复杂度优化为：`O(m)`
```cpp
/* 最小路径和：空间优化后的动态规划 */
int minPathSumDPComp(vector<vector<int>> &grid) {
    int n = grid.size(), m = grid[0].size();
    // 初始化 dp 表，只存储当前行的最小路径和
    //dp[j]表示到达当前行第j列的最小路径和
    vector<int> dp(m);
    // 状态转移：首行
    dp[0] = grid[0][0];
    for (int j = 1; j < m; j++) {
        dp[j] = dp[j - 1] + grid[0][j];
        //当前最小路径和 = 左边的最小路径和 + 当前格子值
    }
    // 状态转移：其余行
    //dp[j-1]：从左边来的最小路径和
    //dp[j]：从上面来的最小路径和（注意：此时的dp[j]还是上一行的值）
    //min(dp[j-1], dp[j])：选择更小的路径
    //+ grid[i][j]：加上当前格子的值
    for (int i = 1; i < n; i++) {
        // 状态转移：首列
        dp[0] = dp[0] + grid[i][0];
        // 状态转移：其余列
        for (int j = 1; j < m; j++) {
        //除了首行和首列
            dp[j] = min(dp[j - 1], dp[j]) + grid[i][j];
        }
    }
    return dp[m - 1];
}
```
### 0-1背包问题（和爬楼梯2相似）
- 每个物品只能选一次
- 状态转移：`dp[i][c] = max(不选, 选)`
- 空间优化需要**倒序**遍历，避免重复选择
**定 𝑛 个物品，第 𝑖 个物品的重量为 𝑤𝑔𝑡[𝑖 − 1]、价值为 𝑣𝑎𝑙[𝑖 − 1] ，和一个容量为 𝑐𝑎𝑝 的背包。每 个物品只能选择一次，问在限定背包容量下能放入物品的最大价值。**
![[Pasted image 20251117190526.png]]
我们可以将 0‑1 背包问题看作一个由 𝑛 轮决策组成的过程，对于每个物体都有不放入和放入两种决策，因此 该问题满足决策树模型
该问题的目标是求解“在限定背包容量下能放入物品的最大价值”，因此较大概率是一个动态规划问题。

**第一步：思考每轮的决策，定义状态，从而得到 𝑑𝑝 表**
定义：当前物品 编号 𝑖 和背包容量 𝑐 ，记为 [𝑖, 𝑐] 
当前 𝑖 个物品在容量为 𝑐 的背包中的最大价值，记为 𝑑𝑝[𝑖, 𝑐]
待求解的是 𝑑𝑝[𝑛, 𝑐𝑎𝑝] ，因此需要一个尺寸为 (𝑛 + 1) × (𝑐𝑎𝑝 + 1) 的二维 𝑑𝑝 表
**第二步：找出最优子结构，进而推导出状态转移方程**
当我们做出物品 𝑖 的决策后，剩余的是前 𝑖 − 1 个物品决策的子问题，可分为以下两种情况。 
- 不放入物品 𝑖 ：背包容量不变，状态变化为 [𝑖 − 1, 𝑐] 。 
- 放入物品 𝑖 ：背包容量减少 𝑤𝑔𝑡[𝑖 − 1] ，价值增加 𝑣𝑎𝑙[𝑖 − 1] ，状态变化为 [𝑖 − 1, 𝑐 − 𝑤𝑔𝑡[𝑖 − 1]]
最大价值 𝑑𝑝[𝑖, 𝑐] 等于不放入物品 𝑖 和放入物品 𝑖 两种方案中价值更大的那一个。由此可推导出状态转移方程： 
<center>𝑑𝑝[𝑖, 𝑐] = max(𝑑𝑝[𝑖 − 1, 𝑐], 𝑑𝑝[𝑖 − 1, 𝑐 − 𝑤𝑔𝑡[𝑖 − 1]] + 𝑣𝑎𝑙[𝑖 − 1])</center>
若当前物品重量 𝑤𝑔𝑡[𝑖 − 1] 超出剩余背包容量 𝑐 ，则只能选择不放入背包。
**第三步：确定边界条件和状态转移顺序**
当无物品或背包容量为 0 时最大价值为 0 ，即首列 𝑑𝑝[𝑖, 0] 和首行 𝑑𝑝[0, 𝑐] 都等于0。 当前状态 [𝑖, 𝑐] 从上方的状态 [𝑖 − 1, 𝑐] 和左上方的状态 [𝑖 − 1, 𝑐 − 𝑤𝑔𝑡[𝑖 − 1]] 转移而来，因此通过两层循 环正序遍历整个 𝑑𝑝 表即可。
```cpp
  容量c: 0  1  2  3  4  5
物品i=0: 0  0  0  0  0  0
物品i=1: 0
物品i=2: 0
物品i=3: 0
```
##### 暴力
```cpp
/* 0-1 背包：暴力搜索 */
int knapsackDFS(vector<int> &wgt, vector<int> &val, int i, int c) {
    // 若已选定所有物品或背包无剩余容量，则返回价值 0
    // i:编号，c:背包容量
    if (i == 0 || c == 0) {
        return 0;
    }
    // wgt：重量
    // val：价格
    // 若超过背包容量，则只能选择不放入背包
    if (wgt[i - 1] > c) {
        return knapsackDFS(wgt, val, i - 1, c);
    }
    // 计算不放入和放入物品 i 的最大价值
    int no = knapsackDFS(wgt, val, i - 1, c);
    int yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1];
    // 返回两种方案中价值更大的那一个
    return max(no, yes);
}
```
![[Pasted image 20251117192847.png]]
##### 记忆化搜索
```cpp
/* 0-1 背包：记忆化搜索 */
int knapsackDFSMem(vector<int> &wgt, vector<int> &val, vector<vector<int>> &mem, int i, int c) {
    // 若已选完所有物品或背包无剩余容量，则返回价值 0
    if (i == 0 || c == 0) {
        return 0;
    }
    // 若已有记录，则直接返回
    if (mem[i][c] != -1) {
        return mem[i][c];
    }
    // 若超过背包容量，则只能选择不放入背包
    if (wgt[i - 1] > c) {
        return knapsackDFSMem(wgt, val, mem, i - 1, c);
    }
    // 计算不放入和放入物品 i 的最大价值
    int no = knapsackDFSMem(wgt, val, mem, i - 1, c);
    int yes = knapsackDFSMem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1];
    // 记录并返回两种方案中价值更大的那一个
    mem[i][c] = max(no, yes);
    return mem[i][c];
}
```
##### 动态规划
动态规划实质上就是在状态转移中填充 𝑑𝑝 表的过程
for (int c = 1; c <= cap; c++)为什么要从1开始?
因为首行首列的情况已经被边界处理过了

```cpp
/* 0-1 背包：动态规划 */
int knapsackDP(vector<int> &wgt, vector<int> &val, int cap) {
    int n = wgt.size();
    // 初始化 dp 表
    vector<vector<int>> dp(n + 1, vector<int>(cap + 1, 0));
    // 状态转移
    for (int i = 1; i <= n; i++) {
        for (int c = 1; c <= cap; c++) {//c:剩余背包容量
            if (wgt[i - 1] > c) {
                // 若超过背包容量，则不选物品 i
                dp[i][c] = dp[i - 1][c];
            } else {
                // 不选和选物品 i 这两种方案的较大值
                dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1]);
            }
        }
    }
    return dp[n][cap];
}
```
##### 优化
```cpp
/* 0-1 背包：空间优化后的动态规划 */
int knapsackDPComp(vector<int> &wgt, vector<int> &val, int cap) {
    int n = wgt.size();
    // 初始化 dp 表
    vector<int> dp(cap + 1, 0);
    // 状态转移
    for (int i = 1; i <= n; i++) {
        // 倒序遍历
        for (int c = cap; c >= 1; c--) {
            if (wgt[i - 1] <= c) {
                // 不选和选物品 i 这两种方案的较大值
                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);
            }
        }
    }
    return dp[cap];
}
```
i = 1：
```cpp
c=1: wgt[0]=2 > 1 → dp[1][1] = dp[0][1] = 0
c=2: max(dp[0][2]=0, dp[0][0]+3=3) = 3
c=3: max(dp[0][3]=0, dp[0][1]+3=3) = 3
c=4: max(dp[0][4]=0, dp[0][2]+3=3) = 3
c=5: max(dp[0][5]=0, dp[0][3]+3=3) = 3
```
i = 2:
```cpp
c=1: wgt[1]=3 > 1 → dp[2][1] = dp[1][1] = 0
c=2: wgt[1]=3 > 2 → dp[2][2] = dp[1][2] = 3
c=3: max(dp[1][3]=3, dp[1][0]+4=4) = 4
c=4: max(dp[1][4]=3, dp[1][1]+4=4) = 4
c=5: max(dp[1][5]=3, dp[1][2]+4=7) = 7
```
i = 3:
```cpp
c=1-3: 物品太重，继承上一行
c=4: max(dp[2][4]=4, dp[2][0]+5=5) = 5
c=5: max(dp[2][5]=7, dp[2][1]+5=5) = 7
```
### 完全背包问题
- 物品可以重复选择
- 状态转移：`dp[i][c] = max(dp[i-1][c], dp[i][c-wgt]+val)`
- 空间优化需要**正序**遍历，允许重复选择
给定 𝑛 个物品，第 𝑖 个物品的重量为 𝑤𝑔𝑡[𝑖 − 1]、价值为 𝑣𝑎𝑙[𝑖 − 1] ，和一个容量为 𝑐𝑎𝑝 的背包。每 个物品可以重复选取，问在限定背包容量下能放入物品的最大价值。
![[Pasted image 20251117210204.png]]
##### 思路
在 0‑1 背包问题中，每种物品只有一个，因此将物品 𝑖 放入背包后，只能从前 𝑖 − 1 个物品中选择。而在完全背包问题中，每种物品的数量是无限的，因此将物品 𝑖 放入背包后，仍可以从前 𝑖 个物品中选择
在完全背包问题的规定下，状态 [𝑖, 𝑐] 的变化分为两种情况。 
- 不放入物品 𝑖 ：与 0‑1 背包问题相同，转移至 [𝑖 − 1, 𝑐] 。 
- 放入物品 𝑖 ：与 0‑1 背包问题不同，转移至 [𝑖, 𝑐 − 𝑤𝑔𝑡[𝑖 − 1]] 。
<center>𝑑𝑝[𝑖, 𝑐] = max(𝑑𝑝[𝑖 − 1, 𝑐], 𝑑𝑝[𝑖, 𝑐 − 𝑤𝑔𝑡[𝑖 − 1]] + 𝑣𝑎𝑙[𝑖 − 1])</center>

##### 动态规划
```cpp
/* 完全背包：动态规划 */
int unboundedKnapsackDP(vector<int> &wgt, vector<int> &val, int cap) {
    int n = wgt.size();
    // 初始化 dp 表
    vector<vector<int>> dp(n + 1, vector<int>(cap + 1, 0));
    // 状态转移
    for (int i = 1; i <= n; i++) {
        for (int c = 1; c <= cap; c++) {
            if (wgt[i - 1] > c) {
                // 若超过背包容量，则不选物品 i
                dp[i][c] = dp[i - 1][c];
            } else {
                // 不选和选物品 i 这两种方案的较大值
                dp[i][c] = max(dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1]);
            }
        }
    }
    return dp[n][cap];
}
```
优化：
```cpp
/* 完全背包：空间优化后的动态规划 */
int unboundedKnapsackDPComp(vector<int> &wgt, vector<int> &val, int cap) {
    int n = wgt.size();
    // 初始化 dp 表
    vector<int> dp(cap + 1, 0);
    // 状态转移
    for (int i = 1; i <= n; i++) {
        for (int c = 1; c <= cap; c++) {
            if (wgt[i - 1] <= c) {
                // 不选和选物品 i 这两种方案的较大值
                dp[c] = max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);
            }
        }
    }
    return dp[cap];
}
```
#### 特例：零钱兑换问题
- 求最**少**硬币数量，使用 `min()` 而非 `max()`
- 初始化：`dp[0] = 0`，其他为 `MAX`（表示不可达）
- 是恰好凑满问题，不是不超过容量
给定 𝑛 种硬币，第 𝑖 种硬币的面值为 𝑐𝑜𝑖𝑛𝑠[𝑖 − 1] ，目标金额为 𝑎𝑚𝑡 ，每种硬币可以重复选取，问 能够凑出目标金额的最少硬币数量。如果无法凑出目标金额，则返回 −1 。
![[Pasted image 20251117212602.png]]
##### 思路
零钱兑换可以看作完全背包问题的一种特殊情况
两道题可以相互转换：
- “物品”对应“硬币”、“物品重量”对应“硬币面值”、“背包容量”对应“目标金 额”。 
- 优化目标相反，完全背包问题是要最大化物品价值，零钱兑换问题是要最小化硬币数量。 
- 完全背包问题是求“不超过”背包容量下的解，零钱兑换是求“恰好”凑到目标金额的解。
**第一步：思考每轮的决策，定义状态，从而得到 𝑑𝑝 表**
状态 [𝑖, 𝑎] 对应的子问题为：前 𝑖 种硬币能够凑出金额 𝑎 的最少硬币数量，记为 𝑑𝑝[𝑖, 𝑎] 。 二维 𝑑𝑝 表的尺寸为 (𝑛 + 1) × (𝑎𝑚𝑡 + 1) 。

**第二步：找出最优子结构，进而推导出状态转移方程**
本题与完全背包问题的状态转移方程存在以下两点差异。 
- 本题要求最小值，因此需将运算符 max() 更改为 min() 。 
- 优化主体是硬币数量而非商品价值，因此在选中硬币时执行 +1 即可。 
<center>𝑑𝑝[𝑖, 𝑎] = min(𝑑𝑝[𝑖 − 1, 𝑎], 𝑑𝑝[𝑖, 𝑎 − 𝑐𝑜𝑖𝑛𝑠[𝑖 − 1]] + 1)</center>
**第三步：确定边界条件和状态转移顺序**
当目标金额为 0 时，凑出它的最少硬币数量为 0 ，即首列所有 𝑑𝑝[𝑖, 0] 都等于 0 。 当无硬币时，无法凑出任意 > 0 的目标金额，即是无效解。为使状态转移方程中的 min() 函数能够识别并 过滤无效解，我们考虑使用 +∞ 来表示它们，即令首行所有 𝑑𝑝[0, 𝑎] 都等于 +∞。
##### 动态规划问题
我们采用数字 𝑎𝑚𝑡 + 1 来表示无效解，因为凑出 𝑎𝑚𝑡 的硬币数量最多为 𝑎𝑚𝑡 。最后返回前，判断 𝑑𝑝[𝑛, 𝑎𝑚𝑡] 是否等于 𝑎𝑚𝑡 + 1 ，若是则返回 −1 ，代表无法凑出目标金额。
```cpp
/* 零钱兑换：动态规划 */
int coinChangeDP(vector<int> &coins, int amt) {
    int n = coins.size();
    int MAX = amt + 1;//无效解
    // 初始化 dp 表
    vector<vector<int>> dp(n + 1, vector<int>(amt + 1, 0));
    // 状态转移：首行首列
    for (int a = 1; a <= amt; a++) {
        dp[0][a] = MAX;
    }
    // 状态转移：其余行和列
    for (int i = 1; i <= n; i++) {
        for (int a = 1; a <= amt; a++) {
            if (coins[i - 1] > a) {
                // 若超过目标金额，则不选硬币 i
                dp[i][a] = dp[i - 1][a];
            } else {
                // 不选和选硬币 i 这两种方案的较小值
                dp[i][a] = min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);
            }
        }
    }
    return dp[n][amt] != MAX ? dp[n][amt] : -1;
}
```

##### 空间优化动态规划
```cpp
/* 零钱兑换：空间优化后的动态规划 */
int coinChangeDPComp(vector<int> &coins, int amt) {
    int n = coins.size();
    int MAX = amt + 1;
    // 初始化 dp 表
    vector<int> dp(amt + 1, MAX);
    dp[0] = 0;
    // 状态转移
    for (int i = 1; i <= n; i++) {
        for (int a = 1; a <= amt; a++) {
            if (coins[i - 1] <= a) {
                // 不选和选硬币 i 这两种方案的较小值
                dp[a] = min(dp[a], dp[a - coins[i - 1]] + 1);
            }
        }
    }
    return dp[amt] != MAX ? dp[amt] : -1;
}
```
#### 零钱兑换 II（组合数量）
给定 𝑛 种硬币，第 𝑖 种硬币的面值为 𝑐𝑜𝑖𝑛𝑠[𝑖 − 1] ，目标金额为 𝑎𝑚𝑡 ，每种硬币可以重复选取，问凑出目标金额的硬币组合数量。
![[Pasted image 20251117215415.png]]
##### 思路
相比于上一题，本题目标是求组合数量，因此子问题变为：前 𝑖 种硬币能够凑出金额 𝑎 的组合数量。而 𝑑𝑝 表仍然是尺寸为 (𝑛 + 1) × (𝑎𝑚𝑡 + 1) 的二维矩阵。 
当前状态的组合数量等于不选当前硬币与选当前硬币这两种决策的组合数量之和。状态转移方程为：
<center>𝑑𝑝[𝑖, 𝑎] = 𝑑𝑝[𝑖 − 1, 𝑎] + 𝑑𝑝[𝑖, 𝑎 − 𝑐𝑜𝑖𝑛𝑠[𝑖 − 1]] </center>
当目标金额为 0 时，无须选择任何硬币即可凑出目标金额，因此应将首列所有 𝑑𝑝[𝑖, 0] 都初始化为 1 。
当无硬币时，无法凑出任何 > 0 的目标金额，因此首行所有 𝑑𝑝[0, 𝑎] 都等于 0。
##### 动态规划
```cpp
/* 零钱兑换 II: 动态规划 */
int coinChangeIIDP(vector<int> &coins, int amt) {
    int n = coins.size();
    // 初始化 dp 表
    vector<vector<int>> dp(n + 1, vector<int>(amt + 1, 0));
    // 初始化首列
    for (int i = 0; i <= n; i++) {
        dp[i][0] = 1;
    }
    // 状态转移
    for (int i = 1; i <= n; i++) {
        for (int a = 1; a <= amt; a++) {
            if (coins[i - 1] > a) {
                // 若超过目标金额，则不选硬币 i
                dp[i][a] = dp[i - 1][a];
            } else {
                // 不选和选硬币 i 这两种方案之和
                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]];
            }
        }
    }
    return dp[n][amt];
}
```
##### 优化
```cpp
/* 零钱兑换 II: 空间优化后的动态规划 */
int coinChangeIIDPComp(vector<int> &coins, int amt) {
    int n = coins.size();
    // 初始化 dp 表
    vector<int> dp(amt + 1, 0);
    dp[0] = 1;
    // 状态转移
    for (int i = 1; i <= n; i++) {
        for (int a = 1; a <= amt; a++) {
            if (coins[i - 1] <= a) {
                // 不选和选硬币 i 这两种方案之和
                dp[a] = dp[a] + dp[a - coins[i - 1]];
            }
        }
    }
    return dp[amt];
}
```
### 编辑距离问题(Levenshtein 距离)（最短路径）
指两个字符串之间互相转换的最少修改次数。
输入两个字符串 𝑠 和 𝑡 ，返回将 𝑠 转换为 𝑡 所需的最少编辑步数。 你可以在一个字符串中进行三种编辑操作：插入一个字符、删除一个字符、将字符替换为任意一个字符。
![[Pasted image 20251117223428.png]]
##### 动态规划
- 三种操作：插入、删除、替换
- 字符相同时直接继承左上角的值
- 字符不同时取左、上、左上三个方向的最小值 + 1
- 空间优化需要特殊处理，使用 `leftup` 保存左上角值
##### 思路
**第一步：思考每轮的决策，定义状态，从而得到 𝑑𝑝 表**
每一轮的决策是对字符串 𝑠 进行一次编辑操作。 我们希望在编辑操作的过程中，问题的规模逐渐缩小，这样才能构建子问题。
设字符串 𝑠 和 𝑡 的长度分别为 𝑛 和 𝑚 ，我们先考虑两字符串尾部的字符 𝑠[𝑛 − 1] 和 𝑡[𝑚 − 1] 。 
- 若 𝑠[𝑛 − 1] 和 𝑡[𝑚 − 1] 相同，我们可以跳过它们，直接考虑 𝑠[𝑛 − 2] 和 𝑡[𝑚 − 2] 。 
- 若 𝑠[𝑛 − 1] 和 𝑡[𝑚 − 1] 不同，我们需要对 𝑠 进行一次编辑（插入、删除、替换），使得两字符串尾部 的字符相同，从而可以跳过它们，考虑规模更小的问题。 
也就是说，我们在字符串 𝑠 中进行的每一轮决策（编辑操作），都会使得 𝑠 和 𝑡 中剩余的待匹配字符发生变化。
因此，状态为当前在 𝑠 和 𝑡 中考虑的第 𝑖 和第 𝑗 个字符，记为 [𝑖, 𝑗] 。 
状态 [𝑖, 𝑗] 对应的子问题：将 𝑠 的前 𝑖 个字符更改为 𝑡 的前 𝑗 个字符所需的最少编辑步数。 
至此，得到一个尺寸为 (𝑖 + 1) × (𝑗 + 1) 的二维 𝑑𝑝 表。
**第二步：找出最优子结构，进而推导出状态转移方程**
考虑子问题 𝑑𝑝[𝑖, 𝑗] ，其对应的两个字符串的尾部字符为 𝑠[𝑖 − 1] 和 𝑡[𝑗 − 1] ，可根据不同编辑操作分为图 14‑29 所示的三种情况。 
1. 在 𝑠[𝑖 − 1] 之后添加 𝑡[𝑗 − 1] ，则剩余子问题 𝑑𝑝[𝑖, 𝑗 − 1] 。 
2. 删除 𝑠[𝑖 − 1] ，则剩余子问题 𝑑𝑝[𝑖 − 1, 𝑗] 。 
3. 将 𝑠[𝑖 − 1] 替换为 𝑡[𝑗 − 1] ，则剩余子问题 𝑑𝑝[𝑖 − 1, 𝑗 − 1] 。
![[Pasted image 20251117223903.png]]
根据以上分析，可得最优子结构：𝑑𝑝[𝑖, 𝑗] 的最少编辑步数等于 𝑑𝑝[𝑖, 𝑗 − 1]、𝑑𝑝[𝑖 − 1, 𝑗]、𝑑𝑝[𝑖 − 1, 𝑗 − 1] 三者中的最少编辑步数，再加上本次的编辑步数 1 。对应的状态转移方程为：
<center>𝑑𝑝[𝑖, 𝑗] = min(𝑑𝑝[𝑖, 𝑗 − 1], 𝑑𝑝[𝑖 − 1, 𝑗], 𝑑𝑝[𝑖 − 1, 𝑗 − 1]) + 1 </center>
请注意，当 𝑠[𝑖 − 1] 和 𝑡[𝑗 − 1] 相同时，无须编辑当前字符，这种情况下的状态转移方程为： 
<center>𝑑𝑝[𝑖, 𝑗] = 𝑑𝑝[𝑖 − 1, 𝑗 − 1]</center>
**第三步：确定边界条件和状态转移顺序**
当两字符串都为空时，编辑步数为 0 ，即 𝑑𝑝[0, 0] = 0 。当 𝑠 为空但 𝑡 不为空时，最少编辑步数等于 𝑡 的长度，即首行 𝑑𝑝[0, 𝑗] = 𝑗 。当 𝑠 不为空但 𝑡 为空时，最少编辑步数等于 𝑠 的长度，即首列 𝑑𝑝[𝑖, 0] = 𝑖 。 观察状态转移方程，解 𝑑𝑝[𝑖, 𝑗] 依赖左方、上方、左上方的解，因此通过两层循环正序遍历整个 𝑑𝑝 表即可。
![[Pasted image 20251117224357.png]]
##### 动态规划 
```cpp
/* 编辑距离：动态规划 */
int editDistanceDP(string s, string t) {
    int n = s.length(), m = t.length();
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
    // 状态转移：首行首列
    for (int i = 1; i <= n; i++) {
        dp[i][0] = i;
    }
    for (int j = 1; j <= m; j++) {
        dp[0][j] = j;
    }
    // 状态转移：其余行和列
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (s[i - 1] == t[j - 1]) {
                // 若两字符相等，则直接跳过此两字符
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                // 最少编辑步数 = 插入、删除、替换这三种操作的最少编辑步数 + 1
                dp[i][j] = min(min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;
            }
        }
    }
    return dp[n][m];
}
```
##### 优化
```cpp
/* 编辑距离：空间优化后的动态规划 */
int editDistanceDPComp(string s, string t) {
    int n = s.length(), m = t.length();
    vector<int> dp(m + 1, 0);
    // 状态转移：首行
    for (int j = 1; j <= m; j++) {
        dp[j] = j;
    }
    // 状态转移：其余行
    for (int i = 1; i <= n; i++) {
        // 状态转移：首列
        int leftup = dp[0]; // 暂存 dp[i-1, j-1]
        dp[0] = i;
        // 状态转移：其余列
        for (int j = 1; j <= m; j++) {
            int temp = dp[j];
            if (s[i - 1] == t[j - 1]) {
                // 若两字符串相等，则直接跳过此两字符
                dp[j] = leftup;
            } else {
                // 最少编辑步数 = 插入、删除、替换这三种操作的最少编辑步数 + 1
                dp[j] = min(min(dp[j - 1], dp[j]), leftup) + 1;
            }
            leftup = temp; // 更新为下一轮的 dp[i-1, j-1]
        }
    }
    return dp[m];
}
```





# 【算法笔记】
#####  动态规划的递归写法和递推写法

**代码示例**（斐波那契递归写法，记忆化）：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXV = 1000;
int dp[MAXV];  // 全局记忆化数组，初始化为-1

int F(int n) {
    if (n == 0 || n == 1) return 1;
    if (dp[n] != -1) return dp[n];  // 已计算，直接返回
    return dp[n] = F(n-1) + F(n-2);  // 记忆化
}

int main() {
    memset(dp, -1, sizeof(dp));
    int n; cin >> n;
    cout << F(n) << endl;
    return 0;
}
```


**应用提示**：适合树形/递归问题，如矩阵路径。LeetCode 509: Fibonacci Number。

##### 11.1.3 动态规划的递推写法
**定义与性质**：  
递推（Bottom-Up）从边界开始，逐层填充表格，避免递归栈开销。示例：n×n三角形矩阵，从底层向上求从(1,1)到(n,n)的最大路径和（每步只能下或右下）。

**算法步骤**：  
1. 输入n和矩阵f[1..n][1..n]。  
2. 初始化边界：dp[n][j] = f[n][j]（底层直接取值）。  
3. 从i = n-1 到1，反向填充：dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + f[i][j]。  
4. 输出dp[1][1]。

**时间/空间复杂度**：O(n^2) 时间/空间，可优化空间至O(n)（只存当前/上一行）。

**代码示例**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1000;
int f[MAXN][MAXN], dp[MAXN][MAXN];

int main() {
    int n; scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= i; j++)  // 注意：三角形，j <= i
            scanf("%d", &f[i][j]);
    for (int j = 1; j <= n; j++) dp[n][j] = f[n][j];  // 边界
    for (int i = n-1; i >= 1; i--)
        for (int j = 1; j <= i; j++)
            dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + f[i][j];
    printf("%d\n", dp[1][1]);
    return 0;
}
```

**应用提示**：路径规划问题。LeetCode 64: Minimum Path Sum（类似）。

---

#### 11.2 最大连续子序列和
**定义与性质**：  
求数组A[1..n]中连续子序列的最大和。性质：以每个A[i]结尾的子序列要么接续前一个，要么重新开始。

**算法步骤**（Kadane算法变体）：  
1. 初始化dp[0] = A[0]，ans = A[0]。  
2. 对于i=1到n：dp[i] = max(A[i], dp[i-1] + A[i])，ans = max(ans, dp[i])。  
3. 输出ans。

**时间/空间复杂度**：O(n) 时间，O(1) 空间（优化后）。

**代码示例**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int A[N], dp[N];

int main() {
    int n; scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &A[i]);
    dp[1] = A[1]; int ans = A[1];
    for (int i = 2; i <= n; i++) {
        dp[i] = max(A[i], dp[i-1] + A[i]);
        ans = max(ans, dp[i]);
    }
    printf("%d\n", ans);
    return 0;
}
```

**应用提示**：股票最大利润（LeetCode 53: Maximum Subarray）。

---

#### 11.3 最长不下降子序列 (LIS)
**定义与性质**：  
求数组A[1..n]中最长非严格递增子序列长度（不下降）。性质：dp[i] = 以A[i]结尾的LIS长度，转移：max(dp[j] + 1, j < i 且 A[i] >= A[j])。

**算法步骤**：  
1. dp[i] = 1（初始化）。  
2. 对于i=1到n，对于j=1到i-1，若A[i] >= A[j]，dp[i] = max(dp[i], dp[j]+1)。  
3. ans = max(dp[i])。

**时间/空间复杂度**：O(n^2) 时间/空间，优化可用O(n log n) 二分（笔记未详）。

**代码示例**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100;
int A[N], dp[N];

int main() {
    int n; scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &A[i]);
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        dp[i] = 1;
        for (int j = 1; j < i; j++)
            if (A[i] >= A[j]) dp[i] = max(dp[i], dp[j] + 1);
        ans = max(ans, dp[i]);
    }
    printf("%d\n", ans);
    return 0;
}
```

**应用提示**：序列匹配。LeetCode 300: Longest Increasing Subsequence。

---

#### 11.4 最长公共子序列 (LCS)
**定义与性质**：  
两个字符串A[1..m]和B[1..n]的最长公共子序列（非连续）。性质：dp[i][j] = A[1..i]与B[1..j]的LCS长度。

**算法步骤**：  
1. dp[0][*] = dp[*][0] = 0。  
2. 对于i=1到m，j=1到n：  
   - 若A[i]==B[j]，dp[i][j] = dp[i-1][j-1] + 1。  
   - 否则，dp[i][j] = max(dp[i-1][j], dp[i][j-1])。  
3. 输出dp[m][n]。

**时间/空间复杂度**：O(mn) 时间/空间，可优化空间至O(min(m,n))。

**代码示例**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100;
char A[N], B[N];
int dp[N][N];

int main() {
    scanf("%s%s", A+1, B+1);
    int m = strlen(A+1), n = strlen(B+1);
    for (int i = 0; i <= m; i++) dp[i][0] = 0;
    for (int j = 0; j <= n; j++) dp[0][j] = 0;
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++) {
            if (A[i] == B[j]) dp[i][j] = dp[i-1][j-1] + 1;
            else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
        }
    printf("%d\n", dp[m][n]);
    return 0;
}
```

**应用提示**：文本比较。LeetCode 1143: Longest Common Subsequence。

---

#### 11.5 最长回文字符串
**定义与性质**：  
字符串S[0..len-1]的最长回文子串长度。性质：dp[i][j] = S[i..j]是否回文（1/0）。

**算法步骤**：  
1. 初始化：dp[i][i]=1；若S[i]==S[i+1]，dp[i][i+1]=1，ans=2。  
2. 对于长度L=3到len：对于i=0到len-L，j=i+L-1，若S[i]==S[j]且dp[i+1][j-1]==1，则dp[i][j]=1，ans=L。  
3. 输出ans。

**时间/空间复杂度**：O(n^2) 时间/空间，Manacher算法可O(n)优化（笔记未提）。

**代码示例**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1010;
char S[MAXN];
int dp[MAXN][MAXN];

int main() {
    scanf("%s", S);
    int len = strlen(S), ans = 1;
    memset(dp, 0, sizeof(dp));
    for (int i = 0; i < len; i++) {
        dp[i][i] = 1;
        if (i < len-1 && S[i] == S[i+1]) {
            dp[i][i+1] = 1; ans = 2;
        }
    }
    for (int L = 3; L <= len; L++)
        for (int i = 0; i + L - 1 < len; i++) {
            int j = i + L - 1;
            if (S[i] == S[j] && dp[i+1][j-1]) {
                dp[i][j] = 1; ans = L;
            }
        }
    printf("%d\n", ans);
    return 0;
}
```

**应用提示**：字符串对称。LeetCode 5: Longest Palindromic Substring。

---

#### 11.7 背包问题

##### 11.7.2 01背包问题
**定义与性质**：  
n件物品，每件体积w[i]、价值c[i]，背包容量V，求最大价值（每件选或不选）。性质：dp[i][v] = 前i件恰好v容量的最大价值。

**算法步骤**（一维优化）：  
1. dp[0..V] = 0。  
2. 对于i=1到n，对于v=V downto w[i]：dp[v] = max(dp[v], dp[v - w[i]] + c[i])。  
3. 输出max(dp[v])（或dp[V]若求恰好）。

**时间/空间复杂度**：O(nV) 时间，O(V) 空间。

**代码示例**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100, V = 1000;
int w[N], c[N], dp[V+1];

int main() {
    int n, VV; scanf("%d%d", &n, &VV);
    for (int i = 1; i <= n; i++) scanf("%d%d", &w[i], &c[i]);
    for (int i = 1; i <= n; i++)
        for (int v = VV; v >= w[i]; v--)
            dp[v] = max(dp[v], dp[v - w[i]] + c[i]);
    printf("%d\n", dp[VV]);
    return 0;
}
```

**应用提示**：资源分配。LeetCode 416: Partition Equal Subset Sum。

##### 11.7.3 完全背包问题
**定义与性质**：  
同01背包，但每件无限件。转移：允许重复选。

**算法步骤**：  
1. dp[0..V] = 0。  
2. 对于i=1到n，对于v=w[i]到V：dp[v] = max(dp[v], dp[v - w[i]] + c[i])（正序）。  
3. 输出dp[V]。

**时间/空间复杂度**：O(nV) 时间，O(V) 空间。

**代码示例**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100, V = 1000;
int w[N], c[N], dp[V+1];

int main() {
    int n, VV; scanf("%d%d", &n, &VV);
    for (int i = 1; i <= n; i++) scanf("%d%d", &w[i], &c[i]);
    for (int i = 1; i <= n; i++)
        for (int v = w[i]; v <= VV; v++)  // 正序枚举
            dp[v] = max(dp[v], dp[v - w[i]] + c[i]);
    printf("%d\n", dp[VV]);
    return 0;
}
```

**应用提示**：无限资源。LeetCode 322: Coin Change（最小硬币变体）。

---

#### 11.8 总结与扩展
本章强调DP的“状态-转移-计算”三要素，适用于序列/组合问题。扩展：区间DP（矩阵乘法）、树形DP（树背包）、状态压缩DP（TSP）。练习时，先手写状态定义，避免“维度爆炸”。如果需要LeetCode对应题或视频资源，随时补充！
# 题型总结

## 11.1 线性 DP（最基础）

| 子节              | 典型模型            | 状态定义                                                 | 转移方程                                                          | 初始化          | 例题            |
| --------------- | --------------- | ---------------------------------------------------- | ------------------------------------------------------------- | ------------ | ------------- |
| **11.1.1 01背包** | 容量有限选物品         | `dp[i][w]`：前 `i` 件物品，背包容量 `w` 的最大价值                  | `dp[i][w] = max(dp[i-1][w], dp[i-1][w−weight[i]] + value[i])` | `dp[0][*]=0` | LC 416（子集划分）  |
| **11.1.2 完全背包** | 物品无限            | `dp[w] = max(dp[w], dp[w−weight[i]] + value[i])`（正序） | 同上                                                            | `dp[0]=0`    | LC 322（零钱兑换）  |
| **11.1.3 多重背包** | 每件物品有限 `cnt[i]` | 二进制拆分或单调队列优化                                         | ——                                                            | ——           | LC 2787（拆分硬币） |

**滚动数组优化（空间 O(W)）**

```cpp
// 01背包（倒序）
for (int i = 1; i <= n; ++i)
    for (int w = W; w >= weight[i]; --w)
        dp[w] = max(dp[w], dp[w - weight[i]] + value[i]);
```

---

## 11.2 区间 DP

**定义**：`dp[l][r]` 表示区间 `[l, r]` 的最优值。  
**枚举长度 → 枚举左端点 → 枚举分割点**。

| 典型题      | 转移                                                           | 例题      |
| -------- | ------------------------------------------------------------ | ------- |
| **石子合并** | `dp[l][r] = min(dp[l][k] + dp[k+1][r] + sum[l..r])`          | LC 1000 |
| **矩阵链乘** | `dp[l][r] = min(dp[l][k] + dp[k+1][r] + p[l]*p[k+1]*p[r+1])` | 经典教材    |

```cpp
for (int len = 2; len <= n; ++len)           // 长度
    for (int l = 1; l + len - 1 <= n; ++l) { // 左端点
        int r = l + len - 1;
        for (int k = l; k < r; ++k)          // 枚举分割
            dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r] + cost(l,k,r));
    }
```

---

## 11.3 树形 DP

**两类**：  
1. **换根 DP**（先以任意根算，再换根）  
2. **背包式树上 DP**（子树背包合并）

| 典型题 | 状态 | 转移 | 例题 |
|--------|------|------|------|
| **树上最大独立集** | `dp[u][0/1]`：以 `u` 为根，选/不选 `u` 的最大值 | `dp[u][1] = val[u] + Σ dp[v][0]` <br> `dp[u][0] = Σ max(dp[v][0], dp[v][1])` | LC 337（打家劫舍 III） |
| **树上背包** | `dp[u][j]`：子树 `u` 选 `j` 个节点的方案数/价值 | 类似 01 背包合并 | LC 2787 变种 |

```cpp
void dfs(int u, int fa) {
    dp[u][1] = val[u];
    for (int v : adj[u]) if (v != fa) {
        dfs(v, u);
        // 合并：倒序防止覆盖
        for (int j = sz[u]; j >= 0; --j)
            for (int k = 0; k <= sz[v]; ++k)
                if (j >= k) dp[u][j] = max(dp[u][j], dp[u][j-k] + dp[v][k]);
        sz[u] += sz[v];
    }
}
```

---

## 11.4 数位 DP

**状态**：`dp[pos][tight][state]`  
- `pos`：当前填到第几位（从高到低）  
- `tight`：是否贴着上界（1=是，0=否）  
- `state`：题目特定限制（前导零、数字和、出现 4 等）

**记忆化搜索模板**

```cpp
using ll = long long;
ll dfs(int pos, bool tight, int state) {
    if (pos == -1) return state_ok(state) ? 1 : 0;
    if (!tight && memo[pos][state] != -1) return memo[pos][state];
    int up = tight ? digit[pos] : 9;
    ll res = 0;
    for (int d = 0; d <= up; ++d) {
        int nstate = update(state, d);
        res += dfs(pos-1, tight && (d==up), nstate);
    }
    if (!tight) memo[pos][state] = res;
    return res;
}
```

**例题**：LC 2376（统计特殊整数）

---

## 11.5 状态压缩 DP（状压 DP）

**适用**：`n ≤ 20`，状态可压缩成二进制掩码。

| 典型题 | 状态 | 转移 |
|--------|------|------|
| **旅行商 TSP** | `dp[mask][u]`：已访问集合 `mask`，当前在 `u` 的最短路径 | `dp[mask][u] = min over v in mask (dp[mask^1<<v][v] + dist[v][u])` |
| **子集和计数** | `dp[mask]`：子集 `mask` 的方案数 | 枚举子集 |

**位运算枚举子集**

```cpp
for (int mask = 0; mask < (1<<n); ++mask) {
    for (int sub = mask; sub; sub = (sub-1) & mask) {
        // sub 是 mask 的非空子集
    }
}
```

---

## 11.6 斜率优化 & 凸包技巧 DP

**适用**：转移形如 `dp[i] = min_j (b[j]*a[i] + c[j])`，`a[i]` 单调。

```cpp
// 维护下凸包，队首决策点
struct Line { ll k, b; };
deque<Line> q;
ll calc(const Line& l, ll x) { return l.k * x + l.b; }
```

---

## 11.7 常见套路 & 题目分类

| 套路 | 关键词 | 代表题 |
|------|--------|--------|
| **计数** | “方案数”、“组合数” | LC 940 |
| **最值** | “最大/小利润” | LC 123 |
| **存在性** | “能否” | LC 416 |
| **构造** | “字典序最小” | LC 1884 |

---

## 11.8 代码模板汇总（直接拷贝）

```cpp
// 1. 01背包（滚动）
vector<int> dp(W+1, 0);
for (int i = 0; i < n; ++i)
    for (int w = W; w >= wt[i]; --w)
        dp[w] = max(dp[w], dp[w-wt[i]] + val[i]);

// 2. 区间DP
vector<vector<int>> dp(n+1, vector<int>(n+1, INF));
for (int i = 1; i <= n; ++i) dp[i][i] = 0;
for (int len = 2; len <= n; ++len)
    for (int l = 1; l + len - 1 <= n; ++l) {
        int r = l + len - 1;
        for (int k = l; k < r; ++k)
            dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r] + cost(l,k,r));
    }

// 3. 树上背包（DFS+滚动）
void dfs(int u, int fa) {
    sz[u] = 1; dp[u][0] = 0; dp[u][1] = val[u];
    for (int v : adj[u]) if (v != fa) {
        dfs(v, u);
        for (int j = sz[u]; j >= 0; --j)
            for (int k = 0; k <= sz[v]; ++k)
                if (j >= k) dp[u][j] = max(dp[u][j], dp[u][j-k] + dp[v][k]);
        sz[u] += sz[v];
    }
}
```

---

## 推荐刷题顺序（精选 15 题）

| 顺序  | 题目                   | 考察点          |
| --- | -------------------- | ------------ |
| 1   | LC 300（最长递增子序列）      | 线性 DP + 贪心   |
| 2   | LC 416（分割等和子集）       | 01 背包        |
| 3   | LC 322（零钱兑换）         | 完全背包         |
| 4   | LC 1143（最长公共子序列）     | 经典二维         |
| 5   | LC 1000（最小代价合并石子）    | 区间 DP        |
| 6   | LC 337（打家劫舍 III）     | 树形 DP        |
| 7   | LC 2376（统计特殊整数）      | 数位 DP        |
| 8   | LC 943（最短超级串）        | 状压 DP        |
| 9   | LC 123（买卖股票最佳时机 III） | 有限状态机 DP     |
| 10  | LC 188（买卖股票 IV）      | 状态压缩         |
| 11  | LC 879（盈利计划）         | 背包 + 取模      |
| 12  | LC 968（监控二叉树）        | 树形贪心+DP      |
| 13  | LC 174（地下城游戏）        | 倒推 DP        |
| 14  | LC 132（分割回文串 II）     | 区间 DP + 预处理  |
| 15  | LC 546（移除盒子）         | 区间 DP + 状态压缩 |

---

**记忆口诀**（背下来即可快速定位模型）：

> **背包看容量，区间看长度，树上看子树，数位看位数，状压看掩码，斜率看单调。**


# 算法图解
什么是动态规划？也许有点难以想象。
现在是2025.11.28
现在的我，对动态规划的理解大概是：
- 线性
- 非线性
### 先说线性：
举一个最近刚做的题
力扣53，求数组中的最大子数组和，这是一个很典型的线性动态规划：
一句话总结：保持最后最大
从动态规划的定义我们可以知道，动态规划就是把一个大问题分解成几个小问题，把最后的问题一步步向前推，分而治之。
从这道题上是怎么体现的呢？
首先，一个无序的数组含有正数和负数，
假设我们从下标0开始，如果下一个数是正数，很好，继续往后
当下一关数是负数，糟糕，不能再往后加了。
再回到定义，最后如何呢找到最大的连续子序列和呢？
那就保持每一步的最后一个元素是在这个元素即已经遍历过元素最大的连续子序列和
怎么实现？
与经典的动态规划相同，动态规划的特点主要体现在分成2/3中情况
这里，分成两种情况：
- 如果 前面的累加和(正能量) + 我自己 > 我自己(另起炉灶)：那就**接上**（哪怕我是负数，只要前面的正能量够大，能罩得住我，我就接）。
- 如果 前面的累加和 + 我自己 < 我自己（说明前面的累加和已经是巨大的负债了）：那就**踢开前面**，从我这里重新开始。
同时，创建一个整型变量maxsum，初始化为0
记录当前找到的最大数组和
下标0已经初始化，所以从1开始
- dp[i] = max(nums[i], dp[i-1] + nums[i])
### 再说非线性：
动态规划的问题，例如背包问题，相同字符串问题等等，因为其有两个变量，很容易想到转化成非线性的矩阵。
##### 先看背包问题 大背包->小背包
- **核心逻辑**：要不要偷这件商品？
    - 如果不偷：最大价值 = 没放这件商品时的价值（看**正上方**）。
    - 如果偷：最大价值 = 商品价值 + 剩余空间能装的最大价值（看**上一行，对应剩余重量的列**）。
![[Pasted image 20251128150200.png]]
背包能装的重量从1开始到最大重量n结束，为列
物品为行
画完表格后我们很容易看出，最终答案就在最后一个格子里
![[Pasted image 20251128150413.png]]
```python
# 伪代码 - 0/1 背包
# rows: 物品 (吉他, 音响, 电脑)
# cols: 背包容量 (1kg, 2kg, 3kg, 4kg)

for i in range(物品数量):       # 遍历每一行
    for w in range(背包容量):   # 遍历每一列
        
        # 1. 如果背包装不下当前物品 (当前物品重量 > 当前格子容量 w)
        if weight[i] > w:
            cell[i][w] = cell[i-1][w]  # 只能抄上面 (继承之前的最优解)
        
        # 2. 如果装得下，就要权衡：偷 vs 不偷
        else:
            不偷的价值 = cell[i-1][w]  # 抄上面
            
            # 这里的 cell[i-1][w - weight[i]] 就是“剩余空间的最大价值”
            偷的价值 = value[i] + cell[i-1][w - weight[i]] 
            
            cell[i][w] = max(不偷的价值, 偷的价值)

# 最终答案在右下角
return cell[物品数量-1][背包容量-1]
```
##### 最长公共子串
- **关键词**：**连续**。
- **核心逻辑**：只有当两个字母**完全一样**时，我才能在“左上角”的基础上 +1。如果不一祥，说明连续断了，直接归零。
![[Pasted image 20251128150924.png]]
```python
# 伪代码 - 最长公共子串 (fish vs hish)
# 只要断了，就清零

global_max = 0  # 因为答案不一定在右下角，要随时记录最大值

for i in range(text1长度):
    for j in range(text2长度):
        
        # 1. 字母相同！ (比如 'i' == 'i')
        if text1[i] == text2[j]:
            # 看左上角 (即 i-1, j-1) 的状态，延续下来
            cell[i][j] = cell[i-1][j-1] + 1
            
            # 更新历史最大值
            if cell[i][j] > global_max:
                global_max = cell[i][j]
                
        # 2. 字母不同 (比如 'f' != 'h')
        else:
            cell[i][j] = 0  # 连续性中断，直接归零！

return global_max
```
这个问题的最终答案并不在最后一个单元格中！ 对于前面的背包问题，最终答案总是在最后的单元格中。但对于最长 公共子串问题，答案为网格中最大的数字——它可能并不位于最后的单元格中.
##### 最长公共子序列
有点绕晕了，这是什么？怎么长得这么像？
- **最长公共子序列**：追求的是 **“顺序”** 的匹配。字符可以不连续，但先后顺序必须一致。它衡量的是两个序列的相似性。
- **最长公共子串**：追求的是 **“连续”** 的匹配。字符必须是连续的片段。它衡量的是两个序列中完全相同的片段。
所以：
- **关键词**：**顺序 (可断开)**。
- **核心逻辑**：
    - 字母一样：太好了，长度 +1 (继承左上角)。
    - 字母不一样：虽然这里没匹配上，但我可以**继承**之前的最大成果（看**左边**或者**上边**谁大，就抄谁）。

![[Pasted image 20251128150747.png]]
```python
# 伪代码 - 最长公共子序列 (fosh vs fish)
# 即使不同，也能继承遗产

for i in range(text1长度):
    for j in range(text2长度):
        
        # 1. 字母相同！
        if text1[i] == text2[j]:
            # 毫无疑问，长度 +1
            cell[i][j] = cell[i-1][j-1] + 1
            
        # 2. 字母不同！(这是与子串最大的区别)
        else:
            # 虽然此时 text1[i] 和 text2[j] 配不上
            # 但也许 text1的前面 和 text2 已经配上了 (看上边)
            # 或者 text1 和 text2的前面 已经配上了 (看左边)
            # 谁大听谁的
            cell[i][j] = max(cell[i-1][j], cell[i][j-1])

# 最终答案一定在右下角，因为它继承了所有的历史
return cell[text1长度-1][text2长度-1]
```
# [邋遢大哥]([邋遢大哥233的个人空间-邋遢大哥233个人主页-哔哩哔哩视频](https://space.bilibili.com/490057508/search?keyword=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92))