# 一.排序
## 1.冒泡排序
模板：
```cpp      
void bubbleSort(vector<T>& arr) {
    int n = arr.size();
    // 外层循环：控制排序轮数
    for (int i = 0; i < n - 1; i++) {
        // 内层循环：比较相邻元素
        for (int j = 0; j < n - 1 - i; j++) {
            // 如果前面的元素比后面大，就交换它们
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}
```
## 2.选择排序
![[Pasted image 20251105180715.png]]
```cpp
void selectionSort(vector<int>& arr) {
    int n = arr.size();
    // 外层循环：控制已排序部分的边界
    for (int i = 0; i < n - 1; i++) {
        // 假设当前i位置是最小元素的位置
        int minIndex = i;   
        // 内层循环：在未排序部分寻找真正的最小元素
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;  // 更新最小元素的位置
            }
        }
        // 将找到的最小元素与当前位置交换
        swap(arr[i], arr[minIndex]);
    }
}
```
## 3. 插入排序
```cpp
void insertionSort(vector<int>& arr) {
    int n = arr.size();
    // 从第二个元素开始（第一个元素默认已排序）
    for (int i = 1; i < n; i++) {
        int key = arr[i];  // 当前要插入的元素
        int j = i - 1; 
        // 将比key大的元素都向后移动一位
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        } 
        // 将key插入到正确位置
        arr[j + 1] = key;
    }
}
```
## 4. 排序函数sort（排序字符串，还能处理数组、向量等多种容器）
### 使用方法：
```cpp
sort(a + m,a + n);
sort(a + m,a + n, map);//cmp是函数 或仿函数
```
- 对于标准库容器（例如`vector`），我们通常使用`begin()`和`end()`成员函数来获取迭代器，从而指定排序范围
- 对于普通数组，我们可以使用指针来指定排序范围，即数组的首地址和尾后地址。
a + m：数组名加一个数字代表这个数字下标的地址
```cpp
a + m == &a[m]; 
```
### 当sort需要降序排列时，可以使用比较函数。
PS:
```cpp
// 字符串（C风格）
char str[] = "Hello";
// 字符串数组
char strings[3][10] = {"Hello", "World", "C++"};
// 或者
char* str_array[] = {"Apple", "Banana", "Cherry"};
```
例如：
```cpp
// 自定义比较函数 - 降序
bool cmp(int a, int b) {
    return a > b;  // 如果a>b，a排在前面（降序）
}
int main() {
    vector<int> nums = {3, 1, 4, 1, 5, 9, 2, 6}; 
    // 使用自定义比较函数
    sort(nums.begin(), nums.end(), cmp);  
    cout << "降序排序结果: ";
    for(int num : nums) {
        cout << num << " ";
    }
    cout << endl;   
    return 0;
}
```
此外还有两种方法：
### 使用 `greater<>()` 函数对象
```cpp
int main() {
    vector<int> nums = {3, 1, 4, 1, 5, 9, 2, 6};
    // 使用 greater<int>() 实现降序排序
    sort(nums.begin(), nums.end(), greater<int>());
    cout << "降序排序结果: ";
    for(int num : nums) {
        cout << num << " ";
    }
    cout << endl;
    return 0;
}
```
### 使用 Lambda 表达式（C++11+）
```cpp
int main() {
    vector<int> nums = {3, 1, 4, 1, 5, 9, 2, 6};
    // 使用 Lambda 表达式
    sort(nums.begin(), nums.end(), [](int a, int b) {
        return a > b;  // 降序
    });
    cout << "降序排序结果: ";
    for(int num : nums) {
        cout << num << " ";
    }
    cout << endl;
    return 0;
}
```
###  计算排名（假设已经按分数降序排序完成）
两种常用方法：
#### 方法一：记录排名到结构体
(结构体：
```cpp
struct 结构体名 {
    数据类型1 成员名1;
    数据类型2 成员名2;
    // ...
};
```
)
首先，我们需要在结构体中添加一个专门的字段来存储排名信息：
```cpp
struct Student {
    char name[20];    // 姓名
    int id;           // 学号
    int score;        // 分数
    int rank;         // 排名 - 这就是记录排名的字段
};
```
PS：为什么要创建结构体？
![[Pasted image 20251105195333.png]]
```cpp
stu[0].r = 1;  // 先将数组的第一个个体排名记为1
for(int i = 1; i < n; i++)//遍历剩余个体 
{
    if(stu[i].score == stu[i - 1].score) {
        stu[i].r = stu[i - 1].r;  // 如果当前个体的分数等于上一个个体的分数，那么当前个体的排名等于上一个个体的排名
    } else {
        stu[i].r = i + 1;  // 分数不同，当前个体的排名为数组下标+1
    }
}
```
#### 方法二：直接输出排名（不储存）
```cpp
int r = 1;
for(int i = 0; i < n; i++) {
    if(i > 0 && stu[i].score != stu[i - 1].score) {
        r = i + 1;  // 更新排名
    }
    // 输出：排名r，其他信息...
}
```
### 两种方法对比：![[Pasted image 20251105194912.png]]
### 【PAT A1025 Ranking】
**题目大意：有n个考场，每个考场有若干数量的学生，给出每个考场中考生的编号和分数，要求算排名，输出所有考生的编号、排名、考场号、考场内排名**  
1. 将所有考生按**分数从高到低**排序
2. 输出时包含：**准考证号、总排名、考场号、考场内排名**    
3. 如果分数相同，按**准考证号从小到大**排序
### 核心思想：**两次排序**
- **第一次排序**：每个考场内部排序，计算考场内排名
- **第二次排序**：所有考生一起排序，计算总排名
#### 晴神宝典上的解法：
**先定义一个学生结构体**
```cpp
struct Student {
    char id[15];          // 准考证号
    int score;            // 分数
    int location_number;  // 考场号
    int local_rank;       // 考场内排名
} stu[30010];             // 定义结构体同时声明数组，防止溢出
```
**创建一个比较函数cmp**
```cpp
bool cmp(Student a, Student b) {
    if(a.score != b.score) 
        return a.score > b.score;    // 分数高的在前
    else 
        return strcmp(a.id, b.id) < 0; // 分数相同时，准考证号小的在前
        //这里使用strcmp是因为id是字符数组（C风格字符串）。如果id是C++的string类型，则可以直接使用a.id < b.id。
}
```
**取每个考场数据并计算考场内排名**
```cpp
int n, k, num = 0;  // n:考场数, k:当前考场人数, num:总考生数
scanf("%d", &n);    // 读入考场数
for(int i = 1; i <= n; i++) {
    scanf("%d", &k);  // 读入当前考场人数   
    // 读入当前考场所有考生信息
    for(int j = 0; j < k; j++) {
        scanf("%s %d", stu[num].id, &stu[num].score);
        stu[num].location_number = i;  // 记录考场号
        num++;  // 总考生数增加
    }
    // 对当前考场的学生排序（局部排序）
    sort(stu + num - k, stu + num, cmp);
    // 计算考场内排名
    stu[num - k].local_rank = 1;  // 第一名排名为1
    for(int j = num - k + 1; j < num; j++) {
        if(stu[j].score == stu[j - 1].score) {
            // 分数相同，排名相同
            stu[j].local_rank = stu[j - 1].local_rank;
        } else {
            // 分数不同，排名为当前在考场内的位置
            stu[j].local_rank = j + 1 - (num - k);
        }
    }
}
```
PS：(scanf("%s %d", stu[num].id, &stu[num].score)为什么要取地址？
 1. 字符串（`%s`）不需要 `&`。**原因**：在C语言中，**数组名就是数组首元素的地址**
 2. 基本数据类型需要 `&`。(int)
 ```cpp
 #include <stdio.h>
int main() {
    int a;
    int arr[10];
    char str[100];
    int *p = &a;
    // 需要&的情况
    scanf("%d", &a);      // a是整型变量，需要&
    scanf("%d", &arr[0]); // arr[0]是整型数组元素，需要&
    // 不需要&的情况
    scanf("%s", str);     // str是字符数组，不需要&
    scanf("%d", p);       // p是指针，已经指向a的地址，不需要&
    scanf("%d", arr);     // arr是数组名，表示数组首地址，不需要&（但这里读取的是第一个元素）
    return 0;
}
 ```
 ![[Pasted image 20251107130740.png]])
**对所有考生进行全局排序**
```cpp
sort(stu, stu + num, cmp);  // 对所有考生排序
```
**计算总排名并输出**
```cpp
int r = 1;  // 当前排名
for(int i = 0; i < num; i++) {
    // 更新排名：如果分数不同，更新为当前位置+1
    if(i > 0 && stu[i].score != stu[i - 1].score) {
        r = i + 1;
    }
    // 输出结果
    printf("%s ", stu[i].id);                    // 准考证号
    printf("%d %d %d\n", r,                     // 总排名
                        stu[i].location_number, // 考场号  
                        stu[i].local_rank);     // 考场内排名
}
```
#### 柳神的解法：(动态数组)
**分析：先按照考场内排名 然后赋值给总数组fin，然后总排名，最后输出。注意相同的分数情况下按照学号的从小到大排列，但是他们的排名应该是一样的数字**
```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
struct student {
    long long int no;
    int score, finrank, loca, locarank;
};
bool cmp1(student a, student b) {
    return a.score != b.score ? a.score > b.score : a.no < b.no;
}
int main() {
    int n, m;
    scanf("%d", &n);
    vector<student> fin;
    for(int i = 1; i <= n; i++) {
        scanf("%d", &m);
        vector<student> v(m);
        for(int j = 0; j < m; j++) {
            scanf("%lld %d", &v[j].no, &v[j].score);
            v[j].loca = i;
        }
        sort(v.begin(), v.end(), cmp1);
        v[0].locarank = 1;
        fin.push_back(v[0]);
        for(int j = 1; j < m; j++) {
            v[j].locarank = (v[j].score == v[j - 1].score) ? (v[j - 1].locarank) : (j + 1);
            fin.push_back(v[j]);
        }
    }
    sort(fin.begin(), fin.end(), cmp1);
    fin[0].finrank = 1;
    for(int j = 1; j < fin.size(); j++)
        fin[j].finrank = (fin[j].score == fin[j - 1].score) ? (fin[j - 1].finrank) : (j + 1);
    printf("%d\n", fin.size());
    for(int i = 0; i < fin.size(); i++)
        printf("%013lld %d %d %d\n", fin[i].no, fin[i].finrank, fin[i].loca, fin[i].locarank);
    return 0;
}
```
- **`v[0].locarank = 1`**：设置**当前考场**的第1名
- **`fin[0].finrank = 1`**：设置**所有考生**的第1名
(说实话没看懂，暂时存疑)
## 5.桶排序
![[13190717624302682.png]]
![[Screenshot_2025-11-06-19-59-39-75_149003a2d400f6adb210d7e357a3a646.jpg]]
```cpp
#include <iostream>
#include <vector>
using namespace std;
int main() {
    const int MAX_SIZE = 1001;
    vector<int> book(MAX_SIZE, 0); // 使用vector代替数组
    int n, t;  
    cin >> n; // 输入一个数n，表示接下来有n个数 
    // 循环读入n个数，并进行桶排序
    for (int i = 0; i < n; i++) {
        cin >> t; // 把每一个数读到变量t中
        if (t >= 0 && t < MAX_SIZE) { // 添加边界检查
            book[t]++; // 进行计数，对编号为t的桶计数
        }
    } 
    // 依次判断编号1000~0的桶，降序输出
    for (int i = MAX_SIZE - 1; i >= 0; i--) {
        // 出现了几次就将桶的编号打印几次
        for (int j = 0; j < book[i]; j++) {
            cout << i << " ";
        }
    } 
    cout << endl; // 输出换行
    return 0;
}
```
## 6.快速排序do…while
**分成大于等于x，小于等于x两部分**
![[Screenshot_2025-11-06-20-35-55-56_149003a2d400f6adb210d7e357a3a646.jpg]]
![[Screenshot_2025-11-06-20-37-55-91_149003a2d400f6adb210d7e357a3a646.jpg]]

![[Screenshot_2025-11-06-20-46-37-46_149003a2d400f6adb210d7e357a3a646.jpg]]
代码块:
```cpp
void quicksort(int arr[], int l, int r)//第l个数，第r个数
{
    if (l >= r)//数组里面没有数或者只有一个数
        return;
    int x = arr[(l + r) / 2], i = l - 1, j = r + 1;
    while (i < j)
    {
        do
            i++;
        while (arr[i] < x);
        do
            j--;
        while (arr[j] > x);
        if (i < j)
            swap(arr[i], arr[j]);
    }
    quicksort(arr, l, j);
    quicksort(arr, j + 1, r);
}
```
PS:do while:
```cpp
do {
    // 循环体
} while (条件);
```
## 7.选择排序
**选择排序的核心思想是**：
每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。
算法步骤
1. 在未排序序列中找到最小元素
2. 将其与未排序序列的第一个元素交换位置
3. 将序列的已排序部分扩大一个元素，未排序部分缩小一个元素
4. 重复上述过程，直到所有元素排序完成
**代码块**：
```cpp
void selection_sort(int arr[], int l, int r)
{
    for (int i = l; i <= r - 1; i++)
    {
        int j_min = i;
        for (int j = i + 1; j <= r; j++)
        {
            if (arr[j] < arr[j_min])
                j_min = j;
        }
        if (j_min != i)
            swap(arr[i], arr[j_min]);
    }
}
```
## 8.插入排序
插入排序是一种简单直观的排序算法，它的工作方式类似于我们整理扑克牌：
将每个元素插入到已排序序列中的适当位置，从而逐步构建有序序列。
算法步骤
1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5
```cpp
void insertion_sort(int arr[], int l, int r)
{
    for (int i = l + 1; i <= r; i++)
    {
        int num = arr[i];
        int j = i - 1;
        while (j >= l && num < arr[j])
        {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = num;
    }
}
```
## 9.归并排序
![[IMG_20251107_100037.jpg]]
![[Screenshot_2025-11-07-10-12-12-88_149003a2d400f6adb210d7e357a3a646.jpg]]
```cpp
const int MAXN = 100;
int tmp[MAXN];
void merge_sort(int arr[], int l, int r)
{
    if (l >= r)
        return;
    int mid = (l + r) / 2;
    merge_sort(arr, l, mid);
    merge_sort(arr, mid + 1, r);
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r)
    {
        if (arr[i] <= arr[j])
            tmp[k++] = arr[i++];
        else
            tmp[k++] = arr[j++];
    }
    while (i <= mid)
        tmp[k++] = arr[i++];
    while (j <= r)
        tmp[k++] = arr[j++];
    for (int m = l, n = 0; m <= r; m++, n++)
        arr[m] = tmp[n];
}
```
![[22364917642448562.png]]
![[22608917642448502.png]]
```cpp
#include <vector>
#include <iostream>
#include <limits>
using namespace std;

// 对应伪代码的 MERGE 函数
void MERGE(vector<int>& A, int l, int m, int r) {
    // 快速复制左半部分 A[l..m-1]
    vector<int> L(A.begin() + l, A.begin() + m);
    // 快速复制右半部分 A[m..r-1]
    vector<int> R(A.begin() + m, A.begin() + r);
    
    // 添加哨兵值（正无穷）
    L.push_back(numeric_limits<int>::max());
    R.push_back(numeric_limits<int>::max());
    
    int i = 0, j = 0;
    // 合并两个有序数组
    for (int k = l; k < r; k++) {
        if (L[i] <= R[j]) {
            A[k] = L[i];
            i++;
        } else {
            A[k] = R[j];
            j++;
        }
    }
}

// 对应伪代码的 MERGESORT 函数
void MERGESORT(vector<int>& A, int l, int r) {
    if (r - l <= 1) return;
    
    int m = (l + r) / 2;
    MERGESORT(A, l, m);
    MERGESORT(A, m, r);
    MERGE(A, l, m, r);
}

int main() {
    vector<int> A = {8, 1, 7, 4, 5, 2, 3, 6};
    
    cout << "原始数组: ";
    for (int num : A) cout << num << " ";
    cout << endl;
    
    MERGESORT(A, 0, A.size());
    
    cout << "排序后: ";
    for (int num : A) cout << num << " ";
    cout << endl;
    
    return 0;
}
```
# 排序的实际应用（不看模板，看模板有时候不会写主函数）
## 快速排序算法实现

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

const int N = 100010;  // 根据题目数据范围，N最大为10^5

int n;
int q[N];  // 存储待排序的数组

// 快速排序函数
void quick_sort(int q[], int l, int r) {
    if (l >= r) return;  // 如果区间只有一个元素或为空，直接返回
    
    // 1. 选择基准元素（这里选择中间元素）
    int mid = (l + r) >> 1;  // 等价于 (l + r) / 2
    int pivot = q[mid];  // 基准元素
    
    // 2. 初始化左右指针
    int i = l - 1, j = r + 1;
    
    // 3. 分区操作
    while (i < j) {
        // 从左向右找到第一个大于等于基准的元素
        do i++; while (q[i] < pivot);
        // 从右向左找到第一个小于等于基准的元素
        do j--; while (q[j] > pivot);
        // 如果i<j，交换这两个元素
        if (i < j) swap(q[i], q[j]);
    }
    
    // 4. 递归排序左右两部分
    quick_sort(q, l, j);      // 排序左半部分
    quick_sort(q, j + 1, r);  // 排序右半部分
}

int main() {
    // 读取输入
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &q[i]);
    }
    
    // 调用快速排序
    quick_sort(q, 0, n - 1);
    
    // 输出结果
    for (int i = 0; i < n; i++) {
        printf("%d ", q[i]);
    }
    printf("\n");
    
    return 0;
}
```

### 快速排序算法详解

#### 算法步骤：
1. **选择基准元素（pivot）**
   - 可以选择第一个、最后一个、中间或随机元素
   - 这里选择中间元素，避免最坏情况

2. **分区操作**
   - 将所有比基准小的元素放在基准左边
   - 所有比基准大的元素放在基准右边
   - 基准元素处于正确位置

3. **递归排序**
   - 对基准左边的子数组递归排序
   - 对基准右边的子数组递归排序

#### 时间复杂度分析：
- **平均情况**：O(n log n)
- **最坏情况**（已排序数组，选择边界元素作为基准）：O(n²)
- **最好情况**（每次都能均匀划分）：O(n log n)

#### 空间复杂度：
- 递归调用栈深度：O(log n)（平均情况）
- 最坏情况：O(n)

### 其他排序算法实现

#### 1. 冒泡排序
```cpp
void bubble_sort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        bool swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        // 如果没有发生交换，说明已排序完成
        if (!swapped) break;
    }
}
```

#### 2. 选择排序
```cpp
void selection_sort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int min_idx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        swap(arr[i], arr[min_idx]);
    }
}
```

#### 3. 插入排序
```cpp
void insertion_sort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

#### 4. 归并排序
```cpp
void merge(int arr[], int l, int mid, int r) {
    int n1 = mid - l + 1;
    int n2 = r - mid;
    int L[n1], R[n2];
    
    for (int i = 0; i < n1; i++) L[i] = arr[l + i];
    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];
    
    int i = 0, j = 0, k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k++] = L[i++];
        } else {
            arr[k++] = R[j++];
        }
    }
    
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}

void merge_sort(int arr[], int l, int r) {
    if (l < r) {
        int mid = l + (r - l) / 2;
        merge_sort(arr, l, mid);
        merge_sort(arr, mid + 1, r);
        merge(arr, l, mid, r);
    }
}
```

#### 5. 桶排序（适用于均匀分布的数据）
```cpp
void bucket_sort(float arr[], int n) {
    // 1. 创建n个空桶
    vector<float> buckets[n];
    
    // 2. 将元素放入不同的桶中
    for (int i = 0; i < n; i++) {
        int idx = n * arr[i];
        buckets[idx].push_back(arr[i]);
    }
    
    // 3. 对每个桶排序
    for (int i = 0; i < n; i++) {
        sort(buckets[i].begin(), buckets[i].end());
    }
    
    // 4. 将桶中元素合并
    int index = 0;
    for (int i = 0; i < n; i++) {
        for (float num : buckets[i]) {
            arr[index++] = num;
        }
    }
}
```

#### 6. 堆排序
```cpp
void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;
    
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heap_sort(int arr[], int n) {
    // 构建最大堆
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    // 一个个提取元素
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}
```

### 各排序算法比较

| 算法 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 稳定性 | 适用场景 |
|------|---------------|---------------|------------|--------|----------|
| 快速排序 | O(n log n) | O(n²) | O(log n) | 不稳定 | 通用排序，大数据量 |
| 归并排序 | O(n log n) | O(n log n) | O(n) | 稳定 | 大数据量，需要稳定性 |
| 堆排序 | O(n log n) | O(n log n) | O(1) | 不稳定 | 内存有限，大数据量 |
| 冒泡排序 | O(n²) | O(n²) | O(1) | 稳定 | 小数据量，几乎已排序 |
| 选择排序 | O(n²) | O(n²) | O(1) | 不稳定 | 小数据量 |
| 插入排序 | O(n²) | O(n²) | O(1) | 稳定 | 小数据量，几乎已排序 |

### 输入输出示例

输入：
```
5
3 1 4 1 5
```

输出：
```
1 1 3 4 5
```

### 注意事项

1. **题目要求**：必须自己实现快速排序，不能使用STL的`sort`
2. **基准选择**：选择中间元素可以避免已排序数组的最坏情况
3. **递归深度**：最坏情况下递归深度可能达到O(n)，但平均为O(log n)
4. **边界条件**：注意递归终止条件`l >= r`
5. **交换操作**：使用`swap`函数或手动交换元素值

这个快速排序实现是经典的Hoare分区方案，在实际应用中性能良好。
# 二.散列（hash）
==默认使用`unordered_map` 和 `unordered_set`==
==**有序/按顺序遍历/低性能就用`set`/`map`**==
==**无序/仅需要快速查找/高性能就用`unordered_map` 和 `unordered_set`**==
## 1. 散列的基本概念

散列是一种将元素（如整数、字符串等）通过一个函数（散列函数）转换为整数，使得该整数可以尽量唯一地代表这个元素的算法思想。==这个转换函数称为散列函数H，转换前的元素称为key，转换后的整数称为H(key)。==
**核心思想：**用空间换时间**，将查询复杂度从 O(N) 降到 O(1)**
## 2. 整数散列的简单应用
==创建hashTable数组，n和m中的元素为下标，来对这个数的性质进行统计==
**给出 N 个正整数，再给出 M 个正整数，判断 M 中的每个数是否在 N 中出现过**
```cpp
#include <cstdio>
const int maxn = 100010;
	bool hashTable[maxn] = {false};//初始状态下，正整数x在N个正整数中没有出现过
int main() {
    int n, m, x;
    scanf("%d%d", &n, &m);
    // 预处理：标记出现过的数字
    for(int i = 0; i < n; i++) {
        scanf("%d", &x);
        hashTable[x] = true;
    }
    // 查询
    for(int i = 0; i < m; i++) {
        scanf("%d", &x);
        if(hashTable[x]) {
            printf("YES\n");
        } else {
            printf("NO\n");
        }
    }
    return 0;
}
```
PS：代码中每个 `&` 的作用：
1. `scanf("%d%d", &n, &m);`
    这里 `&n` 和 `&m` 分别获取变量 `n` 和 `m` 的地址。这样 `scanf` 就可以将读取的两个整数分别存储到变量 `n` 和 `m` 中。    
2. `scanf("%d", &x);`（在第一个 for 循环中）
	 这里 `&x` 获取变量 `x` 的地址，以便将读取的整数存储到 `x` 中。   
3. `scanf("%d", &x);`（在第二个 for 循环中）
    同样，这里 `&x` 获取变量 `x` 的地址，以便将读取的整数存储到 `x` 中。
**如果要统计每个数出现的次数，只需稍作修改：**
```cpp
#include <cstdio>
const int maxn = 100010;
int hashTable[maxn] = {0};
int main() {
    int n, m, x;
    scanf("%d%d", &n, &m);
    for(int i = 0; i < n; i++) {
        scanf("%d", &x);
        hashTable[x]++;  // 计数
    }
    for(int i = 0; i < m; i++) {
        scanf("%d", &x);
        printf("%d\n", hashTable[x]);  // 直接输出次数
    }
    return 0;
}
```
此时，**时间复杂度**：O(N + M)  **空间复杂度**：取决于数值范围
## 3. 散列函数的设计
![[Pasted image 20251106101514.png]]
### 常用散列函数方法：
1. **直接定址法**
    - 恒等变换：`H(key) = key`
    - 线性变换：`H(key) = a × key + b`
2. **平方取中法**
    - 取 key 平方的中间若干位作为 hash 值
3. **除留余数法**（最实用）
    - `H(key) = key % mod`
    - mod 通常取素数，TSize（表长）≥ mod
## 4. 冲突（Collision）处理
当不同 key 映射到相同 hash 值时，产生冲突。
### 开放定址法
#### 线性探查法
- 当 `H(key)` 位置被占时，依次检查 `H(key)+1`, `H(key)+2`, ...
- 超过表长则回到表首循环
- **缺点**：容易产生"扎堆"现象
#### 平方探查法
- 检查顺序：`H(key)+1²`, `H(key)-1²`, `H(key)+2²`, `H(key)-2²`, ...
- 避免扎堆现象
- 位置计算：
    - 正向：`(H(key) + k²) % TSize` 
    - 负向：`((H(key) - k²) % TSize + TSize) % TSize`
### 链地址法（拉链法）
- 不计算新 hash 值
- 将所有 `H(key)` 相同的 key 连接成单链表
- 数组 `Link[0] ~ Link[mod-1]` 存储链表头指针
## 5.字符串哈希
字符串哈希的目标是将一个字符串映射成一个整数，使得该整数可以尽可能唯一地代表该字符串。
n进制公式：`id = id * n + digit`
#### 方法一：二十六进制转换（仅大写字母）
这里我们假设字符串只由大写字母组成，那么我们可以将每个字母看作0到25的数字，这样整个字符串就可以看作一个26进制数，然后将其转换为十进制整数。
例如，字符串"ABC"可以转换为：
- 'A' -> 0, 'B' -> 1, 'C' -> 2
- 那么整个字符串可以表示为：0 * 26^2 + 1 * 26^1 + 2 * 26^0 = 0 + 26 + 2 = 28
```cpp
int hashFunc(char S[], int len) {
    int id = 0;
    for(int i = 0; i < len; i++) {
        id = id * 26 + (S[i] - 'A'); // 注意这里应该是乘26，而不是加26
    }
    return id;
}
```
#### 方法二：五十二进制转换（大小写字母）
```cpp
int hashFunc(char S[], int len) {
    int id = 0;
    for(int i = 0; i < len; i++) {
        if(S[i] >= 'A' && S[i] <= 'Z') {
            id = id * 52 + (S[i] - 'A');      // A-Z: 0-25
        } else if(S[i] >= 'a' && S[i] <= 'z') {
            id = id * 52 + (S[i] - 'a' + 26); // a-z: 26-51
        }
    }
    return id;
}
```
#### 方法三：数字拼接法
```cpp
int hashFunc(char S[], int len) {
    int id = 0;
    // 处理字母部分（除最后一位）
    for(int i = 0; i < len - 1; i++) {
        id = id * 26 + (S[i] - 'A');
    }
    // 拼接最后一位数字
    id = id * 10 + (S[len-1] - '0');
    return id;
}
```
- 三位大写字母：`26 × 26 × 26 = 17576`
- 三位字符（大小写+数字）：`62 × 62 × 62 = 238328`
## 6.标准库
```cpp
#include <unordered_map>
#include <string>
std::unordered_map<std::string, int> hashMap;
// 自动处理哈希和冲突
```

在 C++ STL 中，`map`/`set` 和 `unordered_map`/`unordered_set` 是两组不同的关联容器，它们有重要的区别：

# 哈希表map和unordered_map，set和unordered_set有什么相同不同之处
## 底层实现

| 容器 | 底层数据结构 | 元素顺序 |
|------|-------------|----------|
| `map`, `set` | **红黑树** (平衡二叉搜索树) | **有序**，按键排序 |
| `unordered_map`, `unordered_set` | **哈希表** | **无序**，依赖哈希函数 |

## 主要区别对比

| 特性 | `map`/`set` | `unordered_map`/`unordered_set` |
|------|-------------|--------------------------------|
| **底层结构** | 红黑树 | 哈希表 |
| **元素顺序** | 按键排序 | 无序 |
| **查找时间复杂度** | O(log n) | 平均 O(1)，最坏 O(n) |
| **插入时间复杂度** | O(log n) | 平均 O(1)，最坏 O(n) |
| **内存占用** | 较低 | 较高（需要维护哈希桶） |
| **键的要求** | 需要支持 `<` 操作符 | 需要支持 `std::hash` 和 `==` 操作符 |

## 详细示例说明

### 1. `map` vs `unordered_map`

```cpp
#include <iostream>
#include <map>
#include <unordered_map>
#include <string>

using namespace std;

void test_maps() {
    // map - 有序，基于红黑树
    map<string, int> ordered_map;
    ordered_map["zebra"] = 1;
    ordered_map["apple"] = 2;
    ordered_map["banana"] = 3;
    
    cout << "map (有序): ";
    for (const auto& pair : ordered_map) {
        cout << pair.first << " "; // 输出: apple banana zebra
    }
    cout << endl;
    
    // unordered_map - 无序，基于哈希表
    unordered_map<string, int> unordered_map;
    unordered_map["zebra"] = 1;
    unordered_map["apple"] = 2;
    unordered_map["banana"] = 3;
    
    cout << "unordered_map (无序): ";
    for (const auto& pair : unordered_map) {
        cout << pair.first << " "; // 输出顺序不确定
    }
    cout << endl;
}
```

### 2. `set` vs `unordered_set`

```cpp
void test_sets() {
    // set - 有序
    set<int> ordered_set = {30, 10, 20, 40};
    cout << "set (有序): ";
    for (int num : ordered_set) {
        cout << num << " "; // 输出: 10 20 30 40
    }
    cout << endl;
    
    // unordered_set - 无序
    unordered_set<int> unordered_set = {30, 10, 20, 40};
    cout << "unordered_set (无序): ";
    for (int num : unordered_set) {
        cout << num << " "; // 输出顺序不确定
    }
    cout << endl;
}
```

## 性能比较

```cpp
#include <chrono>

void performance_test() {
    const int SIZE = 100000;
    
    // map 性能测试
    map<int, int> m;
    auto start = chrono::high_resolution_clock::now();
    for (int i = 0; i < SIZE; ++i) {
        m[i] = i;
    }
    auto end = chrono::high_resolution_clock::now();
    cout << "map 插入时间: " 
         << chrono::duration_cast<chrono::milliseconds>(end - start).count() 
         << " ms" << endl;
    
    // unordered_map 性能测试
    unordered_map<int, int> um;
    start = chrono::high_resolution_clock::now();
    for (int i = 0; i < SIZE; ++i) {
        um[i] = i;
    }
    end = chrono::high_resolution_clock::now();
    cout << "unordered_map 插入时间: " 
         << chrono::duration_cast<chrono::milliseconds>(end - start).count() 
         << " ms" << endl;
}
```

## 使用场景建议

### 使用 `map`/`set` 的情况：
- 需要**元素有序**
- 需要**按顺序遍历**元素
- 键类型不支持哈希函数
- 内存敏感的应用

### 使用 `unordered_map`/`unordered_set` 的情况：
- 需要**快速查找**，对性能要求高
- 不需要元素有序
- 键类型支持良好的哈希函数
- 内存充足

## 自定义类型的处理

```cpp
struct Person {
    string name;
    int age;
    
    // 对于 map/set：需要定义比较操作符
    bool operator<(const Person& other) const {
        return name < other.name; // 按姓名排序
    }
};

// 对于 unordered_map/unordered_set：需要定义哈希函数
struct PersonHash {
    size_t operator()(const Person& p) const {
        return hash<string>()(p.name) ^ hash<int>()(p.age);
    }
};

struct PersonEqual {
    bool operator()(const Person& a, const Person& b) const {
        return a.name == b.name && a.age == b.age;
    }
};

// 使用
map<Person, int> ordered_map; // 自动使用 Person::operator<
unordered_map<Person, int, PersonHash, PersonEqual> unordered_map;
```

## 总结

**选择原则**：
- 需要**有序** → 选择 `map`/`set`
- 需要**高性能** → 选择 `unordered_map`/`unordered_set`
- 考虑**键的类型**是否支持相应的操作（比较或哈希）
- 考虑**内存限制**和**遍历需求**

在实际开发中，如果不需要顺序，通常优先选择 `unordered_map`/`unordered_set` 以获得更好的性能。
# 哈希表map和unordered_map，set和unordered_set分别都什么时候用，是不是在不要求有序的条件下，只需要使用unordered_map或者unordered_set就可以了？
您的理解是**完全正确的**！在不要求有序的条件下，通常应该优先使用 `unordered_map` 或 `unordered_set`。

## 使用原则总结

### 1. **默认选择规则**
```cpp
// 当不需要元素有序时，优先使用 unordered_ 版本
unordered_map<Key, Value> umap;  // ✅ 优先选择
unordered_set<Key> uset;         // ✅ 优先选择

// 只有当需要有序时才使用普通版本
map<Key, Value> ordered_map;     // ❌ 除非需要有序
set<Key> ordered_set;            // ❌ 除非需要有序
```

### 2. **具体使用场景**

#### 使用 `unordered_map`/`unordered_set` 的情况：
```cpp
#include <unordered_map>
#include <unordered_set>

// 场景1：快速查找，不关心顺序
unordered_map<string, int> student_scores;
student_scores["Alice"] = 95;
student_scores["Bob"] = 87;

// 场景2：去重操作
unordered_set<int> unique_numbers = {1, 2, 3, 2, 1}; // 自动去重

// 场景3：缓存系统
unordered_map<string, string> cache;
```

#### 使用 `map`/`set` 的情况：
```cpp
#include <map>
#include <set>

// 场景1：需要有序遍历
map<string, int> sorted_students; // 按键排序
for (const auto& pair : sorted_students) {
    // 会按字母顺序输出
}

// 场景2：需要范围查询
set<int> sorted_numbers = {1, 3, 5, 7, 9};
auto it_low = sorted_numbers.lower_bound(3); // 找到 >=3 的第一个元素
auto it_high = sorted_numbers.upper_bound(7); // 找到 >7 的第一个元素

// 场景3：需要按顺序处理数据
map<int, string> timeline_events; // 按时间戳排序
```

### 3. **性能对比示例**

```cpp
void performance_comparison() {
    const int SIZE = 100000;
    
    // 无序容器 - 通常更快
    unordered_set<int> us;
    auto start = chrono::high_resolution_clock::now();
    for (int i = 0; i < SIZE; ++i) {
        us.insert(i);
    }
    auto end = chrono::high_resolution_clock::now();
    cout << "unordered_set 插入时间: " 
         << chrono::duration_cast<chrono::milliseconds>(end - start).count() 
         << " ms" << endl;
    
    // 有序容器 - 通常较慢
    set<int> s;
    start = chrono::high_resolution_clock::now();
    for (int i = 0; i < SIZE; ++i) {
        s.insert(i);
    }
    end = chrono::high_resolution_clock::now();
    cout << "set 插入时间: " 
         << chrono::duration_cast<chrono::milliseconds>(end - start).count() 
         << " ms" << endl;
}
```

### 4. **实际开发中的建议**

#### 默认选择 unordered_ 版本：
```cpp
// 90% 的情况下应该这样选择
class Solution {
public:
    // 例如：两数之和问题
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> num_index;  // ✅ 正确选择
        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];
            if (num_index.find(complement) != num_index.end()) {
                return {num_index[complement], i};
            }
            num_index[nums[i]] = i;
        }
        return {};
    }
};
```

#### 需要有序时才选择普通版本：
```cpp
// 只有 10% 的情况需要有序版本
class Solution {
public:
    // 例如：需要按顺序输出结果
    vector<vector<int>> verticalTraversal(TreeNode* root) {
        map<int, map<int, multiset<int>>> nodes;  // ✅ 需要有序
        // ... 遍历代码
        // 结果会自动按列号、行号排序
    }
};
```

### 5. **特殊情况考虑**

```cpp
// 情况1：自定义类型作为键
struct Point {
    int x, y;
    
    // 如果使用 unordered_map，需要定义哈希
    bool operator==(const Point& other) const {
        return x == other.x && y == other.y;
    }
};

struct PointHash {
    size_t operator()(const Point& p) const {
        return hash<int>()(p.x) ^ hash<int>()(p.y);
    }
};

unordered_map<Point, int, PointHash> point_map;  // 需要哈希函数

// 如果使用 map，只需要定义比较
bool operator<(const Point& a, const Point& b) {
    return tie(a.x, a.y) < tie(b.x, b.y);
}

map<Point, int> point_map_ordered;  // 只需要比较运算符
```

## 总结

**黄金法则**：
- **默认使用** `unordered_map` 和 `unordered_set`
- **只有当需要有序遍历、范围查询或特定排序时才使用** `map` 和 `set`
- **性能优先**：在大多数情况下，无序容器提供更好的性能
- **代码可读性**：明确你的意图 - 如果不需要顺序，使用无序容器更清楚地表达了这一点

在您的日常编程中，养成这样的习惯会让代码更高效、意图更明确！
# unordered_map<int<vector<int>>> map与 unordered_map<int, int> map是不是一样的

**不，它们是完全不同的类型！**

`unordered_map<int, vector<int>>` 和 `unordered_map<int, int>` 是两种不同的哈希表类型。

## 类型区别详解

### 1. `unordered_map<int, int>`
```cpp
unordered_map<int, int> map1;
```
- **键类型**: `int`
- **值类型**: `int`
- **含义**: 从整数键映射到整数值
- **示例**:
```cpp
map1[1] = 100;    // 键1 → 值100
map1[2] = 200;    // 键2 → 值200
```

### 2. `unordered_map<int, vector<int>>`
```cpp
unordered_map<int, vector<int>> map2;
```
- **键类型**: `int`
- **值类型**: `vector<int>`（整数向量）
- **含义**: 从整数键映射到整数向量
- **示例**:
```cpp
map2[1] = {10, 20, 30};        // 键1 → 向量[10,20,30]
map2[2] = {40, 50};            // 键2 → 向量[40,50]
map2[3].push_back(60);         // 向键3的向量添加元素
```

## 实际使用对比

### `unordered_map<int, int>` 的使用场景：
```cpp
// 统计数字出现频率
unordered_map<int, int> freq;
vector<int> nums = {1, 2, 2, 3, 3, 3};
for (int num : nums) {
    freq[num]++;
}
// freq: {1:1, 2:2, 3:3}

// 存储简单键值对
unordered_map<int, int> student_scores;
student_scores[101] = 95;  // 学号101 → 分数95
student_scores[102] = 87;  // 学号102 → 分数87
```

### `unordered_map<int, vector<int>>` 的使用场景：
```cpp
// 图的邻接表表示
unordered_map<int, vector<int>> graph;
graph[1] = {2, 3};        // 节点1连接到节点2和3
graph[2] = {1, 4};        // 节点2连接到节点1和4
graph[3] = {1};           // 节点3连接到节点1

// 分组数据
unordered_map<int, vector<int>> groups;
groups[0].push_back(10);  // 组0包含10
groups[0].push_back(20);  // 组0包含20
groups[1].push_back(30);  // 组1包含30
```

## 在算法中的应用

### 使用 `unordered_map<int, int>`：
```cpp
// 两数之和问题
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> num_index;  // 值 → 索引
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        if (num_index.find(complement) != num_index.end()) {
            return {num_index[complement], i};
        }
        num_index[nums[i]] = i;
    }
    return {};
}
```

### 使用 `unordered_map<int, vector<int>>`：
```cpp
// 分组异或问题
vector<vector<int>> groupNumbers(vector<int>& nums) {
    unordered_map<int, vector<int>> groups;  // 特征值 → 数字列表
    for (int num : nums) {
        int feature = num % 3;  // 按模3分组
        groups[feature].push_back(num);
    }
    
    vector<vector<int>> result;
    for (auto& pair : groups) {
        result.push_back(pair.second);
    }
    return result;
}
```

## 总结

- `unordered_map<int, int>`：**一对一映射**，每个键对应一个整数值
- `unordered_map<int, vector<int>>`：**一对多映射**，每个键对应一个整数列表

选择哪种类型取决于你的需求：
- 如果需要存储简单的键值对 → 使用 `unordered_map<int, int>`
- 如果需要存储键到多个值的映射 → 使用 `unordered_map<int, vector<int>>`

在您之前的滑动窗口代码中，使用的是 `unordered_map<int, int>`，因为需要记录每个数字的出现次数（单个整数值）。