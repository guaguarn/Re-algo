# æ ‘ ==ä¸­åºéå†åªé€‚åˆäºŒå‰æ ‘==

==äºŒå‰æŸ¥æ‰¾æ ‘ï¼ˆBSTï¼‰æ˜¯äºŒå‰æ ‘çš„åº”ç”¨ï¼ŒAVLæ ‘æ˜¯BSTçš„å¹³è¡¡ç‰ˆæœ¬ï¼Œå¹¶æŸ¥é›†å’Œå †æ˜¯ç‹¬ç«‹çš„æ•°æ®ç»“æ„ï¼Œå“ˆå¤«æ›¼æ ‘æ˜¯ç‰¹æ®Šçš„äºŒå‰æ ‘ç”¨äºç¼–ç ä¼˜åŒ–ã€‚==
- **æ‰€æœ‰äºŒå‰æœç´¢æ ‘å˜ä½“ï¼ˆåŒ…æ‹¬AVLã€çº¢é»‘æ ‘ç­‰ï¼‰éƒ½å¿…é¡»ä¿æŒä¸­åºéå†çš„æœ‰åºæ€§**
- **AVLæ ‘åœ¨ä¿æŒä¸­åºæœ‰åºçš„åŸºç¡€ä¸Šï¼Œé¢å¤–ä¿è¯æ ‘çš„å¹³è¡¡**
- **æ—‹è½¬æ“ä½œæ˜¯AVLæ ‘çš„æ ¸å¿ƒæŠ€æœ¯ï¼Œå…¶è®¾è®¡ç¡®ä¿äº†ä¸­åºä¸å˜æ€§**
## 1 æ ‘ä¸äºŒå‰æ ‘
##### å®šä¹‰
- **æ ‘ï¼ˆTreeï¼‰**ï¼šä¸€ä¸ªè¿é€šçš„æ— ç¯æ— å‘å›¾ï¼ˆæˆ–æœ‰æ ¹çš„å±‚æ¬¡ç»“æ„ï¼‰ã€‚å½¢å¼åŒ–å®šä¹‰ï¼š
  - æ— æ ¹æ ‘ï¼šn ä¸ªç»“ç‚¹ã€n-1 æ¡è¾¹çš„è¿é€šæ— å‘å›¾ï¼›ä»»æ„ä¸¤ç»“ç‚¹é—´æœ‰å”¯ä¸€è·¯å¾„ã€‚
  - æœ‰æ ¹æ ‘ï¼šåœ¨æ— æ ¹æ ‘ä¸ŠæŒ‡å®šä¸€ä¸ªæ ¹ç»“ç‚¹ï¼Œå½¢æˆå±‚æ¬¡ç»“æ„ï¼ˆçˆ¶å­å…³ç³»ï¼‰ã€‚
- **æ£®æ—ï¼ˆForestï¼‰**ï¼šå¤šä¸ªæ ‘çš„é›†åˆï¼ˆä¸è¿é€šï¼‰ã€‚
- **äºŒå‰æ ‘ï¼ˆBinary Treeï¼‰**ï¼šæ¯ä¸ªç»“ç‚¹æœ€å¤šæœ‰ä¸¤ä¸ªå­ç»“ç‚¹ï¼ˆå·¦å­æ ‘å’Œå³å­æ ‘ï¼‰çš„æœ‰æ ¹æ ‘ã€‚é€šå¸¸åŒºåˆ†å·¦å³é¡ºåºã€‚
  - ç‰¹æ®ŠäºŒå‰æ ‘ï¼š
    - **å®Œæ•´äºŒå‰æ ‘**ï¼šæ¯ä¸ªç»“ç‚¹è¦ä¹ˆæ˜¯å¶ç»“ç‚¹ï¼Œè¦ä¹ˆæœ‰å·¦å³ä¸¤ä¸ªå­ç»“ç‚¹ã€‚
    - **å®Œå…¨äºŒå‰æ ‘**ï¼šé™¤æœ€åä¸€å±‚å¤–ï¼Œæ‰€æœ‰å±‚ç»“ç‚¹æ»¡ï¼Œä¸”æœ€åä¸€å±‚ç»“ç‚¹ä»å·¦åˆ°å³è¿ç»­ã€‚
    - **å®Œç¾äºŒå‰æ ‘**ï¼šæ‰€æœ‰å±‚ç»“ç‚¹æ»¡ï¼Œå¶ç»“ç‚¹æ·±åº¦ç›¸åŒã€‚
##### æ€§è´¨
- æ ‘æœ‰ n-1 æ¡è¾¹ï¼Œæ— ç¯ã€‚
- å¶ç»“ç‚¹ï¼šåº¦æ•°ä¸º1ï¼ˆæ— æ ¹æ ‘ï¼‰æˆ–æ— å­ç»“ç‚¹ï¼ˆæœ‰æ ¹æ ‘ï¼‰ã€‚
- æ·±åº¦ï¼ˆDepthï¼‰ï¼šç»“ç‚¹åˆ°æ ¹çš„è¾¹æ•°ã€‚
ps:æŸä¸ªç‚¹çš„æ·±åº¦å’Œæ ‘çš„æ·±åº¦ä¸ä¸€å®šä¸€æ ·ã€‚æŸä¸ªç‚¹çš„æ·±åº¦ï¼ˆNode Depthï¼‰æŒ‡çš„æ˜¯ä»æ ‘çš„æ ¹èŠ‚ç‚¹åˆ°è¯¥èŠ‚ç‚¹çš„è·¯å¾„é•¿åº¦ã€‚æ ‘çš„æ·±åº¦ï¼ˆTree Depthï¼‰ ä¹Ÿç§°ä¸ºæ ‘çš„é«˜åº¦ï¼ŒæŒ‡çš„æ˜¯æ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹çš„æœ€å¤§æ·±åº¦ã€‚
- é«˜åº¦ï¼ˆHeightï¼‰ï¼šæ ‘ä¸­æœ€å¤§æ·±åº¦ã€‚
- ç¥–å…ˆ/åä»£ï¼šè·¯å¾„ä¸Šçš„ä¸Šä¸‹çº§å…³ç³»ã€‚
- å­æ ‘ï¼šä»¥æŸç»“ç‚¹ä¸ºæ ¹çš„å­å›¾ã€‚
- äºŒå‰æ ‘é«˜åº¦ä¸º h æ—¶ï¼Œæœ€å¤šæœ‰ 2^{h+1} - 1 ä¸ªç»“ç‚¹ï¼ˆå®Œç¾äºŒå‰æ ‘ï¼‰ã€‚
##### æ“ä½œ
- **å­˜å‚¨æ–¹å¼**ï¼š
  - é‚»æ¥è¡¨ï¼š`vector<int> adj[N];`ï¼ˆæ— æ ¹æ ‘ï¼‰ã€‚
  - çˆ¶æŒ‡é’ˆï¼š`int parent[N];`ï¼ˆæœ‰æ ¹æ ‘ï¼‰ã€‚
  - äºŒå‰æ ‘ä¸“ç”¨ï¼š`int lch[N], rch[N];`ï¼ˆå·¦/å³å­©å­ï¼‰ã€‚
- **éå†**ï¼šDFSã€BFS ç­‰ç”¨äºè®¿é—®æ‰€æœ‰ç»“ç‚¹ã€‚ï¼ˆè§é™†ï¼‰
##### æ—¶é—´å¤æ‚åº¦
- éå†ï¼šO(n)ï¼ˆæ¯ä¸ªç»“ç‚¹/è¾¹è®¿é—®ä¸€æ¬¡ï¼‰ã€‚
å‰ç¼€ï¼š(ä¸é“¾è¡¨ç›¸ä¼¼)
```cpp
/**
Â * Definition for a binary tree node.
Â * struct TreeNode {
Â * Â  Â  int val;
Â * Â  Â  TreeNode *left;
Â * Â  Â  TreeNode *right;
Â * Â  Â  TreeNode() : val(0), left(nullptr), right(nullptr) {}
Â * Â  Â  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
Â * Â  Â  TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
Â * };
Â */
```
##### ä»£ç ç¤ºä¾‹ **è®¡ç®—æ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹æ·±åº¦**ï¼ˆæœ‰æ ¹æ ‘DFSéå†ï¼‰
```cpp
const int N = 1e5 + 10;// å®šä¹‰æœ€å¤§èŠ‚ç‚¹æ•°
vector<int> adj[N];  // é‚»æ¥è¡¨å­˜å‚¨æ ‘
int depth[N]; // å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦

void dfs(int u, int parent, int d) {
//uï¼šå½“å‰æ­£åœ¨è®¿é—®çš„èŠ‚ç‚¹
//parentï¼šå½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼ˆç”¨äºé¿å…å›æº¯ï¼‰ã€‚parent=-1æ—¶ï¼Œæ— çˆ¶èŠ‚ç‚¹
//dï¼šå½“å‰èŠ‚ç‚¹çš„æ·±åº¦
    depth[u] = d;// è®°å½•å½“å‰èŠ‚ç‚¹uçš„æ·±åº¦ä¸ºd
    for (int v : adj[u]) {// éå†uçš„æ‰€æœ‰é‚»å±…èŠ‚ç‚¹v
        if (v != parent) {//é¿å…å›åˆ°çˆ¶èŠ‚ç‚¹ï¼ˆé˜²æ­¢å¾ªç¯ï¼‰
            dfs(v, u, d + 1); // é€’å½’è®¿é—®å­èŠ‚ç‚¹ï¼Œæ·±åº¦+1
        }
    }
}
// ä½¿ç”¨ï¼šä»æ ¹1å¼€å§‹ dfs(1, -1, 0);
```
e.g.è°ƒç”¨Â `dfs(1, -1, 0)`ï¼š
```cpp
    1
   / \
  2   3
 / \
4   5
```
```cpp
dfs(1, -1, 0)
â”œâ”€â”€ depth[1] = 0
â”œâ”€â”€ éå†é‚»å±…ï¼š2, 3
â”‚   â”œâ”€â”€ dfs(2, 1, 1)
â”‚   â”‚   â”œâ”€â”€ depth[2] = 1
â”‚   â”‚   â”œâ”€â”€ éå†é‚»å±…ï¼š1, 4, 5
â”‚   â”‚   â”‚   â”œâ”€â”€ è·³è¿‡1ï¼ˆæ˜¯çˆ¶èŠ‚ç‚¹ï¼‰
â”‚   â”‚   â”‚   â”œâ”€â”€ dfs(4, 2, 2)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ depth[4] = 2
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ éå†é‚»å±…ï¼š2ï¼ˆè·³è¿‡ï¼Œæ˜¯çˆ¶èŠ‚ç‚¹ï¼‰
â”‚   â”‚   â”‚   â””â”€â”€ dfs(5, 2, 2)
â”‚   â”‚   â”‚       â”œâ”€â”€ depth[5] = 2
â”‚   â”‚   â”‚       â””â”€â”€ éå†é‚»å±…ï¼š2ï¼ˆè·³è¿‡ï¼Œæ˜¯çˆ¶èŠ‚ç‚¹ï¼‰
â”‚   â”‚   â””â”€â”€ è¿”å›
â”‚   â””â”€â”€ dfs(3, 1, 1)
â”‚       â”œâ”€â”€ depth[3] = 1
â”‚       â””â”€â”€ éå†é‚»å±…ï¼š1ï¼ˆè·³è¿‡ï¼Œæ˜¯çˆ¶èŠ‚ç‚¹ï¼‰
â””â”€â”€ è¿”å›
```
##### leetcode 104. Maximum Depth of Binary Tree(æœ€å¤§æ·±åº¦)(ååºéå†)
Given theÂ `root`Â of a binary tree, returnÂ _its maximum depth_.
A binary tree'sÂ **maximum depth**Â is the number of nodes along the longest path from the root node down to the farthest leaf node.
```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int l_depth = maxDepth(root->left);
        int r_depth = maxDepth(root->right);
        return max(l_depth, r_depth) + 1;
    }
};
```
å›¾è§£ï¼š
```cpp
      3
     / \
    9   20
       /  \
      15   7
       \
        4
        
maxDepth(3)
â”œâ”€â”€ maxDepth(9) 
â”‚   â”œâ”€â”€ maxDepth(null) â†’ 0
â”‚   â”œâ”€â”€ maxDepth(null) â†’ 0
â”‚   â””â”€â”€ return max(0,0)+1 = 1
â”œâ”€â”€ maxDepth(20)
â”‚   â”œâ”€â”€ maxDepth(15)
â”‚   â”‚   â”œâ”€â”€ maxDepth(null) â†’ 0
â”‚   â”‚   â”œâ”€â”€ maxDepth(4)
â”‚   â”‚   â”‚   â”œâ”€â”€ maxDepth(null) â†’ 0
â”‚   â”‚   â”‚   â”œâ”€â”€ maxDepth(null) â†’ 0
â”‚   â”‚   â”‚   â””â”€â”€ return max(0,0)+1 = 1
â”‚   â”‚   â””â”€â”€ return max(0,1)+1 = 2
â”‚   â”œâ”€â”€ maxDepth(7)
â”‚   â”‚   â”œâ”€â”€ maxDepth(null) â†’ 0
â”‚   â”‚   â”œâ”€â”€ maxDepth(null) â†’ 0
â”‚   â”‚   â””â”€â”€ return max(0,0)+1 = 1
â”‚   â””â”€â”€ return max(2,1)+1 = 3
â””â”€â”€ return max(1,3)+1 = 4
```
##### leetcode 101. Symmetric Tree(å¯¹ç§°äºŒå‰æ ‘)
Given theÂ `root`Â of a binary tree,Â _check whether it is a mirror of itself_Â (i.e., symmetric around its center).
```cpp
class Solution 
{
     public:
     bool compare(TreeNode* left, TreeNode* right) { 
        if (left == NULL && right != NULL) return false; 
        else if (left != NULL && right == NULL) return false; 
        else if (left == NULL && right == NULL) return true; //æ³¨æ„è¿™é‡Œæ˜“é”™
        else if (left->val != right->val) return false; 
        bool outside = compare(left->left, right->right);
        bool inside = compare(left->right, right->left);  
        bool isSame = outside && inside;
        return isSame;
	    }      
     bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true; 
        return compare(root->left, root->right);
        }
        };
```
##### leetcode100. Same Tree
Given the roots of two binary treesÂ `p`Â andÂ `q`, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.
```cpp
```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == nullptr || q == nullptr) {//è¿™ä¸€å¥æœ€é‡è¦ï¼Œè¾¹ç•Œæ¡ä»¶å¤„ç†
            return p == q; // å¿…é¡»éƒ½æ˜¯ nullptr
        }
        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```
ps:
```cpp
if(p == nullptr || q == nullptr) return p == q;
```
ç­‰ä»·å±•å¼€ï¼š
```cpp
if (p == nullptr || q == nullptr) {
    // æ­¤æ—¶è‡³å°‘æœ‰ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©º
    if (p == nullptr && q == nullptr) {
        return true;  // ä¸¤ä¸ªéƒ½ä¸ºç©ºï¼Œè®¤ä¸ºç›¸åŒ
    } else {
        return false; // ä¸€ä¸ªä¸ºç©ºä¸€ä¸ªä¸ä¸ºç©ºï¼Œè‚¯å®šä¸åŒ
    }
}
```
## 2 äºŒå‰æ ‘çš„éå†
##### å®šä¹‰
äºŒå‰æ ‘çš„éå†æ˜¯æŒ‡æŒ‰ç‰¹å®šé¡ºåºè®¿é—®æ‰€æœ‰ç»“ç‚¹ã€‚äºŒå‰æ ‘éå†é€šå¸¸åŸºäºæ ¹ç»“ç‚¹çš„è®¿é—®æ—¶æœºåˆ†ä¸ºä¸‰ç§ï¼ˆDFSå˜ä½“ï¼‰ï¼Œè¿˜æœ‰å±‚åºéå†ï¼ˆBFSï¼‰ã€‚
##### æ–¹æ³•
1. **å…ˆåºéå†ï¼ˆPre-orderï¼‰**ï¼šæ ¹ â†’ å·¦ â†’ å³ã€‚é€‚åˆåˆ›å»ºæ ‘æ‹·è´æˆ–å‰ç¼€è¡¨è¾¾å¼ã€‚
2. **ä¸­åºéå†ï¼ˆIn-orderï¼‰**ï¼šå·¦ â†’ æ ¹ â†’ å³ã€‚åœ¨BSTä¸­äº§ç”Ÿæœ‰åºåºåˆ—ã€‚
3. **ååºéå†ï¼ˆPost-orderï¼‰**ï¼šå·¦ â†’ å³ â†’ æ ¹ã€‚é€‚åˆåˆ é™¤æ ‘æˆ–åç¼€è¡¨è¾¾å¼ã€‚
4. **å±‚åºéå†ï¼ˆLevel-orderï¼‰**ï¼šæŒ‰å±‚ä»å·¦åˆ°å³ï¼ˆä½¿ç”¨é˜Ÿåˆ—ï¼‰ã€‚é€‚åˆæ±‚æ ‘é«˜æˆ–å®½åº¦ã€‚
è¯¦ç»†ä¸€ç‚¹è®²:
  ç®€å•æ¥è¯´ï¼Œé€‰æ‹©å“ªç§éå†æ–¹å¼ï¼Œå®Œå…¨å–å†³äºä½ å¸Œæœ›åœ¨ä»€ä¹ˆæ—¶å€™å¤„ç†â€œæ ¹â€èŠ‚ç‚¹ï¼ˆç›¸å¯¹äºå¤„ç†å®ƒçš„å­èŠ‚ç‚¹è€Œè¨€ï¼‰ã€‚
ä¸‹é¢æ˜¯ä¸‰ç§éå†æ–¹å¼çš„è¯¦ç»†è§£é‡Šå’Œå®ƒä»¬æœ€é€‚åˆçš„ä½¿ç”¨åœºæ™¯ã€‚
ğŸŒ³ å‰åºéå† (Pre-order Traversal)
 * è®¿é—®é¡ºåºï¼š æ ¹ -> å·¦å­æ ‘ -> å³å­æ ‘
 * æ ¸å¿ƒæ€æƒ³ï¼š "å…ˆå¤„ç†æˆ‘ï¼Œå†å¤„ç†æˆ‘çš„å­©å­ä»¬ã€‚" åœ¨è®¿é—®ä»»ä½•å­èŠ‚ç‚¹ä¹‹å‰ï¼Œæ€»æ˜¯å…ˆè®¿é—®å’Œå¤„ç†å½“å‰çš„æ ¹èŠ‚ç‚¹ã€‚
ä¸»è¦ä½¿ç”¨åœºæ™¯ï¼š
 * å¤åˆ¶ï¼ˆæ‹·è´ï¼‰æ ‘ï¼š
   è¿™æ˜¯å‰åºéå†æœ€ç»å…¸çš„åº”ç”¨ã€‚å½“ä½ å¤åˆ¶ä¸€ä¸ªæ ‘æ—¶ï¼Œä½ éœ€è¦å…ˆåˆ›å»ºæ ¹èŠ‚ç‚¹ï¼Œç„¶åå†é€’å½’åœ°å»åˆ›å»ºå®ƒçš„å·¦å­æ ‘å’Œå³å­æ ‘ã€‚è¿™ä¸ªâ€œå…ˆåˆ›å»ºæ ¹â€çš„åŠ¨ä½œï¼Œå®Œç¾å¥‘åˆäº†å‰åºéå†ã€‚
 * åºåˆ—åŒ–/ååºåˆ—åŒ–æ ‘ï¼š
   å½“ä½ éœ€è¦å°†æ ‘ç»“æ„ä¿å­˜åˆ°æ–‡ä»¶æˆ–åœ¨ç½‘ç»œä¸Šä¼ è¾“æ—¶ï¼Œå‰åºéå†éå¸¸æœ‰ç”¨ã€‚å®ƒå¯ä»¥å°†æ ‘â€œæ‹å¹³â€æˆä¸€ä¸ªå­—ç¬¦ä¸²æˆ–å­—èŠ‚æµã€‚åœ¨ååºåˆ—åŒ–ï¼ˆé‡å»ºæ ‘ï¼‰æ—¶ï¼Œå› ä¸ºç¬¬ä¸€ä¸ªå…ƒç´ æ€»æ˜¯æ ¹ï¼Œæ‰€ä»¥ç»“æ„å¾ˆå®¹æ˜“è¢«è¿˜åŸã€‚
 * æ˜¾ç¤ºæ–‡ä»¶ç³»ç»Ÿç»“æ„ï¼š
   æƒ³è±¡ä¸€ä¸‹ä½ åœ¨å‘½ä»¤è¡Œä¸­åˆ—å‡ºä¸€ä¸ªç›®å½•ç»“æ„ã€‚ç³»ç»Ÿé€šå¸¸ä¼šå…ˆæ‰“å°å‡ºå½“å‰ç›®å½•çš„åç§°ï¼ˆæ ¹ï¼‰ï¼Œç„¶åå†é€’å½’åœ°å»æ‰“å°å®ƒä¸‹é¢çš„æ–‡ä»¶å’Œå­ç›®å½•ã€‚
 * è¡¨è¾¾å¼æ ‘çš„å‰ç¼€è¡¨è¾¾å¼ï¼ˆæ³¢å…°è¡¨è¾¾å¼ï¼‰ï¼š
   å¦‚æœä¸€ä¸ªæ ‘ä»£è¡¨äº†æ•°å­¦è¡¨è¾¾å¼ (a+b)*cï¼Œé‚£ä¹ˆå¯¹å®ƒè¿›è¡Œå‰åºéå†ä¼šå¾—åˆ° * + a b cï¼Œè¿™æ˜¯ä¸€ç§æ— éœ€æ‹¬å·çš„è¡¨è¾¾å¼ã€‚
ğŸŒ³ ä¸­åºéå† (In-order Traversal)
 * è®¿é—®é¡ºåºï¼š å·¦å­æ ‘ -> æ ¹ -> å³å­æ ‘
 * æ ¸å¿ƒæ€æƒ³ï¼š "å…ˆå¤„ç†å®Œæˆ‘çš„å·¦è¾¹ï¼Œå†å¤„ç†æˆ‘ï¼Œæœ€åå¤„ç†æˆ‘çš„å³è¾¹ã€‚" æ ¹èŠ‚ç‚¹åœ¨å…¶ä¸­é—´è¢«è®¿é—®ã€‚
ä¸»è¦ä½¿ç”¨åœºæ™¯ï¼š
 * äºŒå‰æœç´¢æ ‘ (BST) çš„æ’åºè¾“å‡ºï¼š
   è¿™æ˜¯ä¸­åºéå† æœ€é‡è¦ã€æœ€æ ¸å¿ƒ çš„åº”ç”¨ã€‚æ ¹æ®äºŒå‰æœç´¢æ ‘çš„å®šä¹‰ï¼ˆå·¦ < æ ¹ < å³ï¼‰ï¼Œå¯¹å®ƒè¿›è¡Œä¸­åºéå†ï¼Œä½ ä¼šå¾—åˆ°ä¸€ä¸ªä¸¥æ ¼å‡åºçš„èŠ‚ç‚¹å€¼åˆ—è¡¨ã€‚
   ä¾‹å¦‚ï¼š å¦‚æœä½ éœ€è¦æ‰¾åˆ°BSTä¸­ç¬¬kå°çš„å…ƒç´ ï¼Œæˆ–è€…æŒ‰é¡ºåºæ‰“å°æ‰€æœ‰å€¼ï¼Œä¸­åºéå†æ˜¯ä½ çš„ä¸äºŒä¹‹é€‰ã€‚
 * è¡¨è¾¾å¼æ ‘çš„ä¸­ç¼€è¡¨è¾¾å¼ï¼š
   å¯¹è¡¨è¾¾å¼æ ‘è¿›è¡Œä¸­åºéå†ï¼Œå¯ä»¥å¾—åˆ°æˆ‘ä»¬äººç±»æœ€ä¹ æƒ¯é˜…è¯»çš„ä¸­ç¼€è¡¨è¾¾å¼ï¼Œä¾‹å¦‚ a + bã€‚ï¼ˆå°½ç®¡è¦å®Œç¾è¿˜åŸæ‹¬å·ä¼šæ›´å¤æ‚ï¼Œä½†åŸºæœ¬é¡ºåºæ˜¯ä¸­åºçš„ï¼‰ã€‚
ğŸŒ³ ååºéå† (Post-order Traversal)
 * è®¿é—®é¡ºåºï¼š å·¦å­æ ‘ -> å³å­æ ‘ -> æ ¹
 * æ ¸å¿ƒæ€æƒ³ï¼š "å…ˆå¤„ç†å®Œæˆ‘æ‰€æœ‰çš„å­©å­ï¼Œæœ€åå†æ¥å¤„ç†æˆ‘ã€‚" æ ¹èŠ‚ç‚¹æ€»æ˜¯åœ¨å®ƒçš„æ‰€æœ‰å­èŠ‚ç‚¹éƒ½è¢«å¤„ç†å®Œæ¯•åæ‰è¢«è®¿é—®ã€‚
ä¸»è¦ä½¿ç”¨åœºæ™¯ï¼š
 * é”€æ¯ï¼ˆé‡Šæ”¾ï¼‰æ ‘çš„å†…å­˜ï¼š
   è¿™æ˜¯ä¸€ä¸ªéå¸¸ç»å…¸çš„ç”¨é€”ã€‚åœ¨åˆ é™¤ä¸€ä¸ªæ ‘æ—¶ï¼Œä½ å¿…é¡»å…ˆåˆ é™¤å®ƒçš„å­èŠ‚ç‚¹ï¼Œç„¶åæ‰èƒ½å®‰å…¨åœ°åˆ é™¤çˆ¶èŠ‚ç‚¹ã€‚å¦‚æœä½ å…ˆåˆ é™¤äº†çˆ¶èŠ‚ç‚¹ï¼Œå°±ä¼šå¤±å»å¯¹å­èŠ‚ç‚¹çš„å¼•ç”¨ï¼Œå¯¼è‡´å†…å­˜æ³„æ¼ã€‚ååºéå†ç¡®ä¿äº†å­èŠ‚ç‚¹æ€»æ˜¯å…ˆäºçˆ¶èŠ‚ç‚¹è¢«å¤„ç†ï¼ˆåˆ é™¤ï¼‰ã€‚
 * è¡¨è¾¾å¼æ ‘çš„æ±‚å€¼ï¼ˆåç¼€è¡¨è¾¾å¼ / é€†æ³¢å…°è¡¨è¾¾å¼ï¼‰ï¼š
   è®¡ç®—æœºåœ¨è®¡ç®— (a+b)*c æ—¶ï¼Œä½¿ç”¨åç¼€è¡¨è¾¾å¼ a b + c * æ›´ä¸ºé«˜æ•ˆï¼ˆä½¿ç”¨æ ˆï¼‰ã€‚ååºéå†ä¸€ä¸ªè¡¨è¾¾å¼æ ‘ï¼Œä¼šè‡ªç„¶åœ°äº§ç”Ÿè¿™ç§åç¼€è¡¨è¾¾å¼ã€‚åœ¨æ±‚å€¼æ—¶ï¼Œä½ å¿…é¡»å…ˆå¾—åˆ° a å’Œ b çš„å€¼ï¼ˆå·¦ã€å³ï¼‰ï¼Œç„¶åæ‰èƒ½æ‰§è¡Œ + æ“ä½œï¼ˆæ ¹ï¼‰ã€‚
 * è®¡ç®—ä¾èµ–å­æ ‘ä¿¡æ¯çš„ä»»åŠ¡ï¼š
   ä»»ä½•éœ€è¦å…ˆçŸ¥é“å­èŠ‚ç‚¹ä¿¡æ¯æ‰èƒ½ç¡®å®šçˆ¶èŠ‚ç‚¹ä¿¡æ¯çš„ä»»åŠ¡ï¼Œéƒ½é€‚åˆç”¨ååºéå†ã€‚
   * è®¡ç®—æ ‘çš„é«˜åº¦ï¼š ä½ å¿…é¡»å…ˆçŸ¥é“å·¦å³å­æ ‘çš„é«˜åº¦ï¼Œæ‰èƒ½è®¡ç®—å‡ºå½“å‰èŠ‚ç‚¹çš„é«˜åº¦ï¼ˆmax(å·¦é«˜, å³é«˜) + 1ï¼‰ã€‚
   * è®¡ç®—æ ‘çš„èŠ‚ç‚¹æ•°ï¼š ä½ å¿…é¡»å…ˆçŸ¥é“å·¦å³å­æ ‘çš„èŠ‚ç‚¹æ•°ï¼Œæ‰èƒ½è®¡ç®—å½“å‰å­æ ‘çš„æ€»èŠ‚ç‚¹æ•°ï¼ˆå·¦æ•° + å³æ•° + 1ï¼‰ã€‚


##### ç®—æ³•å¯¹æ¯”
- **é€’å½’å®ç°**ï¼šç®€å•ï¼Œä½†æ ˆç©ºé—´O(h)ã€‚
- **éé€’å½’å®ç°**ï¼šä½¿ç”¨æ ˆæ¨¡æ‹Ÿé€’å½’ï¼Œç©ºé—´O(h)ã€‚ï¼ˆè¿­ä»£æ³•ï¼‰
- **Morriséå†**ï¼šO(1)é¢å¤–ç©ºé—´ï¼Œåˆ©ç”¨ç©ºæŒ‡é’ˆä¸´æ—¶é“¾æ¥ã€‚
##### æ—¶é—´å¤æ‚åº¦
- æ‰€æœ‰éå†ï¼šO(n)ï¼ˆæ¯ä¸ªç»“ç‚¹è®¿é—®ä¸€æ¬¡ï¼‰ã€‚
##### é€’å½’ä¸‰åºéå†(ä½¿ç”¨æ—¶ä¸è¦å¿˜äº†å¼•ç”¨å‚æ•° ä¾‹å¦‚preorder(Node* rootï¼Œvector< >& res))
```cpp
struct Node {
    int val;
    Node* left, *right;
};

void preorder(Node* root) {  // å…ˆåº
    if (!root) return;
    cout << root->val << " ";
    preorder(root->left);
    preorder(root->right);
}

void inorder(Node* root) {   // ä¸­åº
    if (!root) return;
    inorder(root->left);
    cout << root->val << " ";
    inorder(root->right);
}

void postorder(Node* root) { // ååº
    if (!root) return;
    postorder(root->left);
    postorder(root->right);
    cout << root->val << " ";
}
```
##### è¿­ä»£æ³•ï¼š![[Pasted image 20251112220310.png]]
```cpp
//å‰åºéå†
//æ ˆå…ˆè¿›åå‡ºï¼Œæ‰€ä»¥å…ˆpopä¸­ï¼Œç„¶åä¼ å…¥å³ï¼Œæœ€åä¼ å…¥å·¦
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // ä¸­
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right);           // å³ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
            if (node->left) st.push(node->left);             // å·¦ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
        }
        return result;
    }
};
//ä¸­åºéå†ï¼ï¼ï¼ï¼å®Œå…¨ä¸åŒ
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // æŒ‡é’ˆæ¥è®¿é—®èŠ‚ç‚¹ï¼Œè®¿é—®åˆ°æœ€åº•å±‚
                st.push(cur); // å°†è®¿é—®çš„èŠ‚ç‚¹æ”¾è¿›æ ˆ
                cur = cur->left;                // å·¦
            } else {
                cur = st.top(); // ä»æ ˆé‡Œå¼¹å‡ºçš„æ•°æ®ï¼Œå°±æ˜¯è¦å¤„ç†çš„æ•°æ®ï¼ˆæ”¾è¿›resultæ•°ç»„é‡Œçš„æ•°æ®ï¼‰
                st.pop();
                result.push_back(cur->val);     // ä¸­
                cur = cur->right;               // å³
            }
        }
        return result;
    }
};
//ååºéå†ï¼ˆä¸å‰åºç›¸ä¼¼
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // ç›¸å¯¹äºå‰åºéå†ï¼Œè¿™æ›´æ”¹ä¸€ä¸‹å…¥æ ˆé¡ºåº ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
            if (node->right) st.push(node->right); // ç©ºèŠ‚ç‚¹ä¸å…¥æ ˆ
        }
        reverse(result.begin(), result.end()); // å°†ç»“æœåè½¬ä¹‹åå°±æ˜¯å·¦å³ä¸­çš„é¡ºåºäº†
        return result;
    }
};
```
##### ç»Ÿä¸€é£æ ¼çš„è¿­ä»£å†™æ³•
```cpp
//ä¸­åºéå†
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop(); // å°†è¯¥èŠ‚ç‚¹å¼¹å‡ºï¼Œé¿å…é‡å¤æ“ä½œï¼Œä¸‹é¢å†å°†å³ä¸­å·¦èŠ‚ç‚¹æ·»åŠ åˆ°æ ˆä¸­
                if (node->right) st.push(node->right);  // æ·»åŠ å³èŠ‚ç‚¹ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰

                st.push(node);                          // æ·»åŠ ä¸­èŠ‚ç‚¹
                st.push(NULL); // ä¸­èŠ‚ç‚¹è®¿é—®è¿‡ï¼Œä½†æ˜¯è¿˜æ²¡æœ‰å¤„ç†ï¼ŒåŠ å…¥ç©ºèŠ‚ç‚¹åšä¸ºæ ‡è®°ã€‚

                if (node->left) st.push(node->left);    // æ·»åŠ å·¦èŠ‚ç‚¹ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
            } else { // åªæœ‰é‡åˆ°ç©ºèŠ‚ç‚¹çš„æ—¶å€™ï¼Œæ‰å°†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ”¾è¿›ç»“æœé›†
                st.pop();           // å°†ç©ºèŠ‚ç‚¹å¼¹å‡º
                node = st.top();    // é‡æ–°å–å‡ºæ ˆä¸­å…ƒç´ 
                st.pop();
                result.push_back(node->val); // åŠ å…¥åˆ°ç»“æœé›†
            }
        }
        return result;
    }
};
//å‰åºéå†
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                if (node->right) st.push(node->right);  // å³
                if (node->left) st.push(node->left);    // å·¦
                st.push(node);                          // ä¸­
                st.push(NULL);
            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};
//ååºéå†
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                st.push(node);                          // ä¸­
                st.push(NULL);

                if (node->right) st.push(node->right);  // å³
                if (node->left) st.push(node->left);    // å·¦

            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};
```
##### å±‚åºéå†ï¼Œä½¿ç”¨==é˜Ÿåˆ—==(è¿­ä»£ å¹¿åº¦ä¼˜å…ˆéå†)
```cpp
vector<vector<int>> levelOrder(Node* root) {
    if (!root) return {};// ç©ºæ ‘ç›´æ¥è¿”å›ç©ºæ•°ç»„
    vector<vector<int>> res;// å­˜å‚¨æœ€ç»ˆç»“æœ
    queue<Node*> q;// BFSä½¿ç”¨çš„é˜Ÿåˆ—
    q.push(root);  // æ ¹èŠ‚ç‚¹å…¥é˜Ÿ
    while (!q.empty()) {// é˜Ÿåˆ—ä¸ä¸ºç©ºå°±ç»§ç»­
        int sz = q.size(); // å…³é”®ï¼šè®°å½•å½“å‰å±‚çš„èŠ‚ç‚¹æ•°é‡
        res.push_back({}); // ä¸ºå½“å‰å±‚åˆ›å»ºä¸€ä¸ªç©ºæ•°ç»„
        for (int i = 0; i < sz; ++i) {// å¤„ç†å½“å‰å±‚çš„æ‰€æœ‰èŠ‚ç‚¹
            Node* cur = q.front(); 
            q.pop();// å–å‡ºé˜Ÿé¦–èŠ‚ç‚¹
            res.back().push_back(cur->val);
             //res.back()è·å–æœ€åæ·»åŠ çš„å­æ•°ç»„ï¼ˆå½“å‰å±‚ï¼‰              
             //å°†èŠ‚ç‚¹å€¼åŠ å…¥å½“å‰å±‚æ•°ç»„ 
             // å°†å­èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—ï¼ˆä¸‹ä¸€å±‚ï¼‰
            if (cur->left) q.push(cur->left);
            if (cur->right) q.push(cur->right);
        }
    }
    return res;
}
```
##### leetcode94. Binary Tree Inorder Traversal(ä¸­åºéå†)
Given theÂ `root`Â of a binary tree, returnÂ _the inorder traversal of its nodes' values_.
é€’å½’ï¼š
```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
       vector<int> result;
       traversal(root, result) ;
       return result;
    }
    void traversal(TreeNode* cur, vector<int>& vec){
        if(cur == NULL) return;
        traversal(cur -> left, vec);
        vec.push_back(cur -> val);
        traversal(cur -> right, vec);
    }
};
```
è¿­ä»£ï¼š
```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* curr = root;
        
        while(curr || !st.empty()) {
            // éå†åˆ°æœ€å·¦èŠ‚ç‚¹
            while(curr) {
                st.push(curr);
                curr = curr->left;
            }
            
            // è®¿é—®èŠ‚ç‚¹
            curr = st.top();
            st.pop();
            result.push_back(curr->val);
            
            // è½¬å‘å³å­æ ‘
            curr = curr->right;
        }
        
        return result;
    }
};
```
psï¼šè¿™é‡Œä½¿ç”¨äº†äºŒç»´åŠ¨æ€æ•°ç»„
- **ä¸€ç»´åŠ¨æ€æ•°ç»„**ï¼šç›´æ¥Â `res.push_back(value)`
- **äºŒç»´åŠ¨æ€æ•°ç»„**ï¼šéœ€è¦Â `res.back().push_back(value)`Â æ¥æŒ‡å®šæ·»åŠ åˆ°å“ªä¸ªå­æ•°ç»„
##### leetcode144. Binary Tree Preorder Traversal(å‰åºéå†)ï¼ˆæ ˆï¼‰
Given theÂ `root`Â of a binary tree, returnÂ _the preorder traversal of its nodes' values_.

## 3 æ ‘çš„éå†
##### å®šä¹‰
æ ‘çš„éå†æ˜¯è®¿é—®æ ‘ä¸­æ‰€æœ‰ç»“ç‚¹çš„æ–¹æ³•ã€‚é€šç”¨æ ‘ï¼ˆéäºŒå‰ï¼‰éå†å¸¸ç”¨DFSå’ŒBFSï¼Œä¸åŒºåˆ†å·¦å³é¡ºåºã€‚
##### æ–¹æ³•
1. **DFSï¼ˆæ·±åº¦ä¼˜å…ˆæœç´¢ï¼‰**ï¼šä»æ ¹é€’å½’è®¿é—®æ¯ä¸ªå­æ ‘ã€‚é€‚åˆæ±‚æ·±åº¦ã€å­æ ‘å¤§å°ã€‚
2. **BFSï¼ˆå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼‰**ï¼šæŒ‰å±‚è®¿é—®ï¼ˆé˜Ÿåˆ—å®ç°ï¼‰ã€‚é€‚åˆæ±‚æœ€çŸ­è·¯å¾„æˆ–å±‚åºä¿¡æ¯ã€‚
##### ç®—æ³•
- DFSï¼šé€’å½’æˆ–æ ˆæ¨¡æ‹Ÿï¼Œé¿å…å›è®¿çˆ¶ç»“ç‚¹ã€‚
- BFSï¼šé˜Ÿåˆ—ï¼Œä»æ ¹å…¥é˜Ÿï¼Œé€å±‚å¤„ç†å­ç»“ç‚¹ã€‚
##### æ—¶é—´å¤æ‚åº¦
- O(n)ï¼ˆæ¯ä¸ªç»“ç‚¹/è¾¹è®¿é—®ä¸€æ¬¡ï¼‰ã€‚
##### ä»£ç ç¤ºä¾‹ï¼ˆé€šç”¨æ ‘DFSéå†ï¼‰
```cpp
void dfs(int u, int parent) {
    // å¤„ç†ç»“ç‚¹u
    for (int v : adj[u]) {
        if (v != parent) {
            dfs(v, u);
        }
    }
}
```
##### ä»£ç ç¤ºä¾‹ï¼ˆé€šç”¨æ ‘BFSéå†ï¼Œè®¡ç®—å±‚æ•°ï¼Œè®¡ç®—æœ€çŸ­è·¯å¾„ï¼ˆæ— æƒå›¾ï¼‰ï¼Œæ¸¸æˆä¸­çš„æ‰©å±•æ•ˆæœï¼‰
```cpp
void bfs(int root) {
    queue<pair<int, int>> q; //é˜Ÿåˆ—å­˜å‚¨{èŠ‚ç‚¹, å±‚çº§} é”®å€¼å¯¹
    q.push({root, 0}); // æ ¹èŠ‚ç‚¹å…¥é˜Ÿï¼Œå±‚çº§ä¸º0
    vector<bool> vis(N, false);// è®¿é—®æ ‡è®°æ•°ç»„
    vis[root] = true; // æ ‡è®°æ ¹èŠ‚ç‚¹å·²è®¿é—®
    while (!q.empty()) {
        auto [u, level] = q.front(); // ç»“æ„åŒ–ç»‘å®š
        // è‡ªåŠ¨åˆ›å»ºä¸¤ä¸ªå˜é‡ï¼šuå’Œlevelï¼Œå¹¶åˆ†åˆ«èµ‹å€¼ä¸ºfirstå’Œsecond
        // è·å–ä¸‹ä¸€ä¸ªèŠ‚ç‚¹uå’Œå®ƒçš„å±‚çº§level
        q.pop();
        // å°†è¯¥èŠ‚ç‚¹ä»å¾…å¤„ç†é˜Ÿåˆ—ä¸­ç§»é™¤
        cout << "ç»“ç‚¹ " << u << " åœ¨å±‚ " << level << endl;
        // ç°åœ¨å¯ä»¥å¤„ç†èŠ‚ç‚¹uäº†
        for (int v : adj[u]) {
         // éå†uçš„é‚»å±…
            if (!vis[v]) {
                vis[v] = true;
                q.push({v, level + 1});
            }
        }
    }
}
```
##### leetcode94. Binary Tree Inorder Traversal(ä¸­åºéå†dfså˜ä½“)
```cpp
class Solution {
private: 
    void dfs(TreeNode* node, vector<int>& res){
        if(!node)return;
        dfs(node->left, res);     // å…ˆå¤„ç†å·¦å­æ ‘
        res.emplace_back(node->val);  // å†å¤„ç†å½“å‰èŠ‚ç‚¹
        dfs(node->right, res);    // æœ€åå¤„ç†å³å­æ ‘
    }

public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        dfs(root, res);
        return res;
    }
};
```

## 4 äºŒå‰æŸ¥æ‰¾æ ‘ (BST)

##### å®šä¹‰
äºŒå‰æŸ¥æ‰¾æ ‘ï¼ˆBSTï¼‰æ˜¯ä¸€ç§äºŒå‰æ ‘ï¼Œæ¯ä¸ªç»“ç‚¹æ»¡è¶³ï¼š==å·¦å­æ ‘æ‰€æœ‰å€¼ < æ ¹å€¼ < å³å­æ ‘æ‰€æœ‰å€¼ã€‚ç©ºæ ‘ä¹Ÿæ˜¯BSTã€‚==
 åº”ç”¨äºŒå‰æŸ¥æ‰¾æ ‘å®ç°çš„æ•°æ®ç»“æ„ä¸€èˆ¬ä¸º $set$ æˆ– $map$ï¼Œè‹¥ä¸º $set$ (ä¾‹å¦‚ Java ä¸­çš„ $TreeSet$)ï¼Œåˆ™ä¸ä¼šå­˜å‚¨ç›¸åŒæ•°æ®é¡¹ï¼Œè‹¥ä¸º $map$ (ä¾‹å¦‚ Java ä¸­çš„ $TreeMap$)ï¼Œåˆ™ä¸ä¼šå­˜å‚¨ç›¸åŒ $key$ å€¼ã€‚è‹¥è¦æ±‚ä¿å­˜ç›¸åŒå€¼ï¼Œå¯ä»¥é‡‡ç”¨é“¾è¡¨æˆ–å°†ç›¸åŒå€¼çœ‹ä½œå°äºæˆ–å¤§äºæ¥å¤„ç†
##### æ€§è´¨
- ä¸­åºéå†äº§ç”Ÿæœ‰åºåºåˆ—ã€‚
- æ“ä½œå¤æ‚åº¦å–å†³äºæ ‘é«˜ hï¼šO(h)ï¼Œæœ€ä¼˜O(log n)ï¼Œæœ€åO(n)ï¼ˆé€€åŒ–é“¾è¡¨ï¼‰ã€‚
##### æ“ä½œ
1. **æœç´¢**ï¼šä»æ ¹æ¯”è¾ƒï¼Œå‘å·¦/å³é€’å½’ã€‚
2. **æ’å…¥**ï¼šç±»ä¼¼æœç´¢ï¼Œåˆ°ç©ºä½æ’å…¥ï¼Œæ›´æ–°å¤§å°ã€‚
3. **åˆ é™¤**ï¼šè‹¥é‡å¤å‡è®¡æ•°ï¼›å¦åˆ™ç”¨åç»§æ›¿æ¢ï¼Œå†é€’å½’åˆ é™¤ã€‚
4. **æ’å/é€‰ç¬¬k**ï¼šåˆ©ç”¨å­æ ‘å¤§å°ç»´æŠ¤ã€‚
##### æ—¶é—´å¤æ‚åº¦
- åŸºæœ¬æ“ä½œï¼šO(h)ã€‚
##### æŸ¥æ‰¾èŠ‚ç‚¹
ç»™å®šç›®æ ‡èŠ‚ç‚¹å€¼numï¼Œå¯ä»¥æ ¹æ®äºŒå‰æœç´¢æ ‘çš„æ€§è´¨æ¥æŸ¥æ‰¾ã€‚
æˆ‘ä»¬å£°æ˜ä¸€ä¸ªèŠ‚ç‚¹ cur ï¼Œä»äºŒå‰ æ ‘çš„æ ¹èŠ‚ç‚¹ root å‡ºå‘ï¼Œå¾ªç¯æ¯”è¾ƒèŠ‚ç‚¹å€¼ cur.val å’Œnumçš„å…³ç³»
- è‹¥ cur.val < num ï¼Œè¯´æ˜ç›®æ ‡èŠ‚ç‚¹åœ¨curçš„å³å­æ ‘ä¸­ï¼Œå› æ­¤æ‰§è¡Œ cur = cur.right ã€‚
- è‹¥ cur.val > num ï¼Œè¯´æ˜ç›®æ ‡èŠ‚ç‚¹åœ¨curçš„å·¦å­æ ‘ä¸­ï¼Œå› æ­¤æ‰§è¡Œ cur = cur.leftã€‚
- è‹¥ cur.val = num ï¼Œè¯´æ˜æ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹ï¼Œè·³å‡ºå¾ªç¯å¹¶è¿”å›è¯¥èŠ‚ç‚¹ã€‚
äºŒå‰æœç´¢æ ‘çš„æŸ¥æ‰¾æ“ä½œä¸äºŒåˆ†æŸ¥æ‰¾ç®—æ³•çš„å·¥ä½œåŸç†ä¸€è‡´ï¼Œéƒ½æ˜¯æ¯è½®æ’é™¤ä¸€åŠæƒ…å†µã€‚å¾ªç¯æ¬¡æ•°æœ€å¤šä¸ºäºŒå‰æ ‘çš„é«˜åº¦ã€‚
```cpp
TreeNode *search(int num) {
    TreeNode *cur = root;
    // å¾ªç¯æŸ¥æ‰¾ï¼Œè¶Šè¿‡å¶èŠ‚ç‚¹åè·³å‡º
    while (cur != nullptr) {
        // ç›®æ ‡èŠ‚ç‚¹åœ¨ cur çš„å³å­æ ‘ä¸­
        if (cur->val < num)
            cur = cur->right;
        // ç›®æ ‡èŠ‚ç‚¹åœ¨ cur çš„å·¦å­æ ‘ä¸­
        else if (cur->val > num)
            cur = cur->left;
        // æ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹ï¼Œè·³å‡ºå¾ªç¯
        else
            break;
    }
    // è¿”å›ç›®æ ‡èŠ‚ç‚¹
    return cur;
}
```
##### æ’å…¥èŠ‚ç‚¹
1. æŸ¥æ‰¾æ’å…¥ä½ç½®ï¼šä¸æŸ¥æ‰¾æ“ä½œç›¸ä¼¼ï¼Œä»æ ¹èŠ‚ç‚¹å‡ºå‘ï¼Œæ ¹æ®å½“å‰èŠ‚ç‚¹å€¼numçš„å¤§å°å…³ç³»å¾ªç¯å‘ä¸‹æœç´¢ï¼Œç›´åˆ°è¶Šè¿‡å¶èŠ‚ç‚¹ï¼ˆéå†è‡³ None ï¼‰æ—¶è·³å‡ºå¾ªç¯ã€‚ 
2. åœ¨è¯¥ä½ç½®æ’å…¥èŠ‚ç‚¹ï¼šåˆå§‹åŒ–èŠ‚ç‚¹numï¼Œå°†è¯¥èŠ‚ç‚¹ç½®äºNoneçš„ä½ç½®ã€‚
```cpp
void insert(int num) {
    // è‹¥æ ‘ä¸ºç©ºï¼Œåˆ™åˆå§‹åŒ–æ ¹èŠ‚ç‚¹
    if (root == nullptr) {
        root = new TreeNode(num);
        return;
    }
    TreeNode *cur = root, *pre = nullptr;
    // å¾ªç¯æŸ¥æ‰¾ï¼Œè¶Šè¿‡å¶èŠ‚ç‚¹åè·³å‡º
    while (cur != nullptr) {
        // æ‰¾åˆ°é‡å¤èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›
        if (cur->val == num)
            return;
        pre = cur;// preæŒ‡å‘çš„æ˜¯é‡å¤èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹,éœ€è¦æœ‰ä¸€ä¸ªæŒ‡é’ˆæ¥æŒ‡å‘çˆ¶èŠ‚ç‚¹æ¥ä¿è¯å¢åŠ ç»“ç‚¹æ—¶èƒ½æ‰¾åˆ°ç»“ç‚¹çš„ä½ç½®
        // æ’å…¥ä½ç½®åœ¨ cur çš„å³å­æ ‘ä¸­
        if (cur->val < num)
            cur = cur->right;
        // æ’å…¥ä½ç½®åœ¨ cur çš„å·¦å­æ ‘ä¸­
        else
            cur = cur->left;
    }
    // æ’å…¥èŠ‚ç‚¹
    TreeNode *node = new TreeNode(num);
    if (pre->val < num)
        pre->right = node;
    else
        pre->left = node;
}
```

psï¼š
1.æ˜¯å¦èƒ½å°†returnæ”¹ä¸ºbreakï¼Ÿ
**ä¸å¯ä»¥**å°†Â `return;`Â æ”¹æˆÂ `break;`ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªè¯­å¥çš„åŠŸèƒ½å®Œå…¨ä¸åŒï¼
`return;`Â çš„ä½œç”¨
- **ç«‹å³ç»“æŸæ•´ä¸ªå‡½æ•°**çš„æ‰§è¡Œ
- è¿”å›åˆ°å‡½æ•°çš„è°ƒç”¨å¤„
- å‡½æ•°ä¸­Â `return`Â åé¢çš„ä»£ç éƒ½ä¸ä¼šæ‰§è¡Œ
 `break;`Â çš„ä½œç”¨
- **åªè·³å‡ºå½“å‰å¾ªç¯**ï¼ˆwhile/forï¼‰
- ç»§ç»­æ‰§è¡Œå¾ªç¯åé¢çš„ä»£ç 
- ä¸ä¼šç»“æŸæ•´ä¸ªå‡½æ•°
2.pre = cur;å’Œreturnçš„é¡ºåºå¯ä»¥æ¢ä¸€ä¸‹å—?
**ä¸å¯ä»¥**è°ƒæ¢Â `pre = cur;`Â å’ŒÂ `return;`Â çš„é¡ºåºï¼Œå› ä¸ºè¿™ä¼šç ´åç®—æ³•çš„é€»è¾‘ã€‚
å¦‚æœè°ƒæ¢é¡ºåºï¼Œå½“æ‰¾åˆ°é‡å¤èŠ‚ç‚¹æ—¶ï¼š
- `pre`Â å·²ç»æŒ‡å‘äº†é‡å¤èŠ‚ç‚¹Â `cur`
- è¿™ä¼šå¯¼è‡´Â `pre`Â æŒ‡å‘é”™è¯¯çš„ä½ç½®
- è™½ç„¶è¿™é‡Œç«‹å³Â `return`Â ä¸ä¼šä½¿ç”¨åˆ°Â `pre`ï¼Œä½†**ç ´åäº†ä»£ç çš„é€»è¾‘ä¸€è‡´æ€§**

##### åˆ é™¤èŠ‚ç‚¹
æ­¥éª¤ï¼š
1. æŸ¥æ‰¾å¾…åˆ é™¤èŠ‚ç‚¹
```cpp
TreeNode *cur = root, *pre = nullptr;
while (cur != nullptr) {
    if (cur->val == num)
        break;
    pre = cur;//preæŒ‡é’ˆè®°å½•å½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œä¸ºåç»­åˆ é™¤åšå‡†å¤‡
    if (cur->val < num)
        cur = cur->right;
    else
        cur = cur->left;
}
```
2. å¤„ç†ä¸‰ç§åˆ é™¤æƒ…å†µ
æƒ…å†µ1ï¼šåº¦ä¸º0çš„èŠ‚ç‚¹ï¼ˆå¶å­èŠ‚ç‚¹ï¼‰
- ç›´æ¥åˆ é™¤ï¼Œçˆ¶èŠ‚ç‚¹å¯¹åº”æŒ‡é’ˆè®¾ä¸ºÂ `nullptr`
æƒ…å†µ2ï¼šåº¦ä¸º1çš„èŠ‚ç‚¹
- ç”¨å­èŠ‚ç‚¹æ›¿æ¢å¾…åˆ é™¤èŠ‚ç‚¹
- æ›´æ–°çˆ¶èŠ‚ç‚¹çš„æŒ‡é’ˆæŒ‡å‘å­èŠ‚ç‚¹
```cpp
TreeNode *child = cur->left != nullptr ? cur->left : cur->right;
if (pre->left == cur)
    pre->left = child;
else
    pre->right = child;
```
æƒ…å†µ3ï¼šåº¦ä¸º2çš„èŠ‚ç‚¹
**å½“åˆ é™¤æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹çš„èŠ‚ç‚¹æ—¶ï¼Œæˆ‘ä»¬ä¸ç›´æ¥åˆ é™¤å®ƒï¼Œè€Œæ˜¯æ‰¾ä¸€ä¸ª"æ›¿èº«"æ¥æ›¿æ¢å®ƒï¼Œç„¶ååˆ é™¤é‚£ä¸ª"æ›¿èº«"ã€‚**è¿™ä¸ªæ›¿èº«å°±æ˜¯**å³å­æ ‘ä¸­æœ€å°çš„èŠ‚ç‚¹**ï¼ˆæœ€å·¦è¾¹çš„èŠ‚ç‚¹ï¼‰ã€‚
**ä¸ºä»€ä¹ˆé€‰å®ƒï¼Ÿ**
- å®ƒæ¯”å½“å‰èŠ‚ç‚¹çš„æ‰€æœ‰å·¦å­æ ‘èŠ‚ç‚¹éƒ½å¤§
- å®ƒæ¯”å½“å‰èŠ‚ç‚¹çš„å…¶ä»–å³å­æ ‘èŠ‚ç‚¹éƒ½å°
- ç”¨å®ƒæ›¿æ¢èƒ½ä¿æŒäºŒå‰æœç´¢æ ‘çš„æ€§è´¨
æ­¥éª¤ï¼š
- æ‰¾åˆ°å³å­æ ‘ä¸­çš„æœ€å°èŠ‚ç‚¹ï¼ˆä¸­åºéå†çš„åç»§èŠ‚ç‚¹ï¼‰
- é€’å½’åˆ é™¤è¯¥åç»§èŠ‚ç‚¹ï¼ˆå…¶åº¦å¿…ä¸º0æˆ–1ï¼‰
- ç”¨åç»§èŠ‚ç‚¹çš„å€¼æ›¿æ¢å¾…åˆ é™¤èŠ‚ç‚¹çš„å€¼
```cpp
// æ‰¾åˆ°å³å­æ ‘çš„æœ€å°èŠ‚ç‚¹ï¼ˆä¸­åºåç»§ï¼‰
TreeNode *tmp = cur->right;
while (tmp->left != nullptr) {
    tmp = tmp->left;
}

int tmpVal = tmp->val;
// é€’å½’åˆ é™¤åç»§èŠ‚ç‚¹
remove(tmp->val);
// ç”¨åç»§èŠ‚ç‚¹çš„å€¼æ›¿æ¢å½“å‰èŠ‚ç‚¹
cur->val = tmpVal;
```
å›¾ç¤ºï¼š
```cpp
åˆå§‹æ ‘ï¼š
      5
     / \
    3   6
   / \   \
  2   4   7

åˆ é™¤èŠ‚ç‚¹3ï¼ˆåº¦ä¸º2ï¼‰ï¼š
1. æ‰¾åˆ°å³å­æ ‘æœ€å°èŠ‚ç‚¹ï¼š4
2. é€’å½’åˆ é™¤èŠ‚ç‚¹4ï¼ˆåº¦ä¸º0ï¼‰
3. ç”¨4æ›¿æ¢3çš„å€¼

ç»“æœï¼š
      5
     / \
    4   6
   /     \
  2       7
```
**å®Œæ•´ä»£ç **
```cpp
void remove(int num) {
    // è‹¥æ ‘ä¸ºç©ºï¼Œç›´æ¥æå‰è¿”å›
    if (root == nullptr)
        return;
    
    TreeNode *cur = root, *pre = nullptr;
    // å¾ªç¯æŸ¥æ‰¾ï¼Œè¶Šè¿‡å¶èŠ‚ç‚¹åè·³å‡º
    while (cur != nullptr) {
        // æ‰¾åˆ°å¾…åˆ é™¤èŠ‚ç‚¹ï¼Œè·³å‡ºå¾ªç¯
        if (cur->val == num)
            break;
        pre = cur;
        // å¾…åˆ é™¤èŠ‚ç‚¹åœ¨ cur çš„å³å­æ ‘ä¸­
        if (cur->val < num)
            cur = cur->right;
        // å¾…åˆ é™¤èŠ‚ç‚¹åœ¨ cur çš„å·¦å­æ ‘ä¸­
        else
            cur = cur->left;
    }
    
    // è‹¥æ— å¾…åˆ é™¤èŠ‚ç‚¹ï¼Œåˆ™ç›´æ¥è¿”å›
    if (cur == nullptr)
        return;
    
    // å­èŠ‚ç‚¹æ•°é‡ = 0 or 1
    if (cur->left == nullptr || cur->right == nullptr) {
        // å½“å­èŠ‚ç‚¹æ•°é‡ = 0 / 1 æ—¶ï¼Œchild = nullptr / è¯¥å­èŠ‚ç‚¹
        TreeNode *child = cur->left != nullptr ? cur->left : cur->right;
        
        // åˆ é™¤èŠ‚ç‚¹ cur
        if (cur != root) {
            if (pre->left == cur)
                pre->left = child;
            else
                pre->right = child;
        } else {
            // è‹¥åˆ é™¤èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹ï¼Œåˆ™é‡æ–°æŒ‡å®šæ ¹èŠ‚ç‚¹
            root = child;
        }
        // é‡Šæ”¾å†…å­˜
        delete cur;
    }
    // å­èŠ‚ç‚¹æ•°é‡ = 2
    else {
        // è·å–ä¸­åºéå†ä¸­ cur çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        TreeNode *tmp = cur->right;
        while (tmp->left != nullptr) {
            tmp = tmp->left;
        }
        
        int tmpVal = tmp->val;
        // é€’å½’åˆ é™¤èŠ‚ç‚¹ tmp
        remove(tmp->val);
        // ç”¨ tmp è¦†ç›– cur
        cur->val = tmpVal;
    }
}
```
psï¼š**`cur`**ï¼šè´Ÿè´£"æ‰¾åˆ°è¦åˆ é™¤è°" **`pre`**ï¼šè´Ÿè´£"çŸ¥é“åˆ é™¤åè¦è¿æ¥è°"
`cur`ï¼ˆå½“å‰æŒ‡é’ˆï¼‰
- **ä½œç”¨**ï¼šéå†æ ‘ï¼ŒæŸ¥æ‰¾å¾…åˆ é™¤çš„èŠ‚ç‚¹
- **åˆå§‹å€¼**ï¼šæŒ‡å‘æ ¹èŠ‚ç‚¹Â `root`
- **æœ€ç»ˆå€¼**ï¼šæŒ‡å‘æ‰¾åˆ°çš„å¾…åˆ é™¤èŠ‚ç‚¹ï¼Œæˆ–è€…ä¸ºÂ `nullptr`ï¼ˆæœªæ‰¾åˆ°ï¼‰
 `pre`ï¼ˆå‰é©±æŒ‡é’ˆï¼‰
- **ä½œç”¨**ï¼šè®°å½•Â `cur`Â çš„çˆ¶èŠ‚ç‚¹ï¼Œç”¨äºåç»­çš„æŒ‡é’ˆè°ƒæ•´
- **åˆå§‹å€¼**ï¼š`nullptr`
- **æœ€ç»ˆå€¼**ï¼šæŒ‡å‘å¾…åˆ é™¤èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
##### ä¸­åºéå†æœ‰åº
äºŒå‰æœç´¢æ ‘ä¸­è¿›è¡Œä¸­åºéå†æ—¶ï¼Œæ€»æ˜¯ä¼šä¼˜å…ˆéå†ä¸‹ä¸€ä¸ªæœ€å°èŠ‚ç‚¹ï¼Œä»è€Œå¾—å‡ºä¸€ä¸ªé‡è¦æ€§è´¨ï¼šäºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†åºåˆ—æ˜¯å‡åºçš„
![[Pasted image 20251112154710.png]]
##### leetcode98. Validate Binary Search Tree
Given theÂ `root`Â of a binary tree,Â _determine if it is a valid binary search tree (BST)_.
AÂ **valid BST**Â is defined as follows:
- The leftÂ subtreeÂ of a node contains only nodes with keysÂ **strictly less than**Â the node's key.
- The right subtree of a node contains only nodes with keysÂ **strictly greater than**Â the node's key.
- Both the left and right subtrees must also be binary search trees.
ä¸­åºæ€è·¯ï¼š
1. å¦‚æœå½“å‰èŠ‚ç‚¹ä¸ºç©ºï¼Œè¿”å›trueã€‚
2. å…ˆé€’å½’æ£€æŸ¥å·¦å­æ ‘ï¼Œå¦‚æœå·¦å­æ ‘ä¸æ˜¯BSTï¼Œç›´æ¥è¿”å›falseã€‚
3. æ£€æŸ¥å½“å‰èŠ‚ç‚¹ï¼šå¦‚æœå½“å‰èŠ‚ç‚¹çš„å€¼å°äºç­‰äºpreï¼ˆå³å‰ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼ï¼‰ï¼Œè¯´æ˜ä¸æ»¡è¶³BSTæ€§è´¨ï¼Œè¿”å›falseã€‚
4. æ›´æ–°preä¸ºå½“å‰èŠ‚ç‚¹çš„å€¼ã€‚
5. é€’å½’æ£€æŸ¥å³å­æ ‘ã€‚
```cpp
//å‰åºéå†dfs
class Solution {
public:
    bool isValidBST(TreeNode* root, long long left = LLONG_MIN, long long right = LLONG_MAX) {
        if (root == nullptr) {
            return true;
        }
        long long x = root->val;
        return left < x && x < right &&
               isValidBST(root->left, left, x) &&
               isValidBST(root->right, x, right);
    }
};
//ä¸­åºéå† æŠŠäºŒå‰æœç´¢æ ‘çœ‹æˆä¸€ä¸ªæœ‰åºæ•°ç»„
class Solution {
    long long pre = LLONG_MIN;
public:
    bool isValidBST(TreeNode* root) {
        if (root == nullptr) { // ç©ºæ ‘æ˜¯æœ‰æ•ˆçš„BST
            return true;
        }
        if (!isValidBST(root->left)) { // å·¦  å¦‚æœå·¦å­æ ‘ä¸æ˜¯BSTï¼Œç›´æ¥è¿”å›false
            return false;
        }
        if (root->val <= pre) { // ä¸­  å½“å‰èŠ‚ç‚¹å€¼å¿…é¡»å¤§äºå‰ä¸€ä¸ªèŠ‚ç‚¹å€¼  ä»å·¦è¾¹åç”µæ¢¯ä¸Šå»ï¼Œæ‰€ä»¥preå°
            return false;
        }
        pre = root->val;  // æ›´æ–°å‰ä¸€ä¸ªèŠ‚ç‚¹å€¼ä¸ºå½“å‰èŠ‚ç‚¹å€¼
        return isValidBST(root->right); // å³   æ£€æŸ¥å³å­æ ‘
    }
};
//ååºéå†dfs
class Solution {
    pair<long long, long long> dfs(TreeNode* node) {
        if (node == nullptr) {
            return {LLONG_MAX, LLONG_MIN};
        }
        auto[l_min, l_max] = dfs(node->left);
        auto[r_min, r_max] = dfs(node->right);
        long long x = node->val;
        // ä¹Ÿå¯ä»¥åœ¨é€’å½’å®Œå·¦å­æ ‘ä¹‹åç«‹åˆ»åˆ¤æ–­ï¼Œå¦‚æœå‘ç°ä¸æ˜¯äºŒå‰æœç´¢æ ‘ï¼Œå°±ä¸ç”¨é€’å½’å³å­æ ‘äº†
        if (x <= l_max || x >= r_min) {
            return {LLONG_MIN, LLONG_MAX};
        }
        return {min(l_min, x), max(r_max, x)};
    }

public:
    bool isValidBST(TreeNode* root) {
        return dfs(root).second != LLONG_MAX;
    }
};
```
ä¸­åºå›¾è§£ï¼š
```cpp
      5
     / \
    3   7
   / \   \
  1   4   8
  
isValidBST(5)
â”œâ”€â”€ isValidBST(3)
â”‚   â”œâ”€â”€ isValidBST(1)
â”‚   â”‚   â”œâ”€â”€ left: null â†’ true
â”‚   â”‚   â”œâ”€â”€ check: 1 > LLONG_MIN âœ“, pre=1
â”‚   â”‚   â””â”€â”€ right: null â†’ true
â”‚   â”œâ”€â”€ check: 3 > 1 âœ“, pre=3
â”‚   â””â”€â”€ isValidBST(4)
â”‚       â”œâ”€â”€ left: null â†’ true
â”‚       â”œâ”€â”€ check: 4 > 3 âœ“, pre=4
â”‚       â””â”€â”€ right: null â†’ true
â”œâ”€â”€ check: 5 > 4 âœ“, pre=5
â””â”€â”€ isValidBST(7)
    â”œâ”€â”€ left: null â†’ true
    â”œâ”€â”€ check: 7 > 5 âœ“, pre=7
    â””â”€â”€ isValidBST(8)
        â”œâ”€â”€ left: null â†’ true
        â”œâ”€â”€ check: 8 > 7 âœ“, pre=8
        â””â”€â”€ right: null â†’ true
â†’ è¿”å› true
```
##### leetcode 108. Convert Sorted Array to Binary Search Tree
Given an integer arrayÂ `nums`Â where the elements are sorted inÂ **ascending order**, convertÂ _it to a_Â **_height-balanced_**Â _binary search tree_.
```cpp
class Solution {
public:
    // é€’å½’æ„å»ºäºŒå‰æ ‘çš„è¾…åŠ©å‡½æ•°
    TreeNode* dfs(vector<int>& nums, int left, int right) {
        // åŸºå‡†æƒ…å†µï¼šå½“å·¦è¾¹ç•Œç­‰äºå³è¾¹ç•Œæ—¶ï¼ŒåŒºé—´ä¸ºç©º
        if(left == right) {
            return nullptr;
        }
        
        // è®¡ç®—ä¸­é—´ç´¢å¼•ï¼ˆé˜²æ­¢æ•´æ•°æº¢å‡ºï¼‰
        int m = left + (right - left) / 2;
        
        // åˆ›å»ºæ–°èŠ‚ç‚¹ï¼šä¸­é—´å€¼ä½œä¸ºæ ¹ï¼Œé€’å½’æ„å»ºå·¦å³å­æ ‘
        return new TreeNode(nums[m], 
                          dfs(nums, left, m),      // å·¦å­æ ‘ï¼šå·¦åŠéƒ¨åˆ†
                          dfs(nums, m + 1, right)); // å³å­æ ‘ï¼šå³åŠéƒ¨åˆ†
    }
    
    // ä¸»å‡½æ•°
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return dfs(nums, 0, nums.size());
    }
};
```
æ ¸å¿ƒç­–ç•¥ï¼š**åˆ†æ²»æ³•**
- æ¯æ¬¡é€‰æ‹©æ•°ç»„ä¸­é—´å…ƒç´ ä½œä¸ºæ ¹èŠ‚ç‚¹
- å·¦åŠéƒ¨åˆ†æ„å»ºå·¦å­æ ‘
- å³åŠéƒ¨åˆ†æ„å»ºå³å­æ ‘
- é€’å½’æ‰§è¡Œç›´åˆ°åŒºé—´ä¸ºç©º
å›¾è§£ï¼š
```cpp
`[10, 20, 30, 40, 50]`
åˆå§‹è°ƒç”¨: dfs([10,20,30,40,50], 0, 5)
    m = 2 â†’ æ ¹èŠ‚ç‚¹: 30
    â”œâ”€â”€ å·¦å­æ ‘: dfs([10,20], 0, 2)
    â”‚       m = 1 â†’ æ ¹èŠ‚ç‚¹: 20
    â”‚       â”œâ”€â”€ å·¦å­æ ‘: dfs([10], 0, 1) â†’ èŠ‚ç‚¹10
    â”‚       â””â”€â”€ å³å­æ ‘: dfs([], 2, 2) â†’ null
    â””â”€â”€ å³å­æ ‘: dfs([40,50], 3, 5)
            m = 4 â†’ æ ¹èŠ‚ç‚¹: 50
            â”œâ”€â”€ å·¦å­æ ‘: dfs([40], 3, 4) â†’ èŠ‚ç‚¹40
            â””â”€â”€ å³å­æ ‘: dfs([], 5, 5) â†’ null
```
## 5.å¹³è¡¡äºŒå‰æ ‘ (AVLæ ‘)
##### å®šä¹‰
AVLæ ‘æ˜¯è‡ªå¹³è¡¡çš„BSTï¼Œæ¯ä¸ªç»“ç‚¹å·¦å³å­æ ‘é«˜åº¦å·®ï¼ˆå¹³è¡¡å› å­ï¼‰ç»å¯¹å€¼ â‰¤1ã€‚
ç©ºèŠ‚ç‚¹é«˜åº¦ä¸º -1ï¼Œå¶èŠ‚ç‚¹é«˜åº¦ä¸º 0ã€‚
åœ¨å¤šæ¬¡æ’å…¥å’Œåˆ é™¤æ“ä½œåï¼ŒäºŒå‰æœç´¢æ ‘å¯èƒ½é€€åŒ–ä¸ºé“¾è¡¨ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ æ‰€æœ‰æ“ä½œçš„æ—¶é—´å¤æ‚åº¦å°†ä»ğ‘‚(logğ‘›)åŠ£åŒ–ä¸ºğ‘‚(ğ‘›)ã€‚
![[Pasted image 20251112161726.png]]
##### æ€§è´¨
- å¹³è¡¡å› å­ï¼šå³é«˜ - å·¦é«˜ = -1/0/1ã€‚(ä»»æ„èŠ‚ç‚¹çš„å¹³è¡¡å› å­å¿…é¡»æ»¡è¶³Â `-1 â‰¤ f â‰¤ 1`)
![[Pasted image 20251112162102.png]]
- æ ‘é«˜O(log n)ï¼Œæ“ä½œå¤æ‚åº¦O(log n)ã€‚
##### æ“ä½œ
- **æ—‹è½¬**ï¼šå·¦æ—‹/å³æ—‹è°ƒæ•´å¹³è¡¡ï¼ˆå•æ—‹/åŒæ—‹ï¼‰ã€‚
- **æ’å…¥/åˆ é™¤**ï¼šæ ‡å‡†BSTæ“ä½œåï¼Œè‡ªåº•å‘ä¸Šæ£€æŸ¥å¹³è¡¡å› å­ï¼Œè¿›è¡Œæ—‹è½¬ã€‚
##### æ—¶é—´å¤æ‚åº¦
- O(log n)ï¼ˆä¸¥æ ¼å¹³è¡¡ï¼‰ã€‚
##### **åŸºæœ¬å®šä¹‰**
```cpp
/* AVL æ ‘èŠ‚ç‚¹ç±» */
struct TreeNode {
    int val;          // èŠ‚ç‚¹å€¼
    int height = 0;   // èŠ‚ç‚¹é«˜åº¦
    TreeNode *left;   // å·¦å­èŠ‚ç‚¹
    TreeNode *right;  // å³å­èŠ‚ç‚¹
    TreeNode() = default;
    explicit TreeNode(int x) : val(x) {}
};

/* è·å–èŠ‚ç‚¹é«˜åº¦ */
int height(TreeNode *node) {
    // ç©ºèŠ‚ç‚¹é«˜åº¦ä¸º -1ï¼Œå¶èŠ‚ç‚¹é«˜åº¦ä¸º 0
    return node == nullptr ? -1 : node->height;
}

/* æ›´æ–°èŠ‚ç‚¹é«˜åº¦ */
void updateHeight(TreeNode *node) {
    // èŠ‚ç‚¹é«˜åº¦ç­‰äºæœ€é«˜å­æ ‘é«˜åº¦ + 1
    node->height = max(height(node->left), height(node->right)) + 1;
}

/* è·å–å¹³è¡¡å› å­ */
int balanceFactor(TreeNode *node) {
    // ç©ºèŠ‚ç‚¹å¹³è¡¡å› å­ä¸º 0
    if (node == nullptr)
        return 0;
    // èŠ‚ç‚¹å¹³è¡¡å› å­ = å·¦å­æ ‘é«˜åº¦ - å³å­æ ‘é«˜åº¦
    return height(node->left) - height(node->right);
}
```

##### æ—‹è½¬ï¼ˆå½“AVLæ ‘ä¸­æŸä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­ç»å¯¹å€¼ > 1æ—¶ï¼Œæ ‘å¤±å»å¹³è¡¡ï¼Œéœ€è¦é€šè¿‡æ—‹è½¬æ“ä½œæ¢å¤å¹³è¡¡ã€‚ï¼‰åªéœ€ç”»å›¾ç„¶ååˆ¤æ–­éœ€è¦æ”¹å˜å“ªä¸ªæŒ‡é’ˆçš„æŒ‡å‘æ–¹å‘å³å¯
æ³¨æ„ï¼š
- å³æ—‹æ—¶ï¼š`grandChild`Â æˆä¸ºåŸæ ¹èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹
- å·¦æ—‹æ—¶ï¼š`grandChild`Â æˆä¸ºåŸæ ¹èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹
**å³æ—‹ï¼ˆå½“èŠ‚ç‚¹**å·¦å­æ ‘æ¯”å³å­æ ‘é«˜2ä¸ªå±‚çº§**æ—¶ï¼ˆå¹³è¡¡å› å­ = 2ï¼‰ï¼‰**
```cpp
    node (å¹³è¡¡å› å­=2)
   /
child (å¹³è¡¡å› å­=1)
  \
 grandChild
```
```cpp
TreeNode *rightRotate(TreeNode *node) {
    // æ­¥éª¤1ï¼šè®°å½•ç›¸å…³èŠ‚ç‚¹
    TreeNode *child = node->left;        // å·¦å­èŠ‚ç‚¹å°†æˆä¸ºæ–°çš„æ ¹
    TreeNode *grandChild = child->right; // å·¦å­èŠ‚ç‚¹çš„å³å­æ ‘
    
    // æ­¥éª¤2ï¼šæ‰§è¡Œæ—‹è½¬
    child->right = node;     // åŸå·¦å­èŠ‚ç‚¹ç°åœ¨æŒ‡å‘åŸæ ¹èŠ‚ç‚¹
    node->left = grandChild; // åŸæ ¹èŠ‚ç‚¹çš„å·¦æŒ‡é’ˆæŒ‡å‘åŸå·¦å­èŠ‚ç‚¹çš„å³å­æ ‘
    
    // æ­¥éª¤3ï¼šæ›´æ–°é«˜åº¦ï¼ˆå…ˆæ›´æ–°è¾ƒä½èŠ‚ç‚¹ï¼Œå†æ›´æ–°è¾ƒé«˜èŠ‚ç‚¹ï¼‰
    updateHeight(node);
    updateHeight(child);
    
    // æ­¥éª¤4ï¼šè¿”å›æ–°çš„æ ¹èŠ‚ç‚¹
    return child;
}
```
**å·¦æ—‹åŒç†**
```cpp
TreeNode *leftRotate(TreeNode *node) {
    // æ­¥éª¤1ï¼šè®°å½•ç›¸å…³èŠ‚ç‚¹
    TreeNode *child = node->right;       // å³å­èŠ‚ç‚¹å°†æˆä¸ºæ–°çš„æ ¹
    TreeNode *grandChild = child->left;  // å³å­èŠ‚ç‚¹çš„å·¦å­æ ‘
    
    // æ­¥éª¤2ï¼šæ‰§è¡Œæ—‹è½¬
    child->left = node;      // åŸå³å­èŠ‚ç‚¹ç°åœ¨æŒ‡å‘åŸæ ¹èŠ‚ç‚¹
    node->right = grandChild; // åŸæ ¹èŠ‚ç‚¹çš„å³æŒ‡é’ˆæŒ‡å‘åŸå³å­èŠ‚ç‚¹çš„å·¦å­æ ‘
    
    // æ­¥éª¤3ï¼šæ›´æ–°é«˜åº¦
    updateHeight(node);
    updateHeight(child);
    
    // æ­¥éª¤4ï¼šè¿”å›æ–°çš„æ ¹èŠ‚ç‚¹
    return child;
}
```
##### æ’å…¥
```cpp
void insert(int val) {
    root = insertHelper(root, val);
}

/* é€’å½’æ’å…¥èŠ‚ç‚¹ï¼ˆè¾…åŠ©æ–¹æ³•ï¼‰ */
TreeNode *insertHelper(TreeNode *node, int val) {
    if (node == nullptr)
        return new TreeNode(val);// åˆ›å»ºæ–°èŠ‚ç‚¹ä½œä¸ºå­æ ‘æ ¹èŠ‚ç‚¹
    
    /* 1. æŸ¥æ‰¾æ’å…¥ä½ç½®å¹¶æ’å…¥èŠ‚ç‚¹ */
    if (val < node->val)
        node->left = insertHelper(node->left, val);
    else if (val > node->val)
        node->right = insertHelper(node->right, val);
    else
        return node; // é‡å¤èŠ‚ç‚¹ä¸æ’å…¥ï¼Œç›´æ¥è¿”å›
    
    updateHeight(node); // æ›´æ–°èŠ‚ç‚¹é«˜åº¦
    
    /* 2. æ‰§è¡Œæ—‹è½¬æ“ä½œï¼Œä½¿è¯¥å­æ ‘é‡æ–°æ¢å¤å¹³è¡¡ */
    node = rotate(node);
    
    // è¿”å›å­æ ‘çš„æ ¹èŠ‚ç‚¹
    return node;
}
```
##### åˆ é™¤
```cpp
void remove(int val) {
    root = removeHelper(root, val);
}

/* é€’å½’åˆ é™¤èŠ‚ç‚¹ï¼ˆè¾…åŠ©æ–¹æ³•ï¼‰ */
TreeNode *removeHelper(TreeNode *node, int val) {
    if (node == nullptr)
        return nullptr;
    
    /* 1. æŸ¥æ‰¾èŠ‚ç‚¹å¹¶åˆ é™¤ */
    if (val < node->val)
        node->left = removeHelper(node->left, val);
    else if (val > node->val)
        node->right = removeHelper(node->right, val);
    else {
        if (node->left == nullptr || node->right == nullptr) {
            TreeNode *child = node->left != nullptr ? node->left : node->right;
            // å­èŠ‚ç‚¹æ•°é‡ = 0 , ç›´æ¥åˆ é™¤ node å¹¶è¿”å›
            if (child == nullptr) {
                delete node;
                return nullptr;
            }
            // å­èŠ‚ç‚¹æ•°é‡ = 1 , ç›´æ¥åˆ é™¤ node
            else {
                delete node;
                node = child;
            }
        } else {
            // å­èŠ‚ç‚¹æ•°é‡ = 2ï¼Œåˆ™å°†ä¸­åºéå†çš„ä¸‹ä¸ªèŠ‚ç‚¹åˆ é™¤ï¼Œå¹¶ç”¨è¯¥èŠ‚ç‚¹æ›¿æ¢å½“å‰èŠ‚ç‚¹
            TreeNode *temp = node->right;
            while (temp->left != nullptr) {
                temp = temp->left;
            }
            int tempVal = temp->val;
            node->right = removeHelper(node->right, tempVal);
            node->val = tempVal;
        }
    }
    
    updateHeight(node); // æ›´æ–°èŠ‚ç‚¹é«˜åº¦
    /* 2. æ‰§è¡Œæ—‹è½¬æ“ä½œï¼Œä½¿è¯¥å­æ ‘é‡æ–°æ¢å¤å¹³è¡¡ */
    node = rotate(node);
    // è¿”å›å­æ ‘çš„æ ¹èŠ‚ç‚¹
    return node;
}
```
##### leetcode 98.Validate Binary Search Tree
Given theÂ `root`Â of a binary tree,Â _determine if it is a valid binary search tree (BST)_.
AÂ **valid BST**Â is defined as follows:
- The leftÂ subtreeÂ of a node contains only nodes with keysÂ **strictly less than**Â the node's key.
- The right subtree of a node contains only nodes with keysÂ **strictly greater than**Â the node's key.
- Both the left and right subtrees must also be binary search trees.

##### leetcode 1382. Balance a Binary Search Tree(å°†äºŒå‰æœç´¢æ ‘å˜å¹³è¡¡)
Given theÂ `root`Â of a binary search tree, returnÂ _aÂ **balanced**Â binary search tree with the same node values_. If there is more than one answer, returnÂ **any of them**.
A binary search tree isÂ **balanced**Â if the depth of the two subtrees of every node never differs by more thanÂ `1`.
```cpp
class Solution {
private:
    vector<int> vec;
    // æœ‰åºæ ‘è½¬æˆæœ‰åºæ•°ç»„
    void traversal(TreeNode* cur) {
        if (cur == nullptr) {
            return;
        }
        traversal(cur->left);
        vec.push_back(cur->val);
        traversal(cur->right);
    }
    // æœ‰åºæ•°ç»„è½¬å¹³è¡¡äºŒå‰æ ‘
    TreeNode* getTree(vector<int>& nums, int left, int right) {
        if (left > right) return nullptr;
        int mid = left + ((right - left) / 2);
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = getTree(nums, left, mid - 1);
        root->right = getTree(nums, mid + 1, right);
        return root;
    }

public:
    TreeNode* balanceBST(TreeNode* root) {
        traversal(root);
        return getTree(vec, 0, vec.size() - 1);
    }
};
```
**AVL æ ‘çš„æ ¸å¿ƒæ€æƒ³æ˜¯ä¿æŒå¹³è¡¡å› å­ (Balance Factor) åœ¨ [-1, 0, 1] ä¹‹é—´ã€‚è¯·é—®ï¼Œå½“ä½ åœ¨ AVL æ ‘ä¸­æ’å…¥ä¸€ä¸ªæ–°èŠ‚ç‚¹å¯¼è‡´å¤±è¡¡æ—¶ï¼Œæœ€åæƒ…å†µä¸‹ä½ éœ€è¦è¿›è¡Œå¤šå°‘æ¬¡å•æ—‹è½¬ (Single Rotation) æ¥æ¢å¤å¹³è¡¡ï¼Ÿ**
åœ¨ AVL æ ‘ä¸­æ’å…¥æ–°èŠ‚ç‚¹å¯¼è‡´å¤±è¡¡æ—¶ï¼Œæœ€åæƒ…å†µä¸‹éœ€è¦è¿›è¡ŒåŒæ—‹è½¬ï¼ˆDouble Rotationï¼‰æ¥æ¢å¤å¹³è¡¡ã€‚åŒæ—‹è½¬ç”±ä¸¤æ¬¡å•æ—‹è½¬ï¼ˆSingle Rotationï¼‰ç»„æˆï¼Œä¾‹å¦‚å…ˆå·¦æ—‹åå³æ—‹æˆ–å…ˆå³æ—‹åå·¦æ—‹ã€‚å› æ­¤ï¼Œæœ€åæƒ…å†µä¸‹éœ€è¦è¿›è¡Œçš„å•æ—‹è½¬æ¬¡æ•°ä¸º 2 æ¬¡ã€‚
è¿™æ˜¯å› ä¸ºåœ¨ AVL æ ‘æ’å…¥æ“ä½œä¸­ï¼Œä»æ’å…¥ç‚¹å‘ä¸Šéå†æ£€æŸ¥å¹³è¡¡å› å­æ—¶ï¼Œä¸€æ—¦å‘ç°æŸä¸ªèŠ‚ç‚¹å¤±è¡¡ï¼Œé€šè¿‡ä¸€æ¬¡æ—‹è½¬æ“ä½œï¼ˆå•æ—‹è½¬æˆ–åŒæ—‹è½¬ï¼‰å³å¯æ¢å¤è¯¥èŠ‚ç‚¹çš„å¹³è¡¡ï¼Œå¹¶ä¸”æ—‹è½¬åå­æ ‘çš„é«˜åº¦ä¸æ’å…¥å‰ç›¸åŒï¼Œä»è€Œä¸ä¼šå½±å“ç¥–å…ˆèŠ‚ç‚¹çš„å¹³è¡¡ã€‚å› æ­¤ï¼Œä¸€æ¬¡æ’å…¥æœ€å¤šåªéœ€è¦ä¸€æ¬¡æ—‹è½¬æ“ä½œï¼Œä½†åŒæ—‹è½¬æ¶‰åŠä¸¤æ¬¡å•æ—‹è½¬ã€‚
æ•…æœ€åæƒ…å†µä¸‹ï¼Œå•æ—‹è½¬çš„æ¬¡æ•°ä¸º 2ã€‚
## 6 å¹¶æŸ¥é›†ï¼ˆå­˜ç–‘ï¼‰
##### å®šä¹‰
å¹¶æŸ¥é›†ç®¡ç†ä¸ç›¸äº¤é›†åˆï¼Œæ”¯æŒåˆå¹¶å’ŒæŸ¥è¯¢ã€‚å†…éƒ¨ä¸ºæ£®æ—ï¼Œæ¯æ ‘ä¸€é›†åˆã€‚
![[Pasted image 20251112172301.png]]
##### æ“ä½œ
- **åˆå§‹åŒ–**ï¼šæ¯ä¸ªå…ƒç´ è‡ªæˆé›†åˆã€‚
- **æŸ¥è¯¢ï¼ˆFindï¼‰**ï¼šæ‰¾æ ¹ï¼Œåˆ¤æ–­åŒé›†åˆã€‚
- **åˆå¹¶ï¼ˆUnionï¼‰**ï¼šè¿æ¥ä¸¤æ ¹ã€‚
##### ä¼˜åŒ–
- è·¯å¾„å‹ç¼©ï¼šæŸ¥è¯¢æ—¶æ‰å¹³æ ‘ã€‚
- æŒ‰ç§©/å¤§å°åˆå¹¶ï¼šå°æ ‘å¹¶å¤§æ ‘ã€‚
##### æ—¶é—´å¤æ‚åº¦
- è¿‘ä¼¼O(1)ï¼ˆÎ±(n)ï¼Œæå°å¸¸æ•°ï¼‰ã€‚
##### åŸºæœ¬ä»£ç å—ï¼š
```cpp
class UnionFind {
private:
    vector<int> parent;  // è®°å½•æ¯ä¸ªå…ƒç´ çš„çˆ¶èŠ‚ç‚¹
    
public:
    //åˆå§‹åŒ–ï¼šæ¯ä¸ªäººéƒ½æ˜¯è‡ªå·±çš„ç»„é•¿
    //å¼€å§‹æ—¶æ¯ä¸ªå…ƒç´ è‡ªæˆä¸€ä¸ªé›†åˆï¼Œæ‰€ä»¥çˆ¶èŠ‚ç‚¹æŒ‡å‘è‡ªå·±
    int parent[MAXN];
    void Initial(int n){
	    for(int i = 0; i < n; i++){
		    parent[i] = i;
	    }
	}
    // Findï¼šæŸ¥è¯¢å…ƒç´ xå±äºå“ªä¸ªé›†åˆï¼ˆæ‰¾æ ¹èŠ‚ç‚¹ï¼‰ï¼ˆé€’å½’ï¼‰
    int find(int x) {
        if(parent[x] != x) 
            parent[x] = find(parent[x]);  // è·¯å¾„å‹ç¼© å…³é”®ï¼šé€’å½’+èµ‹å€¼
        return parent[x];
    }
    // Unionï¼šåˆå¹¶ä¸¤ä¸ªå…ƒç´ æ‰€å±çš„é›†åˆ
    void unionSets(int x, int y) {//ä¸»å‡½æ•°
        int rootX = find(x);// å¸¦è·¯å¾„å‹ç¼©çš„æŸ¥æ‰¾
        int rootY = find(y);
        if(rootX != rootY) 
            parent[rootY] = rootX;  // è®©ä¸€ä¸ªè€å¤§è®¤å¦ä¸€ä¸ªè€å¤§å½“è€å¤§
    }
};
```
**å¹¶æŸ¥é›†åˆå§‹åŒ–å›¾è§£**
åˆå§‹çŠ¶æ€å›¾è§£
åœºæ™¯ï¼šæœ‰5ä¸ªäººï¼Œç¼–å·0-4
```
åˆå§‹çŠ¶æ€ï¼š
äººç‰©: 0   1   2   3   4
çˆ¶èŠ‚ç‚¹: 0   1   2   3   4
```
**è§†è§‰åŒ–è¡¨ç¤º**ï¼š
```
(0)   (1)   (2)   (3)   (4)
 â†‘     â†‘     â†‘     â†‘     â†‘
è‡ªæŒ‡  è‡ªæŒ‡  è‡ªæŒ‡  è‡ªæŒ‡  è‡ªæŒ‡
```

**å«ä¹‰**ï¼šæ¯ä¸ªäººéƒ½æ˜¯è‡ªå·±çš„"ç»„é•¿"ï¼Œå½¢æˆ5ä¸ªç‹¬ç«‹çš„ç»„ã€‚
å¦‚æœåˆå§‹åŒ–ä¸ºå…¶ä»–å€¼ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
é”™è¯¯æƒ…å†µ1ï¼šå…¨éƒ¨è®¾ä¸º0
```
äººç‰©: 0   1   2   3   4
çˆ¶èŠ‚ç‚¹: 0   0   0   0   0
```
**è§†è§‰åŒ–**ï¼š
```
(0) â† (1) â† (2) â† (3) â† (4)
 â†‘
è‡ªæŒ‡
```
**é—®é¢˜**ï¼šæ‰€æœ‰äººéƒ½å±äºç»„0ï¼Œä½†å®é™…ä¸Šä»–ä»¬åº”è¯¥æ˜¯5ä¸ªç‹¬ç«‹çš„ç»„ï¼
é”™è¯¯æƒ…å†µ2ï¼šå…¨éƒ¨è®¾ä¸º-1
```
äººç‰©: 0   1   2   3   4  
çˆ¶èŠ‚ç‚¹: -1  -1  -1  -1  -1
```
**é—®é¢˜**ï¼š`find`å‡½æ•°æ— æ³•å·¥ä½œï¼
```cpp
int find(int x) {
    if(parent[x] != x)  // è¿™é‡Œparent[x] = -1, x = 0, -1 â‰  0
        parent[x] = find(parent[x]);  // è°ƒç”¨find(-1) â†’ æ•°ç»„è¶Šç•Œï¼
    return parent[x];
}
```
æ­£ç¡®çš„æ“ä½œæµç¨‹å›¾è§£
æ­¥éª¤1ï¼šåˆå§‹çŠ¶æ€ï¼ˆ5ä¸ªç‹¬ç«‹ç»„ï¼‰
```
ç»„0: (0)  ç»„1: (1)  ç»„2: (2)  ç»„3: (3)  ç»„4: (4)
     â†‘         â†‘         â†‘         â†‘         â†‘
    è‡ªæŒ‡      è‡ªæŒ‡      è‡ªæŒ‡      è‡ªæŒ‡      è‡ªæŒ‡
```
æ­¥éª¤2ï¼šåˆå¹¶0å’Œ1ï¼ˆunion(0,1)ï¼‰
```cpp
find(0) = 0  // 0çš„ç»„é•¿æ˜¯0
find(1) = 1  // 1çš„ç»„é•¿æ˜¯1
parent[1] = 0  // è®©1çš„ç»„é•¿è®¤0çš„ç»„é•¿å½“ç»„é•¿
```
**ç»“æœ**ï¼š
```
ç»„0: (0) â† (1)  ç»„2: (2)  ç»„3: (3)  ç»„4: (4)
     â†‘     â†‘         â†‘         â†‘         â†‘
    è‡ªæŒ‡  æŒ‡å‘0     è‡ªæŒ‡      è‡ªæŒ‡      è‡ªæŒ‡
```
æ­¥éª¤3ï¼šåˆå¹¶2å’Œ3ï¼ˆunion(2,3)ï¼‰
```cpp
find(2) = 2
find(3) = 3  
parent[3] = 2
```
**ç»“æœ**ï¼š
```
ç»„0: (0) â† (1)  ç»„2: (2) â† (3)  ç»„4: (4)
     â†‘     â†‘         â†‘     â†‘         â†‘
    è‡ªæŒ‡  æŒ‡å‘0     è‡ªæŒ‡  æŒ‡å‘2     è‡ªæŒ‡
```
æ­¥éª¤4ï¼šåˆå¹¶1å’Œ3ï¼ˆunion(1,3)ï¼‰
```cpp
find(1) = find(0) = 0  // 1â†’0â†’0
find(3) = find(2) = 2  // 3â†’2â†’2
parent[2] = 0  // è®©ç»„2çš„ç»„é•¿è®¤ç»„0çš„ç»„é•¿å½“ç»„é•¿
```
**ç»“æœ**ï¼š
```
ç»„0: (0) â† (1)   (2) â† (3)  ç»„4: (4)
     â†‘     â†‘      â†‘     â†‘         â†‘
    è‡ªæŒ‡  æŒ‡å‘0  æŒ‡å‘0 æŒ‡å‘2     è‡ªæŒ‡
```
æ­¥éª¤5ï¼šæŸ¥æ‰¾æ—¶çš„è·¯å¾„å‹ç¼©ï¼ˆfind(3)ï¼‰
```cpp
find(3):
- 3 â†’ 2 â†’ 0
- å›æº¯æ—¶ï¼šparent[2] = 0, parent[3] = 0
```
**å‹ç¼©åç»“æœ**ï¼š
```
ç»„0: (0) â† (1)   (2)   (3)  ç»„4: (4)
     â†‘     â†‘      â†‘     â†‘         â†‘
    è‡ªæŒ‡  æŒ‡å‘0  æŒ‡å‘0 æŒ‡å‘0     è‡ªæŒ‡
```
 ä¸ºä»€ä¹ˆè‡ªæŒ‡è®¾è®¡å¦‚æ­¤é‡è¦ï¼Ÿ
1. è¯†åˆ«æ ¹èŠ‚ç‚¹ï¼ˆç»„é•¿çš„æ ‡è¯†ï¼‰
```cpp
// åˆ¤æ–­xæ˜¯å¦æ˜¯æ ¹èŠ‚ç‚¹çš„å”¯ä¸€æ–¹æ³•ï¼š
if (parent[x] == x) {
    // xæ˜¯æ ¹èŠ‚ç‚¹ï¼ˆç»„é•¿ï¼‰
} else {
    // xä¸æ˜¯æ ¹èŠ‚ç‚¹ï¼Œéœ€è¦ç»§ç»­å‘ä¸Šæ‰¾
}
```
 2. é€’å½’ç»ˆæ­¢æ¡ä»¶
```cpp
int find(int x) {
    if (parent[x] != x)          // å¦‚æœä¸æ˜¯æ ¹èŠ‚ç‚¹
        parent[x] = find(parent[x]);  // ç»§ç»­å‘ä¸Šæ‰¾
    return parent[x];             // è¿”å›æ ¹èŠ‚ç‚¹
}
```
**é€’å½’è¿‡ç¨‹ç¤ºä¾‹**ï¼ˆfind(3)ï¼‰ï¼š
```
find(3)
â”œâ”€â”€ parent[3] = 2 â‰  3 â†’ find(2)
â”‚   â”œâ”€â”€ parent[2] = 0 â‰  2 â†’ find(0)
â”‚   â”‚   â””â”€â”€ parent[0] = 0 â†’ è¿”å›0
â”‚   â””â”€â”€ parent[2] = 0, è¿”å›0
â””â”€â”€ parent[3] = 0, è¿”å›0
```
![[Pasted image 20251112180512.png]]
![[Pasted image 20251112181013.png]]
åŠ›æ‰£128. æœ€é•¿è¿ç»­åºåˆ—
**ç»™å®šä¸€ä¸ªæœªæ’åºçš„æ•´æ•°æ•°ç»„Â `nums`Â ï¼Œæ‰¾å‡ºæ•°å­—è¿ç»­çš„æœ€é•¿åºåˆ—ï¼ˆä¸è¦æ±‚åºåˆ—å…ƒç´ åœ¨åŸæ•°ç»„ä¸­è¿ç»­ï¼‰çš„é•¿åº¦ã€‚
è¯·ä½ è®¾è®¡å¹¶å®ç°æ—¶é—´å¤æ‚åº¦ä¸ºÂ `O(n)`Â çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚**
**ç¤ºä¾‹ 1ï¼š**
**è¾“å…¥ï¼š**nums = [100,4,200,1,3,2]
**è¾“å‡ºï¼š**4
**è§£é‡Šï¼š**æœ€é•¿æ•°å­—è¿ç»­åºåˆ—æ˜¯ [1, 2, 3, 4]ã€‚å®ƒçš„é•¿åº¦ä¸º 4ã€‚
![[deepseek_mermaid_20251110_dffe02.png]]
```cpp
class Solution {
public:
    // ä¸¤ä¸ªå“ˆå¸Œè¡¨ï¼š
    // uf: å­˜å‚¨èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼ˆç”¨äºå¹¶æŸ¥é›†ï¼‰
    // cnt: å­˜å‚¨æ¯ä¸ªè¿é€šåˆ†é‡çš„å…ƒç´ ä¸ªæ•°
    unordered_map<int,int> uf, cnt;

    // æŸ¥æ‰¾æ“ä½œï¼šæ‰¾åˆ°içš„æ ¹èŠ‚ç‚¹ï¼Œå¹¶è¿›è¡Œè·¯å¾„å‹ç¼©
    int find(int i){
        return i == uf[i] ? i : uf[i] = find(uf[i]);
        // å¦‚æœiå°±æ˜¯æ ¹èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›
        // å¦åˆ™é€’å½’æŸ¥æ‰¾ï¼Œå¹¶è¿›è¡Œè·¯å¾„å‹ç¼©
    }

    // åˆå¹¶æ“ä½œï¼šå°†xå’Œyæ‰€åœ¨çš„é›†åˆåˆå¹¶
    int merge(int x, int y){
        x = find(x); // æ‰¾åˆ°xçš„æ ¹
        y = find(y); // æ‰¾åˆ°yçš„æ ¹
        
        if(x == y) return cnt[x]; // å¦‚æœå·²ç»åœ¨åŒä¸€é›†åˆï¼Œç›´æ¥è¿”å›è¯¥é›†åˆå¤§å°
        
        uf[y] = x; // å°†yçš„æ ¹æŒ‡å‘xçš„æ ¹ï¼ˆåˆå¹¶ï¼‰
        cnt[x] += cnt[y]; // æ›´æ–°åˆå¹¶åçš„é›†åˆå¤§å°
        
        return cnt[x]; // è¿”å›åˆå¹¶åçš„é›†åˆå¤§å°
    }

    int longestConsecutive(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        
        // åˆå§‹åŒ–ï¼šæ¯ä¸ªå…ƒç´ è‡ªæˆä¸€ç»„
        for(int i: nums) {
            uf[i] = i;    // æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹æ˜¯è‡ªå·±
            cnt[i] = 1;    // æ¯ä¸ªé›†åˆåˆå§‹å¤§å°ä¸º1
        }
        
        int ans = 1;
        // éå†æ¯ä¸ªæ•°å­—ï¼Œå°è¯•ä¸å®ƒçš„ä¸‹ä¸€ä¸ªæ•°å­—(i+1)åˆå¹¶
        for(int i: nums){
            // æ£€æŸ¥i+1æ˜¯å¦å­˜åœ¨ï¼Œä¸”é¿å…æ•´æ•°æº¢å‡º
            if(i != INT_MAX && uf.count(i+1)) {
                ans = max(ans, merge(i, i+1));
            }
        }
        return ans;
    }
};
```
## 7 å †ï¼ˆHeapï¼‰

##### åŸºæœ¬æ¦‚å¿µ
å †æ˜¯ä¸€ç§æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„å®Œå…¨äºŒå‰æ ‘ï¼Œä¸»è¦åˆ†ä¸ºä¸¤ç§ç±»å‹ï¼š
- **å°é¡¶å † (min heap)**ï¼šä»»æ„èŠ‚ç‚¹çš„å€¼ â‰¤ å…¶å­èŠ‚ç‚¹çš„å€¼
- **å¤§é¡¶å † (max heap)**ï¼šä»»æ„èŠ‚ç‚¹çš„å€¼ â‰¥ å…¶å­èŠ‚ç‚¹çš„å€¼
å †çš„ç‰¹æ€§ï¼š
- æœ€åº•å±‚èŠ‚ç‚¹é å·¦å¡«å……ï¼Œå…¶ä»–å±‚çš„èŠ‚ç‚¹éƒ½è¢«å¡«æ»¡
- æ ¹èŠ‚ç‚¹ç§°ä¸º"å †é¡¶"ï¼Œåº•å±‚æœ€é å³çš„èŠ‚ç‚¹ç§°ä¸º"å †åº•"
- å¯¹äºå¤§é¡¶å †ï¼Œå †é¡¶å…ƒç´ çš„å€¼æ˜¯æœ€å¤§çš„ï¼›å¯¹äºå°é¡¶å †ï¼Œå †é¡¶å…ƒç´ çš„å€¼æ˜¯æœ€å°çš„
##### å †çš„å¸¸ç”¨æ“ä½œ
å †é€šå¸¸ç”¨äºå®ç°ä¼˜å…ˆé˜Ÿåˆ—ï¼Œå¸¸ç”¨æ“ä½œåŠæ—¶é—´å¤æ‚åº¦ï¼š

| æ“ä½œ | æè¿° | æ—¶é—´å¤æ‚åº¦ |
|------|------|------------|
| `push()` | å…ƒç´ å…¥å † | O(log n) |
| `pop()` | å †é¡¶å…ƒç´ å‡ºå † | O(log n) |
| `peek()` | è®¿é—®å †é¡¶å…ƒç´  | O(1) |
| `size()` | è·å–å †çš„å…ƒç´ æ•°é‡ | O(1) |
| `isEmpty()` | åˆ¤æ–­å †æ˜¯å¦ä¸ºç©º | O(1) |

##### å †çš„ä½¿ç”¨

```cpp
/* åˆå§‹åŒ–å † */
// åˆå§‹åŒ–å°é¡¶å †
priority_queue<int, vector<int>, greater<int>> minHeap;
// åˆå§‹åŒ–å¤§é¡¶å †
priority_queue<int, vector<int>, less<int>> maxHeap;

/* å…ƒç´ å…¥å † */
maxHeap.push(1);
maxHeap.push(3);
maxHeap.push(2);
maxHeap.push(5);
maxHeap.push(4);

/* è·å–å †é¡¶å…ƒç´  */
int peek = maxHeap.top(); // 5

/* å †é¡¶å…ƒç´ å‡ºå † */
// å‡ºå †å…ƒç´ ä¼šå½¢æˆä¸€ä¸ªä»å¤§åˆ°å°çš„åºåˆ—
maxHeap.pop(); // 5
maxHeap.pop(); // 4
maxHeap.pop(); // 3
maxHeap.pop(); // 2
maxHeap.pop(); // 1

/* è·å–å †å¤§å° */
int size = maxHeap.size();

/* åˆ¤æ–­å †æ˜¯å¦ä¸ºç©º */
bool isEmpty = maxHeap.empty();

/* è¾“å…¥åˆ—è¡¨å¹¶å»ºå † */
vector<int> input = {1, 3, 2, 5, 4};
priority_queue<int, vector<int>, greater<int>> minHeap(input.begin(), input.end());
```
##### å †çš„å®ç°ï¼ˆå¤§é¡¶å †ï¼‰
å †çš„å­˜å‚¨ä¸è¡¨ç¤º

```cpp
class MaxHeap {
private:
    vector<int> maxHeap;
    
    /* è·å–å·¦å­èŠ‚ç‚¹çš„ç´¢å¼• */
    int left(int i) {
        return 2 * i + 1;
    }
    
    /* è·å–å³å­èŠ‚ç‚¹çš„ç´¢å¼• */
    int right(int i) {
        return 2 * i + 2;
    }
    
    /* è·å–çˆ¶èŠ‚ç‚¹çš„ç´¢å¼• */
    int parent(int i) {
        return (i - 1) / 2; // å‘ä¸‹æ•´é™¤
    }
```
è®¿é—®å †é¡¶å…ƒç´ 
```cpp
    int peek() {
        return maxHeap[0];
    }
```
å…ƒç´ å…¥å †
```cpp
    void push(int val) {
        // æ·»åŠ èŠ‚ç‚¹
        maxHeap.push_back(val);
        // ä»åº•è‡³é¡¶å †åŒ–
        siftUp(size() - 1);
    }
    
    /* ä»èŠ‚ç‚¹ i å¼€å§‹ï¼Œä»åº•è‡³é¡¶å †åŒ– */
    void siftUp(int i) {
        while (true) {
            // è·å–èŠ‚ç‚¹ i çš„çˆ¶èŠ‚ç‚¹
            int p = parent(i);
            // å½“"è¶Šè¿‡æ ¹èŠ‚ç‚¹"æˆ–"èŠ‚ç‚¹æ— é¡»ä¿®å¤"æ—¶ï¼Œç»“æŸå †åŒ–
            if (p < 0 || maxHeap[i] <= maxHeap[p])
                break;
            // äº¤æ¢ä¸¤èŠ‚ç‚¹
            swap(maxHeap[i], maxHeap[p]);
            // å¾ªç¯å‘ä¸Šå †åŒ–
            i = p;
        }
    }
```
å †é¡¶å…ƒç´ å‡ºå †
```cpp
    void pop() {
        // åˆ¤ç©ºå¤„ç†
        if (isEmpty()) {
            throw out_of_range("å †ä¸ºç©º");
        }
        // äº¤æ¢æ ¹èŠ‚ç‚¹ä¸æœ€å³å¶èŠ‚ç‚¹ï¼ˆäº¤æ¢é¦–å…ƒç´ ä¸å°¾å…ƒç´ ï¼‰
        swap(maxHeap[0], maxHeap[size() - 1]);
        // åˆ é™¤èŠ‚ç‚¹
        maxHeap.pop_back();
        // ä»é¡¶è‡³åº•å †åŒ–
        siftDown(0);
    }
    
    /* ä»èŠ‚ç‚¹ i å¼€å§‹ï¼Œä»é¡¶è‡³åº•å †åŒ– */
    void siftDown(int i) {
        while (true) {
            // åˆ¤æ–­èŠ‚ç‚¹ i, l, r ä¸­å€¼æœ€å¤§çš„èŠ‚ç‚¹ï¼Œè®°ä¸º ma
            int l = left(i), r = right(i), ma = i;
            if (l < size() && maxHeap[l] > maxHeap[ma])
                ma = l;
            if (r < size() && maxHeap[r] > maxHeap[ma])
                ma = r;
            // è‹¥èŠ‚ç‚¹ i æœ€å¤§æˆ–ç´¢å¼• l, r è¶Šç•Œï¼Œåˆ™æ— é¡»ç»§ç»­å †åŒ–ï¼Œè·³å‡º
            if (ma == i)
                break;
            swap(maxHeap[i], maxHeap[ma]);
            // å¾ªç¯å‘ä¸‹å †åŒ–
            i = ma;
        }
    }
```
é«˜æ•ˆå»ºå †æ–¹æ³•
```cpp
    /* æ„é€ æ–¹æ³•ï¼Œæ ¹æ®è¾“å…¥åˆ—è¡¨å»ºå † */
    MaxHeap(vector<int> nums) {
        // å°†åˆ—è¡¨å…ƒç´ åŸå°ä¸åŠ¨æ·»åŠ è¿›å †
        maxHeap = nums;
        // å †åŒ–é™¤å¶èŠ‚ç‚¹ä»¥å¤–çš„å…¶ä»–æ‰€æœ‰èŠ‚ç‚¹
        for (int i = parent(size() - 1); i >= 0; i--) {
            siftDown(i);
        }
    }
```
##### Top-k é—®é¢˜è§£å†³æ–¹æ¡ˆ
```cpp

/* åŸºäºå †æŸ¥æ‰¾æ•°ç»„ä¸­æœ€å¤§çš„ k ä¸ªå…ƒç´  */
priority_queue<int, vector<int>, greater<int>> topKHeap(vector<int> &nums, int k) {
    // åˆå§‹åŒ–å°é¡¶å †
    priority_queue<int, vector<int>, greater<int>> heap;
    // å°†æ•°ç»„çš„å‰ k ä¸ªå…ƒç´ å…¥å †
    for (int i = 0; i < k; i++) {
        heap.push(nums[i]);
    }
    // ä»ç¬¬ k+1 ä¸ªå…ƒç´ å¼€å§‹ï¼Œä¿æŒå †çš„é•¿åº¦ä¸º k
    for (int i = k; i < nums.size(); i++) {
        // è‹¥å½“å‰å…ƒç´ å¤§äºå †é¡¶å…ƒç´ ï¼Œåˆ™å°†å †é¡¶å…ƒç´ å‡ºå †ã€å½“å‰å…ƒç´ å…¥å †
        if (nums[i] > heap.top()) {
            heap.pop();
            heap.push(nums[i]);
        }
    }
    return heap;
}
```

##### å…³é”®è¦ç‚¹
1. **å †çš„æ€§è´¨**ï¼šå®Œå…¨äºŒå‰æ ‘ï¼Œå¤§é¡¶å †/å°é¡¶å †
2. **æ—¶é—´å¤æ‚åº¦**ï¼š
   - å…¥å †/å‡ºå †ï¼šO(log n)
   - è®¿é—®å †é¡¶ï¼šO(1)
   - å»ºå †ï¼šO(n)
3. **å­˜å‚¨æ–¹å¼**ï¼šä½¿ç”¨æ•°ç»„å­˜å‚¨å®Œå…¨äºŒå‰æ ‘
4. **å †åŒ–æ“ä½œ**ï¼šä»åº•è‡³é¡¶(siftUp)å’Œä»é¡¶è‡³åº•(siftDown)
5. **Top-ké—®é¢˜**ï¼šä½¿ç”¨å°é¡¶å †ï¼Œæ—¶é—´å¤æ‚åº¦ O(n log k)
å †æ˜¯ä¼˜å…ˆé˜Ÿåˆ—çš„é«˜æ•ˆå®ç°ï¼Œåœ¨ç®—æ³•è®¾è®¡ä¸­æœ‰ç€å¹¿æ³›çš„åº”ç”¨ã€‚
## 8 å“ˆå¤«æ›¼æ ‘
##### å®šä¹‰
å“ˆå¤«æ›¼æ ‘æ˜¯å¸¦æƒè·¯å¾„é•¿åº¦ï¼ˆWPLï¼‰æœ€å°çš„äºŒå‰æ ‘ã€‚WPL = Î£(å¶æƒå€¼ Ã— æ·±åº¦)ã€‚
##### æ„é€ ç®—æ³•
1. ä»¥æƒå€¼ä½œä¸ºå¶ç»“ç‚¹ï¼Œåˆå§‹åŒ–æ£®æ—ã€‚
2. é‡å¤ï¼šé€‰æœ€å°ä¸¤æƒå€¼æ ‘åˆå¹¶ä¸ºæ–°æ ‘ï¼ˆæƒå€¼å’Œï¼‰ï¼Œç›´åˆ°å‰©ä¸€æ£µã€‚
##### æ€§è´¨
- æƒå€¼å¤§ç¦»æ ¹è¿‘ã€‚
- ç”¨äºéœå¤«æ›¼ç¼–ç ï¼šå·¦0å³1ï¼Œé¢‘ç‡é«˜ç¼–ç çŸ­ã€‚
##### æ—¶é—´å¤æ‚åº¦
- æ„é€ ï¼šO(n log n)ï¼ˆç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼‰ã€‚
##### ä»£ç å—ï¼ˆæ„å»ºå“ˆå¤«æ›¼æ ‘ï¼Œç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼‰
```cpp
struct Node {
    int weight;
    Node* left = nullptr, *right = nullptr;
    bool operator>(const Node& other) const { return weight > other.weight; }
};

Node* buildHuffman(vector<int> weights) {
    priority_queue<Node, vector<Node>, greater<Node>> pq;
    for (int w : weights) pq.push({w});
    while (pq.size() > 1) {
        Node left = pq.top(); pq.pop();
        Node right = pq.top(); pq.pop();
        Node* new_node = new Node{left.weight + right.weight, new Node(left), new Node(right)};
        pq.push(*new_node);
    }
    return new Node(pq.top());
}
```


