# 递归
## 1.全排列(**DFS** **Depth-First Search**  回溯算法)
![[Pasted image 20251107184527.png]]
```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        dfs(nums, 0);
        return res;
    }
private:
    vector<vector<int>> res;
    void dfs(vector<int> nums, int x) {
        if (x == nums.size() - 1) {
            res.push_back(nums);      // 添加排列方案
            return;
        }
        for (int i = x; i < nums.size(); i++) {
            swap(nums[i], nums[x]);   // 交换，将 nums[i] 固定在第 x 位
            dfs(nums, x + 1);         // 开启固定第 x + 1 位元素
            swap(nums[i], nums[x]);   // 恢复交换
        }

    }

};
```
![[Pasted image 20251107132859.png]]
去除重复元素：
```cpp
class Solution {
private:
    vector<vector<int>> ans;
    vector<int> path;
    vector<int> c;
    vector<bool> visited;
private:
    void dfs(int index, int cnt) {
        if (cnt == c.size()) {
            ans.push_back(path);
            return;
        }
        for (int i = 0; i < c.size(); ++i) {
            if (visited[i] == true) continue;
            if (i > 0 && c[i] == c[i - 1] && visited[i - 1] == false) continue;
            path.push_back(c[i]);
            visited[i] = true;
            dfs(i + 1, cnt + 1);
            visited[i] = false;
            path.pop_back();
        }
    }
public:
    vector<vector<int>> permuteUnique(vector<int>& c) {
        sort(c.begin(), c.end());
        vector<bool> visited(c.size(), false);
        swap(this->c, c);
        swap(this->visited, visited);
        dfs(0, 0);
        return ans;
    }
};
```
## 2.N皇后
按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。
**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。
给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。
每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。
### **问题分析：**  
n皇后问题要求在一个n×n的棋盘上放置n个皇后，使得它们互不攻击（即不在同一行、同一列、同一对角线）。
### **转化为排列问题：** 
由于每行只能放一个皇后，每列也只能放一个皇后，因此我们可以用一个长度为n的数组P来表示一个放置方案，其中P[i]表示第i列皇后所在的行号（列号从1到n，行号也从1到n）。这样，P数组是1~n的一个排列。
### **暴力法（生成所有排列并检查）：**
首先生成所有1~n的排列，然后对每个排列检查是否没有两个皇后在同一对角线上。  
检查方法：对于两个皇后(i, P[i])和(j, P[j])，如果它们在同一对角线上，则满足|i-j| = |P[i]-P[j]|。
`P[i]` = 第 i 列皇后所在的行号
例如排列 `24135` 表示：
- 第1列皇后在第2行
- 第2列皇后在第4行
- 第3列皇后在第1行
- 第4列皇后在第3行
- 第5列皇后在第5行
#### **代码框架：** 
int n; // 皇后数量  
int P[maxn]; // 保存当前排列  
bool hashTable[maxn] = {false}; // 记录哪些行已经被占用  
int count = 0; // 合法方案计数
PS：**如何判断棋子是否在对角线上？**
- 主对角线：行索引减去列索引的值相等。即，对于位置(i, j)和(k, l)，如果 i - j == k - l，则它们在同一主对角线上。
- 副对角线：行索引加上列索引的值相等。即，如果 i + j == k + l，则它们在同一副对角线上。
```cpp
int count = 0;
void generateP(int index) {
    if(index == n + 1) { // 递归边界：生成了一个完整排列
        bool flag = true;
        // 检查任意两个皇后是否在对角线上
        for(int i = 1; i <= n; i++) {
            for(int j = i + 1; j <= n; j++) {
                if(abs(i - j) == abs(P[i] - P[j])) {
                    flag = false; // 对角线冲突
                }
            }
        }
        if(flag) count++; // 合法方案
        return;
    }
    // 生成排列：第index列尝试每一行
    for(int x = 1; x <= n; x++) {
        if(hashTable[x] == false) { // 第x行还没被占用
            P[index] = x;           // 第index列皇后放在第x行
            hashTable[x] = true;    // 标记第x行已占用
            generateP(index + 1);   // 递归处理下一列
            hashTable[x] = false;   // 回溯，恢复状态
        }
    }
}
```
### 回溯法（在递归过程中提前剪枝）：  
在暴力法中，我们生成整个排列后再检查，但实际上，在放置第index个皇后（即第index列）的时候，我们可以检查当前皇后是否与前面已经放置的皇后冲突（在同一对角线）。如果冲突，则不再继续递归，直接返回。
#### 代码框架：  
void generateP(int index) {  
if (index == n+1) { // 递归边界，生成一个合法方案  
count++;  
return;  
}
```cpp
    for (int x=1; x<=n; x++) {
        if (!hashTable[x]) { // 第x行还没有皇后
            bool flag = true; // 表示当前皇后不会和之前的皇后冲突
            for (int pre=1; pre<index; pre++) {
                // 第pre列的皇后行号为P[pre]，当前放置的皇后为(index, x)
                if (abs(index - pre) == abs(x - P[pre])) {
                    flag = false;
                    break;
                }
            }
            if (flag) { // 如果不会冲突，则放置
                P[index] = x;
                hashTable[x] = true;
                generateP(index+1);
                hashTable[x] = false;
            }
        }
    }
}
```
### 灵神的解法(我太弱了看得我脑子疼)
![[Pasted image 20251107143800.png]]
#### 写法一：
```cpp
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> ans;      
        vector board(n, string(n, '.')); // 一开始棋盘是空的，没有皇后
        vector<uint8_t> col(n), diag1(n * 2 - 1), diag2(n * 2 - 1); // vector<uint8_t> 效率比 vector<bool> 高
        auto dfs = [&](this auto&& dfs, int r) {
            if (r == n) {
                ans.push_back(board); // 复制整个棋盘
                return;
            }
            // 在 (r,c) 放皇后
            for (int c = 0; c < n; c++) {
                int rc = r - c + n - 1;
                if (!col[c] && !diag1[r + c] && !diag2[rc]) { // 判断能否放皇后
                    board[r][c] = 'Q'; // 放皇后
                    col[c] = diag1[r + c] = diag2[rc] = true; // 皇后占用了 c 列和两条斜线
                    dfs(r + 1);
                    col[c] = diag1[r + c] = diag2[rc] = false; // 恢复现场
                    board[r][c] = '.';
                }
            }
        };
        dfs(0);
        return ans;
    }
};
```
#### 写法二：
```cpp
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> ans;
        vector<int> queens(n); // 皇后放在 (r,queens[r])
        vector<uint8_t> col(n), diag1(n * 2 - 1), diag2(n * 2 - 1); // vector<uint8_t> 效率比 vector<bool> 高
        auto dfs = [&](this auto&& dfs, int r) {
            if (r == n) {
                vector<string> board(n);
                for (int i = 0; i < n; i++) {
                    board[i] = string(queens[i], '.') + 'Q' + string(n - 1 - queens[i], '.');
                }
                ans.push_back(board);
                return;
            }
            // 在 (r,c) 放皇后
            for (int c = 0; c < n; c++) {
                int rc = r - c + n - 1;
                if (!col[c] && !diag1[r + c] && !diag2[rc]) { // 判断能否放皇后
                    queens[r] = c; // 直接覆盖，无需恢复现场
                    col[c] = diag1[r + c] = diag2[rc] = true; // 皇后占用了 c 列和两条斜线
                    dfs(r + 1);
                    col[c] = diag1[r + c] = diag2[rc] = false; // 恢复现场
                }
            }
        };
        dfs(0);
        return ans;
    }
};
```
### 对比：  
暴力法：生成所有排列，然后检查，计算量很大（n!）。  
回溯法：在生成排列的过程中，如果当前放置的皇后与之前冲突，则不再继续递归，从而减少了很多不必要的计算。 
### 注意：  
在回溯法中，我们只需要检查当前皇后与之前皇后的冲突，因为行和列的限制已经由排列和hashTable保证了（每行每列只有一个皇后）。
### 和全排列有什么关系？
由于每行恰好放一个皇后，记录每行的皇后放在哪一列，可以得到一个 [0,n−1] 的排列 queens。示例 1 的两个图，分别对应排列 [1,3,0,2] 和 [2,0,3,1]。所以我们本质上是在枚举列号的全排列。
（11.12）对递归还是不是很明白：
问题：**写递归时，把递归比作坐电梯。最后一行写的代码是为了还原到上一层还是处理这一层?**
**上楼：递归进行**
```cpp
void dfs(int floor) {
    if(floor > 10) return;  // 到达顶楼
    
    cout << "上到" << floor << "楼" << endl;
    dfs(floor + 1);         // 继续上楼
    // 这里开始是"下楼"的过程
}
```
**下楼：递归返回**
```cpp
void dfs(int floor) {
    if(floor > 10) return;
    
    cout << "上到" << floor << "楼" << endl;
    dfs(floor + 1);
    cout << "从" << floor + 1 << "楼下到" << floor << "楼" << endl;  // 下楼过程
}
```
**最后一行代码通常是处理"当前层"的逻辑，而不是还原到上一层。**
例子1：回溯算法中的状态还原
```cpp
void backtrack(vector<int>& path, vector<bool>& used) {
    if(满足条件) {
        记录结果;
        return;
    }
    
    for(int i = 0; i < n; i++) {
        if(!used[i]) {
            used[i] = true;        // 标记使用（当前层处理）
            path.push_back(i);     // 选择（当前层处理）
            
            backtrack(path, used); // 递归到下一层
            
            // 以下两行是"最后代码" - 还原状态（当前层处理）
            path.pop_back();       // 撤销选择
            used[i] = false;       // 取消标记
        }
    }
}
```
这里的最后两行代码是在**处理当前层的清理工作**，为返回上一层做准备。
例子2：二叉树遍历
```cpp
void inorder(TreeNode* root) {
    if(!root) return;
    
    inorder(root->left);     // 坐电梯到左子树
    cout << root->val << " "; // 最后代码：处理当前节点
    inorder(root->right);    // 坐电梯到右子树
}
```
把递归比作**探索迷宫**可能更准确：
- 进入递归：向前走一步，做标记
- 递归调用：继续探索新的路径
- 最后代码：退回一步，擦掉标记（为探索其他路径做准备）
# 贪心
## 1.简单贪心 
贪心法是一种每一步选择==局部最优==以期望达到全局最优的方法。
- **不回头**：一旦做出选择就不会改变
- **希望累积**：希望局部最优的累积能带来全局最优
### 【PAT B1020 月饼】
销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。
思路：**首先根据月饼的总价和数量计算出每一种月饼的单价，然后将月饼数组按照单价从大到小排序，根据需求量need的大小，从单价最大的月饼开始售卖，将销售掉这种月饼的价格累加到result中，最后输出result即可**
#### 代码块：(结构体)
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
struct mooncake {
    double store;   // 库存量
    double sell;    // 总售价  
    double price;   // 单价
}cake[1010];
bool cmp(mooncake a, mooncake b) {
    return a.price > b.price;  // 按单价从高到低排序
}
int main() {
    int n;
    double D;
    scanf("%d%lf", &n, &D);
    // 输入库存量
    for(int i = 0; i < n; i++) {
        scanf("%lf", &cake[i].store);
    }
    // 输入总售价并计算单价
    for(int i = 0; i < n; i++) {
        scanf("%lf", &cake[i].sell);
        cake[i].price = cake[i].sell / cake[i].store;
    }
    sort(cake, cake + n, cmp);  // 按单价排序
    double ans = 0;  // 总收益
    for(int i = 0; i < n; i++) {
        if(cake[i].store <= D) {      // 库存 <= 需求
            D -= cake[i].store;       // 减少剩余需求
            ans += cake[i].sell;      // 卖出全部库存
        } else {                      // 库存 > 需求  
            ans += cake[i].price * D; // 卖出部分库存
            break;
        }
    }
    printf("%.2f\n", ans);
    return 0;
}
```
#### 柳神的解法：
```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
struct mooncake{
    float num, price, unit;
};
int cmp(mooncake a, mooncake b) {
    return a.unit > b.unit;
}
int main() {
    int n, need;
    cin >> n >> need;
    vector<mooncake> a(n);
    for (int i = 0; i < n; i++) scanf("%f", &a[i].num);
    for (int i = 0; i < n; i++) scanf("%f", &a[i].price);
    for (int i = 0; i < n; i++) a[i].unit = a[i].price / a[i].num;
    sort(a.begin(), a.end(), cmp);
    float result = 0.0;
    for (int i = 0; i < n; i++) {
        if (a[i].num <= need) {
            result = result + a[i].price;
        } else {
            result = result + a[i].unit * need;
            break;
        }
        need = need - a[i].num;
    }
    printf("%.2f",result);
    return 0;
}
```
### 力扣122.买卖股票的最佳时机 2
给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。
在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。然而，你可以在 **同一天** 多次买卖该股票，但要确保你持有的股票不超过一股。
返回 _你能获得的 **最大** 利润_ 。
#### k神优雅的解法：
![[Pasted image 20251107155926.png]]
#### 代码块：
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int profit = 0;
        for (int i = 1; i < prices.size(); i++) {
            int tmp = prices[i] - prices[i - 1];
            if (tmp > 0) profit += tmp;
        }
        return profit;
    }
};
```
### 【PAT B1023 组个最小数】
给定数字 0-9 各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）。例如：给定两个 0，两个 1，三个 5，一个 8，我们得到的最小的数就是 10015558。
现给定数字，请编写程序输出能够组成的最小的数。
#### 思路：
1. 首先从1~9中选择一个最小的且count不为0的数字作为首位（因为不能有前导0）。  
2. 然后从0~9依次输出剩余的数字（每个数字输出次数为count[i]）。
#### 代码块：
```cpp
#include <cstdio>
int main() {
    int count[10]; // 记录数字0-9的个数
    // 输入每个数字的出现次数
    for(int i = 0; i < 10; i++) {
        scanf("%d", &count[i]);
    }
    // 找到第一个非零的最小数字作为首位（避免前导零）
    for(int i = 1; i < 10; i++) {
        if(count[i] > 0) {
            printf("%d", i);
            count[i]--;
            break; // 找到首位后中断
        }
    }
    // 按顺序输出剩余的所有数字
    for(int i = 0; i < 10; i++) {
        for(int j = 0; j < count[i]; j++) {
            printf("%d", i);
        }
    }
    return 0;
}
```
#### 柳：
```cpp
#include <iostream>
using namespace std;
int main() {
    int a[10], t;
    for (int i = 0; i < 10; i++)
        cin >> a[i];
    for (int i = 1; i < 10; i++) {
        if (a[i] != 0) {
            cout << i;
            t = i;
            break;
        }
    }
    for (int i = 0; i < a[0]; i++) cout << 0;
    for (int i = 0; i < a[t] - 1; i++) cout << t;
    for (int i = t + 1; i < 10; i++)
        for (int k = 0; k < a[i]; k++)
            cout << i;
    return 0;
}
```
# 2.区间贪心
**区间贪心**是一类基于区间选择的贪心算法问题，核心思想是：**通过某种排序规则和选择策略，从多个区间中选择最优的子集**。
==`intervals[i][0]`是第i个区间的左端点，`intervals[i][1]`是右端点。==
## 区间不相交问题
**目标**：从N个开区间中选择尽可能多的区间，使得这些区间两两没有交集。
**贪心策略**：
1. 将所有区间按**左端点从大到小**排序
2. 如果左端点相同，按**右端点从小到大**排序
3. 遍历区间，选择左端点最大的区间，且该区间与已选区间的右端点不重叠
**排序策略**
- **左端点从大到小**：优先选择左端点大的区间 
- **右端点从小到大**（左端点相同时）：避免被包含的小区间影响选择
### 代码块：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int maxn = 110;
struct Interval {
    int x, y; // 开区间左右端点
} I[maxn];
// 排序比较函数
bool cmp(Interval a, Interval b) {
    if(a.x != b.x) return a.x > b.x; // 按左端点从大到小排序
    else return a.y < b.y; // 左端点相同时按右端点从小到大排序
}
int main() {
    int n;
    while(scanf("%d", &n), n != 0) {
        for(int i = 0; i < n; i++) {
            scanf("%d%d", &I[i].x, &I[i].y);
        }//输入二维数组
        sort(I, I + n, cmp); // 区间排序
        // ans记录不相交区间个数，lastX记录上一个选中区间的左端点
        int ans = 1, lastX = I[0].x;
        for(int i = 1; i < n; i++) {
            if(I[i].y <= lastX) { // 如果该区间右端点在lastX左边（无交集）
                lastX = I[i].x; // 以I[i]作为新选中的区间
                ans++; // 不相交区间个数加1
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}
```
### 图解
```
0    1    2    3    4    5    6    7    8
     [----]   (1,3)   ← 选中
          [----]   (2,4)   ← 未选中
               [----]   (3,5)   ← 选中
                         [----]   (6,7)   ← 选中
```

```
区间: (6,7) ← 第一个选中的
        lastX=6
        ↓
区间: (3,5) ← 5≤6? ✅ 选中，更新lastX=3
        ↓  
区间: (2,4) ← 4≤3? ❌ 不选
        ↓
区间: (1,3) ← 3≤3? ✅ 选中，更新lastX=1
```
## 区间选点问题
**目标**：在N个闭区间中选择最少的点，使得每个区间都至少包含一个点。
**策略**：与区间不相交问题类似，只是判断条件稍有不同。
## 力扣56. 合并区间
以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 _一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间_ 。
**示例 ：**
**输入：**intervals = [[1,3],[2,6],[8,10],[15,18]]
**输出：**[[1,6],[8,10],[15,18]]
**解释：**区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
### 代码块：
```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end()); // 区间按左端点排序
        vector<vector<int>> ans;
        // 开始先初始化一个区间
        int start = intervals[0][0], end = intervals[0][1];
        for(int i = 1; i < intervals.size(); i++) {
            if(intervals[i][0] > end) {  
                // 如果下一个区间的左端点比前一个区间右端点还要大的话，则说明前面的区间已经无法合并了
                // 则直接将前一个区间加入ans, 并重新初始化start, end
                ans.push_back({start, end});
                start = intervals[i][0], end = intervals[i][1];
            }
            else {
                // 如果下一个区间的左端点比前一个区间的右端点小，并且后一个区间右端点比前一区间右端点大
                // 则说明可以合并，更新右端点
                if(intervals[i][1] > end) end = intervals[i][1];
            }
        }
        // 把最后一个区间加入
        ans.push_back({start, end});
        return ans;
    }
};
```
### 排序+双指针
```cpp
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end());
        vector<vector<int>> ans;
        for (int i = 0; i < intervals.size();) {
            int t = intervals[i][1];
            int j = i + 1;
            while (j < intervals.size() && intervals[j][0] <= t) {
                t = max(t, intervals[j][1]);
                j++;
            }
            ans.push_back({ intervals[i][0], t });
            i = j;
        }
        return ans;
    }
```
### leetcode2654. Minimum Number of Operations to Make All Array Elements Equal to 1]
You are given a **0-indexed** array `nums` consisiting of **positive** integers. You can do the following operation on the array **any** number of times:
- Select an index `i` such that `0 <= i < n - 1` and replace either of `nums[i]` or `nums[i+1]` with their gcd value.
Return _the **minimum** number of operations to make all elements of_ `nums` _equal to_ `1`. If it is impossible, return `-1`.
The gcd of two integers is the greatest common divisor of the two integers.
```cpp
class Solution {

public:

    int gcd(int a, int b){

    return !b ? a : gcd(b, a % b);

}

    int minOperations(vector<int>& nums) {

        int ans = -1;

        int n = nums.size();

        // 统计1的个数，并寻找可以生成1的最短区间

        int cutOne = 0;

        for(int i = 0; i < n; i++){

           int G = nums[i];

            if(G == 1) cutOne++;

            for(int j = i + 1; j < n ; j++){

                G = gcd(G, nums[j]);

                if(G == 1){

                    if(ans == -1) {ans = j - i + n - 1;}

                    else ans = min(ans, j - i + n - 1);

                    break;

                }

            }

        }

        if(cutOne) return min(ans, n - cutOne);

        return ans;

    }

  

};
```