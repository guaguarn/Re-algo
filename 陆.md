# 迭代器：
## 1.力扣：49.字母异位词分组
**给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。**
**示例 1:**
**输入:** strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
**输出:** [["bat"],["nat","tan"],["ate","eat","tea"]]
![[1 1.png]]
```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        // 创建哈希表：键是排序后的字符串，值是原始字符串的集合
        unordered_map<string, vector<string>> hash;
        
        int n = strs.size();
        for(int i = 0; i < n; i++) {
            string temp = strs[i];        // 复制当前字符串
            sort(temp.begin(), temp.end()); // 对副本进行排序
            hash[temp].push_back(strs[i]); // 以排序后的字符串为键，添加原字符串
        }
        
        vector<vector<string>> ret;       // 存储最终结果
        // 使用迭代器遍历哈希表
        for(auto it = hash.begin(); it != hash.end(); it++) {
            ret.push_back(it->second);    // 将每个分组加入结果
        }
        return ret;
    }
};
```
## 2.什么是迭代器?
```cpp
// 定义迭代器
unordered_map<string, vector<string>>::iterator it;
// 或使用auto自动推导
auto it = hash.begin();

// 基本操作
it->first;    // 访问键 (排序后的字符串)
it->second;   // 访问值 (字符串向量)
it++;         // 移动到下一个元素
it != hash.end(); // 判断是否到达末尾
```
**写法：**
```cpp
// 方法1：传统迭代器
for(auto it = hash.begin(); it != hash.end(); it++) {
    ret.push_back(it->second);
}

// 方法2：基于范围的for循环（更简洁）
for(auto& pair : hash) {
    ret.push_back(pair.second);
}

// 方法3：使用结构化绑定（C++17）
for(auto& [key, value] : hash) {
    ret.push_back(value);
}
```
## 3. 为什么这里要用迭代器？

因为我们需要遍历整个 `unordered_map`，而map不支持下标遍历：
```cpp
// 错误！map不能用数字下标遍历
for(int i = 0; i < hash.size(); i++) {
    ret.push_back(hash[i]); // 编译错误！
}
```
# 链表

**链表是一种动态数据结构，由多个**结点（node）**组成，每个结点存储数据并通过**指针（pointer）**链接到下一个结点。
链表的内存是动态分配的，不连续存储。**
## 1. 链表的基本概念
- **结点（Node）**：链表的基本单元，包含两部分：
  - **数据域（data）**：存储实际元素（如整数）。
  - **指针域（next）**：指向下一个结点的指针（类型为 `node*`，初始为 `NULL` 表示结束）。
- **指针（Pointer）**：用于链接结点或遍历链表的变量，类型为 `node*`（指向结点的指针）。笔记中常用指针如 `head`（头指针）、`pre`（前驱指针）、`p`（当前指针）。
- **链表类型**：**动态链表**（用 `new` 或 `malloc` 分配内存）和**静态链表**（用数组模拟，地址小的情况用）。
- **头结点**：一个哑结点（dummy node），不存数据，`head->next` 指向第一个真实结点。遍历时从 `head->next` 开始，避免空链表边界问题。
## 2. 如何创建结点(==data可换成val==)
创建结点就是为链表分配一个新的内存块，并初始化其内容。推荐用**动态内存分配**，因为链表长度不确定。
- **步骤**：
  1. 定义结点结构体（struct）。
  2. 使用 `new`（C++）或 `malloc`（C）分配内存。
  3. 初始化数据域和指针域（`next = NULL`）。
  4. **内存管理**：分配后必须用 `delete` 或 `free` 释放，避免内存泄漏。失败时检查 `NULL`。
- **代码示例**（定义和单结点创建）：
  ```cpp
  #include <iostream>
  using namespace std;
  // 步骤1: 定义结点结构体
  struct node {
      int data;    // 数据域（可替换为其他类型）
      node* next;  // 指针域，指向下一个结点
  };
  int main() {
      // 步骤2: 创建单个结点
      node* newNode = new node;  // C++方式：动态分配，返回 node* 类型
      // 或 C方式：node* newNode = (node*)malloc(sizeof(node)); 需要 #include <stdlib.h>
      // 步骤3: 初始化
      newNode->data = 10;  // 设置数据
      newNode->next = NULL;  // 初始指向空
      // 输出验证
      cout << "新结点数据: " << newNode->data << endl;
      // 步骤4: 释放内存（重要！）
      delete newNode;  // C++方式
      newNode = NULL;  // 置空指针，避免野指针
      return 0;
  }
  ```
  - **解释**：`new node` 在堆上分配空间，返回指向新结点的指针。笔记强调：每次创建新结点时，都用 `new` 动态分配，因为栈空间有限。
## 3. 如何创建指针
指针是变量，用于“指向”结点或链表。创建指针就是声明变量，并初始化（初始可为 `NULL`）。
- **步骤**：
  1. 声明指针变量，类型为 `node*`。
  2. 初始化：赋值为 `NULL`（空链表）或已创建的结点地址。
  3. 使用时通过 `->` 操作符访问（如 `p->data`）。
  - **常见指针**：
    - `node* head`：头指针，指向头结点。
    - `node* pre`：前驱指针，用于插入/删除时记录上一个结点。
    - `node* p` 或 `temp`：临时指针，用于遍历或临时存储新结点。
- **代码示例**（创建指针变量）：
  ```cpp
  // 在 main 或函数中
  node* head = NULL;  // 创建头指针，初始为空链表
  node* pre = head;   // 创建前驱指针，指向头
  node* temp = new node;  // 创建临时指针，指向新结点
  // 使用示例：让 head 指向新结点
  head = temp;  // 现在 head 指向这个结点
  head->next = NULL;

  // 释放
  delete temp;
  head = NULL;  // 头指针置空
  ```
  - **解释**：指针创建很简单，就是声明 `node* var;`。关键是**指针的赋值和移动**：如 `p = p->next;` 用于遍历。避免“野指针”（未初始化指针），总是先设 `NULL`。
## 4. 如何创建整个链表（结合结点和指针）
**尾插法创建链表**：从数组输入，逐个创建结点并链接。使用头结点简化。
- **步骤**：
  1. 创建头结点：`head = new node; head->next = NULL;`
  2. 用 `pre = head` 作为尾指针。
  3. 循环：为每个元素创建新结点 `temp = new node;`，设置数据，链接 `pre->next = temp; pre = temp;`
  4. 返回 `head`。
- **完整代码示例**（从数组创建链表）：
  ```cpp
  node* create(int Array[], int n) {  // n 为数组长度
      node* head = new node;  // 创建头结点
      head->next = NULL;
      node* pre = head;       // pre 作为尾指针

      for (int i = 0; i < n; i++) {
          node* temp = new node;  // 创建新结点
          temp->data = Array[i];  // 设置数据
          temp->next = NULL;      // 新结点暂无后继
          pre->next = temp;       // 链接：上一个指向新结点
          pre = temp;             // pre 移动到尾部
      }
      return head;
  }

  // 遍历输出（使用指针 p）
  void show(node* head) {
      node* p = head->next;  // p 从第一个真实结点开始
      while (p != NULL) {
          cout << p->data << " ";
          p = p->next;  // 指针移动
      }
      cout << endl;
  }

  int main() {
      int Array[5] = {5, 3, 6, 1, 2};
      node* L = create(Array, 5);  // 创建链表
      show(L);  // 输出: 5 3 6 1 2

      // 记得释放整个链表（笔记中用递归或循环 delete）
      // 示例：简单释放（实际需遍历）
      delete L;
      return 0;
  }
  ```
  - **解释**：这里 `pre` 是关键指针，确保尾插（避免头插的逆序）。笔记提醒：创建后，操作时总是从 `head->next` 开始遍历。
## 5. 其他基本操作
- **查找**：用指针 `p = head->next;` 遍历，比较 `p->data == x`，计数或返回位置。
- **插入**：找到位置前驱 `pre`，创建新结点 `q`，链接 `pre->next = q; q->next = old_next;`。
- **删除**：用 `pre` 和 `p`，若匹配则 `pre->next = p->next; delete p; p = pre->next;`（跳过结点）。
- **静态链表**：用数组模拟（如 `int data[1000]; int next[1000];`），用下标当“指针”，适合地址小的场景（如5位数）。
【重要！！！】
链表问题重点关注：

环形链表问题：利用快慢指针来解，有两种思路-① 快慢指针都从head起步，先移动指针再比较是否相遇；② 快慢指针从不同节点起步，先比较是否相遇再移动指针；

合并链表问题：利用并行指针来解，多个指针有序从前向后移动，边移动指针边比较/计算，分两种情况—①原地修改链表，只需维护新链表的指针，空间复杂度为O(1)；②生成新链表，需同时维护新链表的节点和指针，空间复杂度为O(N)；为了简化边界条件，头部都需要使用守卫节点，尾部需考虑链表长度不一致剩余节点合并的问题；

反转链表问题：支持递归和遍历，遍历是万能解法，空间O(1)，链表太长时递归可能出现栈溢出，空间O(N)；遍历实现需使用守卫节点简化边界条件；递归实现分三步：① 递归遍历下一个指针；② 反转指针(next → cur)，并删除原方向指针(cur → next)；③ 出栈时递归向上返回新的头结点；

倒数第K个节点问题：利用快慢指针来解，快指针先走K步，然后快慢指针同步移动，快指针到达链表结尾(NULL)时，慢指针就指向倒数第K个节点；如果要删除倒数第K个节点，可利用守卫节点走到倒数第K+1个节点，然后再执行删除；

删除链表节点问题：包括①删除指定值的节点；②删除第K个、倒数第K个节点；③重复节点去重；④删除所有重复节点；其中③和④分排序和不排序两类，排序链表只需比较相邻节点，不排序链表需借助哈希表实现重复元素的O(1)查找；

链表重组问题：按照一定算法将链表拆分后再合并，可以解决链表的分割、相交、旋转等问题；
## 6. 力扣2. 两数之和
思路：
首先，逆序的意思是;链表;1->2->3表示的是数字321，所以在计算两数之和时，要注意进位问题。
步骤:
1. 遍历l1，l2结点个数，如果个数不同(位数不同)，补齐链表长度使计算对齐
2. 逐位相加并处理进位(count)，最后补齐
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int len1=1;//记录l1的长度
        int len2=1;//记录l2的长度
        ListNode* p=l1;
        ListNode* q=l2;
        while(p->next!=NULL)//获取l1的长度
        {
            len1++;
            p=p->next;
        }
        while(q->next!=NULL)//获取l2的长度
        {
            len2++;
            q=q->next;
        }
        if(len1>len2)//l1较长，在l2末尾补零
        {
            for(int i=1;i<=len1-len2;i++)
            {
                q->next=new ListNode(0);
                q=q->next;
            }
        }
        else//l2较长，在l1末尾补零
        {
            for(int i=1;i<=len2-len1;i++)
            {
                p->next=new ListNode(0);
                p=p->next;
            }
        }
        p=l1;
        q=l2;
        bool count=false;//记录进位
        ListNode* l3=new ListNode(-1);//存放结果的链表
        ListNode* w=l3;//l3的移动指针
        int i=0;//记录相加结果
        while(p!=NULL&&q!=NULL)
        {
            i=count+p->val+q->val;
            w->next=new ListNode(i%10);
            count=i>=10?true:false;
            w=w->next;
            p=p->next;
            q=q->next;
        }
        if(count)//若最后还有进位
        {
            w->next=new ListNode(1);
            w=w->next;
        }
        return l3->next; 
    }
};```
## 力扣234.回文链表（链表终点，反转链表的整合）
代码块：
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head){
        ListNode* slow = head ,* fast = head;
        while(fast != nullptr && fast->next != nullptr){
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
    ListNode* reverseList(ListNode* head){
        ListNode* pre = nullptr, *cur = head;
        while(cur){
            ListNode* temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp; 
        }
        return pre;
    }
    bool isPalindrome(ListNode* head) {
       ListNode* mid = middleNode(head);
       ListNode* head2 = reverseList(mid);
        while(head2){
            if(head->val != head2->val){
                return false;
            }
            else{
                head = head->next;
                head2 = head2->next;
            }   
        }
        return true;
    }
};
```
PS:反转链表的两种方法
**迭代:**
```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *cur = head, *pre = nullptr;
        while(cur != nullptr) {
            ListNode* tmp = cur->next; // 暂存后继节点 cur.next
            cur->next = pre;           // 修改 next 引用指向
            pre = cur;                 // pre 暂存 cur
            cur = tmp;                 // cur 访问下一节点
        }
        return pre;
    }
};```
**递归:**
```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        return recur(head, nullptr);           // 调用递归并返回
    }
private:
    ListNode* recur(ListNode* cur, ListNode* pre) {
        if (cur == nullptr) return pre;        // 终止条件
        ListNode* res = recur(cur->next, cur); // 递归后继节点
        cur->next = pre;                       // 修改节点引用指向
        return res;                            // 返回反转链表的头节点
    }
};```
递归分析：
```cpp
ListNode* recur(ListNode* cur, ListNode* pre) {
    if (cur == nullptr) return pre;        // 终止条件
    ListNode* res = recur(cur->next, cur); // 递归后继节点
    cur->next = pre;                       // 修改节点引用指向
    return res;                            // 返回反转链表的头节点
}
```
```cpp
recur(1, nullptr)
├── recur(2, 1)  // 递归调用
│   ├── recur(3, 2)
│   │   ├── recur(nullptr, 3) → 返回 3
│   │   ├── 3->next = 2  // 3指向2
│   │   └── 返回 3
│   ├── 2->next = 1  // 2指向1
│   └── 返回 3
├── 1->next = nullptr  // 1指向nullptr
└── 返回 3
```
# 搜索算法![[Pasted image 20251116100303.png]]
搜索算法的优势：高效枚举可能路径，适用于**无权图的最短路径或约束满足问题**。
缺点：**DFS可能超时（指数级时间），BFS空间消耗大（需队列）。**
## 概述
- **核心思想**：搜索是将问题空间视为“图”或“树”，通过系统枚举路径找到解。DFS像“钻洞”深入，BFS像“层层扩散”。
- **适用问题**：迷宫求解、连通块统计、排列组合枚举、N皇后、八数码等。
- **时间/空间复杂度**：
  - DFS：O(分支因子^深度)，最坏指数级。
  - BFS：O(V + E)，V为节点数，E为边数。
- ==用递归实现DFS，用队列实现BFS。==

## 深度优先搜索（DFS）（在叁中也有写过）![[Pasted image 20251116100648.png]]
DFS（Depth-First Search）是一种“先深后广”的递归搜索策略：从起点出发，沿着一条路径尽可能深入，直到死胡同（无路可走或条件不满足），然后回溯到上一个分支点，尝试其他路径。DFS本质上是**递归的枚举**，通过函数调用栈模拟路径栈。常用于回溯法。
![[Pasted image 20251111222802.png]]
### 代码模板：
```cpp
type dfs(type x, ... ) // 可以存在多个变量
{
    if( ... ) // 达成目标，找到答案
    {
        ... // 输出答案或判断最优解等等
        return;
    }
    if( ... ) // 达到搜索边界（即到边界了还没搜到，有时没有此步骤）
    {
        return;
    }
    for( ... ) // 遍历所有子节点
    {
        if( ... ) // 可以转移状态，一般用标志变量判断
        {
            ... // 修改标志变量，表明此节点不可转移
            dfs( ... ) // 搜索子节点，经常为x+1
            ... // 还原标志变量，表面此节点可转移
        }
    }
}
```
## 广度优先搜索（BFS）
BFS（Breadth-First Search）是一种“先广后深”的层序搜索策略：从起点开始，访问所有邻接节点（一层），再访问下一层所有节点。使用**队列**管理待访节点，确保最短路径（无权图）。
![[Pasted image 20251111223101.png]]
### 概述
- **队列框架**：
  1. **入队起点**，标记vis=true。
  2. **循环**：出队当前，访问未访邻接（四个方向），入队并标记。
  3. **终止**：队列空或找到目标（记录步数）。
- **优化**：方向数组dx/dy简化邻接枚举；vis防止重复。
- **与DFS区别**：BFS保证层序（最短），DFS不保证。
### 代码模板
```cpp
bool vis[MAXN]; // 标记是否搜索过，有时也可直接用depth来判断
int depth[MAXN]; // 储存搜索深度，有时可能为二维数组或map
queue<type> que; // STL队列，不过数组模拟队列效率更高

type bfs(type start)
{
    que.push(start); // 起点入队
    depth[start] = 0; // 起点深度0
    vis[start] = true; // 标记起点
    while (!que.empty())
    {
        type now = que.front(); // 当前节点设置为队首
        que.pop(); // 弹出队首
        if ( ... ) // 如果达到目标条件
        {
            ans = depth[now]; // 储存答案
            return; // 搜索结束
        }
        for( ... ) // 遍历now节点的所有子节点，可用数组表示方向
        {
            type next = ... // 计算出子节点
            if (!vis[next] && ... ) // 如果子节点未搜索过，且范围符合题目条件
            {
                vis[next] = true; // 标记子节点
                depth[next] = depth[now] + 1; // 子节点深度+1
                que.push(next); // 子节点入队
                // 有时题目还需输出具体路径，可用一个数组储存每个节点的上一个节点，然后在此处对数组赋值。输出时，从结尾递归反向输出即可获得具体的路径。
            }
        }
    }
}
```

