# 前缀和详解

前缀和（Prefix Sum）是一种非常重要的算法技巧，主要用于**快速计算数组任意区间内的和**。

## 基本概念

### 什么是前缀和？

前缀和是一个新的数组，其中第i个元素表示原数组前i个元素的和。

**定义：**
- 原数组：`nums[0], nums[1], nums[2], ..., nums[n-1]`
- 前缀和数组：`prefix[0], prefix[1], prefix[2], ..., prefix[n]`
- 其中：`prefix[i] = nums[0] + nums[1] + ... + nums[i-1]`

**注意：** 前缀和数组通常比原数组多一个元素，`prefix[0] = 0`

## 前缀和的构建

```cpp
vector<int> buildPrefixSum(vector<int>& nums) {
    int n = nums.size();
    vector<int> prefix(n + 1, 0);
    
    for(int i = 0; i < n; i++) {
        prefix[i + 1] = prefix[i] + nums[i];
    }
    
    return prefix;
}
```

### 示例：
```
原数组: [1, 2, 3, 4, 5]
前缀和: [0, 1, 3, 6, 10, 15]
```

## 前缀和的核心应用

### 1. 快速计算区间和

**公式：** `sum[i...j] = prefix[j+1] - prefix[i]`

```cpp
int rangeSum(vector<int>& prefix, int i, int j) {
    return prefix[j + 1] - prefix[i];
}
```

**示例：**
```
计算 nums[1] 到 nums[3] 的和：
prefix[4] - prefix[1] = 10 - 1 = 9
验证：nums[1]+nums[2]+nums[3] = 2+3+4 = 9 ✓
```

### 2. 解决子数组和问题

前缀和特别适合解决"子数组和等于k"这类问题。

**核心思想：**
- 如果 `prefix[j] - prefix[i] = k`
- 那么子数组 `nums[i...j-1]` 的和就等于k

## 实际应用示例

### 示例1：力扣930 - 和相同的二元子数组

```cpp
class Solution {
public:
    int numSubarraysWithSum(vector<int>& nums, int goal) {
        unordered_map<int, int> prefixCount;
        prefixCount[0] = 1; // 前缀和为0出现1次
        
        int sum = 0, count = 0;
        for(int num : nums) {
            sum += num; // 当前前缀和
            
            // 如果存在前缀和 = sum - goal
            // 说明存在子数组的和 = goal
            if(prefixCount.find(sum - goal) != prefixCount.end()) {
                count += prefixCount[sum - goal];
            }
            
            prefixCount[sum]++;
        }
        return count;
    }
};
```

**工作原理：**
- 遍历数组，计算当前前缀和 `sum`
- 检查是否存在 `sum - goal` 的前缀和
- 如果存在，说明从那个位置到当前位置的子数组和为goal

### 示例2：力扣560 - 和为K的子数组

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> prefixCount;
        prefixCount[0] = 1;
        
        int sum = 0, count = 0;
        for(int num : nums) {
            sum += num;
            if(prefixCount.find(sum - k) != prefixCount.end()) {
                count += prefixCount[sum - k];
            }
            prefixCount[sum]++;
        }
        return count;
    }
};
```

## 前缀和的变种

### 1. 二维前缀和
用于快速计算矩阵中任意矩形区域的和。

### 2. 差分数组
前缀和的逆运算，用于快速进行区间加减操作。

## 前缀和的优势

1. **时间复杂度优化：**
   - 构建前缀和：O(n)
   - 查询区间和：O(1)
   - 相比每次都重新计算：O(n) → O(1)

2. **空间换时间：**
   - 需要额外的O(n)空间存储前缀和数组
   - 但大大提高了查询效率

3. **代码简洁：**
   - 逻辑清晰，易于理解和实现

## 练习题目

1. **简单：**
   - 303. 区域和检索 - 数组不可变
   - 724. 寻找数组的中心下标

2. **中等：**
   - 560. 和为K的子数组
   - 930. 和相同的二元子数组
   - 1248. 统计「优美子数组」

3. **困难：**
   - 1074. 元素和为目标值的子矩阵数量

前缀和是解决数组区间和问题的利器，掌握它对于解决许多算法问题都很有帮助！
# 关于容器插入方法

## 各种容器的插入方法总结

### 1. **序列容器 (Sequence Containers)** - 使用 `push_back`

| 容器             | 插入方法                          | 特点           |
| -------------- | ----------------------------- | ------------ |
| `vector`       | `push_back()`                 | 动态数组，尾部插入高效  |
| `deque`        | `push_back()`, `push_front()` | 双端队列，头尾插入都高效 |
| `list`         | `push_back()`, `push_front()` | 双向链表，头尾插入都高效 |
| `forward_list` | `push_front()`                | 单向链表，只有头部插入  |

**示例：**
```cpp
vector<int> vec;
vec.push_back(10);    // ✅ 正确

deque<int> dq;
dq.push_back(20);     // ✅ 正确
dq.push_front(15);    // ✅ 正确

list<int> lst;
lst.push_back(30);    // ✅ 正确
```

### 2. **关联容器 (Associative Containers)** - 使用 `insert`

| 容器         | 插入方法       | 特点         |
| ---------- | ---------- | ---------- |
| `set`      | `insert()` | 有序唯一元素集合   |
| `multiset` | `insert()` | 有序可重复元素集合  |
| `map`      | `insert()` | 键值对集合      |
| `multimap` | `insert()` | 可重复键的键值对集合 |

**示例：**
```cpp
set<int> s;
s.insert(10);         // ✅ 正确
// s.push_back(10);   // ❌ 错误！

multiset<int> ms;
ms.insert(20);        // ✅ 正确

map<string, int> m;
m.insert({"key", 1}); // ✅ 正确
```

### 3. **无序关联容器 (Unordered Associative Containers)** - 使用 `insert`

| 容器 | 插入方法 | 特点 |
|------|----------|------|
| `unordered_set` | `insert()` | 哈希集合 |
| `unordered_multiset` | `insert()` | 可重复哈希集合 |
| `unordered_map` | `insert()` | 哈希映射 |
| `unordered_multimap` | `insert()` | 可重复键哈希映射 |

**示例：**
```cpp
unordered_set<int> us;
us.insert(10);        // ✅ 正确
```

## 为什么设计成这样？

### 设计哲学差异：

**序列容器** (`vector`, `list`, `deque`)：
- 维护元素的**插入顺序**
- `push_back` 强调在**特定位置**（尾部）添加元素
- 适用于需要保持元素顺序的场景

**关联容器** (`set`, `map`, `multiset`)：
- 按**值**自动排序（或哈希）
- `insert` 强调按**值**插入到正确位置
- 不关心插入顺序，只关心值的顺序

## 在滑动窗口问题中的具体应用

```cpp
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    vector<int> result;        // 序列容器 - 用 push_back
    multiset<int> window;      // 关联容器 - 用 insert
    
    for (int i = 0; i < nums.size(); i++) {
        window.insert(nums[i]);  // ✅ multiset 必须用 insert
        
        if (i >= k - 1) {
            result.push_back(*window.rbegin());  // ✅ vector 用 push_back
            
            window.erase(window.find(nums[i - k + 1]));  // multiset 用 erase
        }
    }
    
    return result;
}
```

## 记忆技巧

1. **看容器名称**：
   - 包含 `set` 或 `map` → 用 `insert`
   - `vector`, `list`, `deque` → 用 `push_back`

2. **理解用途**：
   - 需要保持顺序 → 序列容器 → `push_back`
   - 需要自动排序/快速查找 → 关联容器 → `insert`

3. **简单规则**：
   ```cpp
   // 如果是数组、列表、队列
   sequence_container.push_back(value);
   
   // 如果是集合、映射
   associative_container.insert(value);
   ```

## 总结

- **`multiset` 只能用 `insert`**，不能用 `push_back`
- **`vector` 可以用 `push_back`**
- 选择哪种容器和插入方法取决于你的需求：
  - 保持顺序 → 序列容器 + `push_back`
  - 自动排序/快速查找 → 关联容器 + `insert`

理解这个区别对于正确使用C++ STL容器非常重要！
# 容器输出方法详解

## 容器输出的主要方式

### 1. **序列容器的输出**

#### `vector` / `deque` / `list` 的输出：
```cpp
#include <vector>
#include <deque>
#include <list>
#include <iostream>
using namespace std;

vector<int> vec = {1, 2, 3};
deque<int> dq = {4, 5, 6};
list<int> lst = {7, 8, 9};

// 方法1: 使用索引（仅vector和deque支持）
for (size_t i = 0; i < vec.size(); i++) {
    cout << vec[i] << " ";  // 输出: 1 2 3
}

// 方法2: 使用迭代器（所有序列容器都支持）
for (auto it = vec.begin(); it != vec.end(); it++) {
    cout << *it << " ";  // 输出: 1 2 3
}

// 方法3: 范围for循环（推荐）
for (int num : vec) {
    cout << num << " ";  // 输出: 1 2 3
}

// 方法4: 使用front()和back()访问首尾元素
cout << vec.front();  // 输出第一个元素: 1
cout << vec.back();   // 输出最后一个元素: 3
```

### 2. **关联容器的输出**

#### `set` / `multiset` 的输出：
```cpp
#include <set>
#include <iostream>
using namespace std;

set<int> s = {3, 1, 4, 1, 5};  // 自动排序去重: {1, 3, 4, 5}
multiset<int> ms = {3, 1, 4, 1, 5};  // 自动排序: {1, 1, 3, 4, 5}

// 只能使用迭代器或范围for循环（没有索引访问）
for (int num : s) {
    cout << num << " ";  // 输出: 1 3 4 5
}

// 使用反向迭代器输出倒序
for (auto it = s.rbegin(); it != s.rend(); it++) {
    cout << *it << " ";  // 输出: 5 4 3 1
}

// 访问最小值和最大值
cout << *s.begin();    // 最小值: 1
cout << *s.rbegin();   // 最大值: 5
```

#### `map` / `multimap` 的输出：
```cpp
#include <map>
#include <iostream>
using namespace std;

map<string, int> m = {{"apple", 5}, {"banana", 3}, {"orange", 8}};

// 方法1: 范围for循环
for (const auto& pair : m) {
    cout << pair.first << ": " << pair.second << endl;
    // 输出: apple: 5
    //       banana: 3  
    //       orange: 8
}

// 方法2: 结构化绑定（C++17）
for (const auto& [key, value] : m) {
    cout << key << ": " << value << endl;
}

// 方法3: 使用迭代器
for (auto it = m.begin(); it != m.end(); it++) {
    cout << it->first << ": " << it->second << endl;
}
```

### 3. **无序容器的输出**

#### `unordered_set` / `unordered_map` 的输出：
```cpp
#include <unordered_set>
#include <unordered_map>
#include <iostream>
using namespace std;

unordered_set<int> us = {3, 1, 4, 1, 5};  // 顺序不确定
unordered_map<string, int> um = {{"apple", 5}, {"banana", 3}};

// 输出顺序不确定（基于哈希）
for (int num : us) {
    cout << num << " ";  // 可能输出: 4 1 5 3
}

for (const auto& [key, value] : um) {
    cout << key << ": " << value << endl;
    // 可能输出: banana: 3
    //          apple: 5
}
```

## 特殊容器的输出方法

### `stack` / `queue` / `priority_queue` 的输出：
```cpp
#include <stack>
#include <queue>
#include <iostream>
using namespace std;

stack<int> st;
queue<int> q;
priority_queue<int> pq;

// 这些容器不支持直接遍历，需要逐个弹出
while (!st.empty()) {
    cout << st.top() << " ";  // 访问栈顶
    st.pop();  // 移除栈顶
}

while (!q.empty()) {
    cout << q.front() << " ";  // 访问队首
    q.pop();  // 移除队首
}

while (!pq.empty()) {
    cout << pq.top() << " ";  // 访问最大元素
    pq.pop();  // 移除最大元素
}
```

## 输出方法的类比总结

| 容器类型 | 插入方法 | 输出/访问方法 | 特点 |
|----------|----------|---------------|------|
| **序列容器** | `push_back()` | `[]`, `at()`, 迭代器 | 保持插入顺序，支持随机访问 |
| **关联容器** | `insert()` | 迭代器, `find()` | 自动排序，不支持随机访问 |
| **无序容器** | `insert()` | 迭代器, `find()` | 哈希存储，顺序不确定 |
| **适配器** | `push()` | `top()`, `front()` | 受限访问（LIFO/FIFO） |

## 实用输出技巧

### 1. **调试输出函数**
```cpp
template<typename T>
void printContainer(const T& container) {
    for (const auto& elem : container) {
        cout << elem << " ";
    }
    cout << endl;
}

// 使用
vector<int> vec = {1, 2, 3};
set<int> s = {3, 1, 2};
printContainer(vec);  // 输出: 1 2 3
printContainer(s);    // 输出: 1 2 3
```

### 2. **map的特定键值输出**
```cpp
map<string, int> m = {{"apple", 5}, {"banana", 3}};

// 检查键是否存在并输出
if (m.find("apple") != m.end()) {
    cout << "apple: " << m["apple"] << endl;  // 输出: apple: 5
}

// 使用count检查
if (m.count("banana")) {
    cout << "banana: " << m.at("banana") << endl;  // 输出: banana: 3
}
```

### 3. **边界检查输出**
```cpp
vector<int> vec = {1, 2, 3};

// 安全的边界检查访问
try {
    cout << vec.at(10);  // 抛出std::out_of_range异常
} catch (const out_of_range& e) {
    cout << "索引越界: " << e.what() << endl;
}

// 不安全的访问
cout << vec[10];  // 未定义行为！
```

## 总结

1. **序列容器**：支持多种输出方式（索引、迭代器、范围for）
2. **关联容器**：只能使用迭代器或范围for循环
3. **无序容器**：输出顺序不确定
4. **容器适配器**：受限访问（只能访问特定位置）

**核心原则**：
- 理解不同容器的内部结构
- 选择适合的输出方法
- 注意访问的安全性和效率
- 在C++11+中优先使用范围for循环
