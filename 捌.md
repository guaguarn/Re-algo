# å›¾
å›¾çš„ä¼˜åŠ¿ï¼šçµæ´»å»ºæ¨¡ï¼ˆæœ‰å‘/æ— å‘ã€åŠ æƒ/éåŠ æƒï¼‰ï¼›
ç¼ºç‚¹ï¼šå­˜å‚¨O(V^2)ï¼ˆç¨ å¯†å›¾ï¼‰ï¼Œéå†éœ€visæ ‡è®°é˜²ç¯ã€‚
## æ¦‚è¿°
- **æ ¸å¿ƒæ€æƒ³**ï¼šå›¾ç”±é¡¶ç‚¹ï¼ˆVï¼‰å’Œè¾¹ï¼ˆEï¼‰ç»„æˆã€‚æ— å‘å›¾è¾¹æ— æ–¹å‘ï¼Œæœ‰å‘å›¾æœ‰ï¼ˆå¼§ï¼‰ã€‚åŠ æƒå›¾è¾¹æœ‰æƒå€¼ã€‚
- **åˆ†ç±»**ï¼šç®€å•å›¾ï¼ˆæ— é‡è¾¹/è‡ªç¯ï¼‰ã€è¿é€šå›¾ï¼ˆæ— å‘å¯è¾¾ï¼‰ã€å¼ºè¿é€šï¼ˆæœ‰å‘äº’è¾¾ï¼‰ã€‚
- **æ—¶é—´/ç©ºé—´å¤æ‚åº¦**ï¼šå­˜å‚¨O(V+E)ï¼Œéå†O(V+E)ï¼Œæœ€çŸ­è·¯å¾„O(V^2)ï¼ˆDijkstraï¼‰ã€‚
- **å¸¸è§ç±»å‹**ï¼š
    - æ— å‘å›¾ vs æœ‰å‘å›¾
    - è¿é€šå›¾ vs éè¿é€šå›¾
    - æœ‰æƒå›¾ vs æ— æƒå›¾
- **é‡è¦æœ¯è¯­**ï¼šé‚»æ¥ã€è·¯å¾„ã€åº¦ï¼ˆå…¥åº¦/å‡ºåº¦ï¼‰
## å›¾çš„è¡¨ç¤ºæ–¹æ³•
### é‚»æ¥çŸ©é˜µï¼ˆ2Dæ•°ç»„ï¼Œé€‚åˆç¨ å¯†å›¾ï¼‰
æŸ¥è¯¢å¿«O(1)ï¼Œä½†ç©ºé—´å ç”¨å¤§O(nÂ²)
**åœ¨ç®€å•å›¾ï¼ˆæ— è‡ªç¯çš„å›¾ï¼‰ä¸­ï¼Œé‚»æ¥çŸ©é˜µçš„ä¸»å¯¹è§’çº¿éƒ½ä¸º0**ã€‚
ä½¿ç”¨ä¸€ä¸ª**äºŒç»´æ•°ç»„ï¼ˆçŸ©é˜µï¼‰**Â æ¥è®°å½•å›¾ä¸­å„ä¸ªé¡¶ç‚¹ä¹‹é—´çš„è¿æ¥å…³ç³»ã€‚
ç»™å®šä¸€ä¸ªé¡¶ç‚¹æ•°é‡ä¸ºğ‘›çš„æ— å‘å›¾ï¼Œåˆ™å„ç§æ“ä½œçš„å®ç°æ–¹å¼å¦‚å›¾æ‰€ç¤ºã€‚
- æ·»åŠ æˆ–åˆ é™¤è¾¹ï¼šç›´æ¥åœ¨é‚»æ¥çŸ©é˜µä¸­ä¿®æ”¹æŒ‡å®šçš„è¾¹å³å¯ï¼Œä½¿ç”¨ğ‘‚(1)æ—¶é—´ã€‚è€Œç”±äºæ˜¯æ— å‘å›¾ï¼Œå› æ­¤éœ€è¦åŒ æ—¶æ›´æ–°ä¸¤ä¸ªæ–¹å‘çš„è¾¹ã€‚ 
- æ·»åŠ é¡¶ç‚¹ï¼šåœ¨é‚»æ¥çŸ©é˜µçš„å°¾éƒ¨æ·»åŠ ä¸€è¡Œä¸€åˆ—ï¼Œå¹¶å…¨éƒ¨å¡«0å³å¯ï¼Œä½¿ç”¨ğ‘‚(ğ‘›)æ—¶é—´ã€‚ 
- åˆ é™¤é¡¶ç‚¹ï¼šåœ¨é‚»æ¥çŸ©é˜µä¸­åˆ é™¤ä¸€è¡Œä¸€åˆ—ã€‚å½“åˆ é™¤é¦–è¡Œé¦–åˆ—æ—¶è¾¾åˆ°æœ€å·®æƒ…å†µï¼Œéœ€è¦å°†(ğ‘›âˆ’1)2ä¸ªå…ƒç´  â€œå‘å·¦ä¸Šç§»åŠ¨â€ï¼Œä»è€Œä½¿ç”¨ğ‘‚(ğ‘›2)æ—¶é—´ã€‚ 
- åˆå§‹åŒ–ï¼šä¼ å…¥ğ‘›ä¸ªé¡¶ç‚¹ï¼Œåˆå§‹åŒ–é•¿åº¦ä¸ºğ‘›çš„é¡¶ç‚¹åˆ—è¡¨ å°çš„é‚»æ¥çŸ©é˜µ adjMat ï¼Œä½¿ç”¨ğ‘‚(ğ‘›2)æ—¶é—´ã€‚ ![[Pasted image 20251115155458.png]]
#### ä»£ç 
```cpp
// === File: graph_adjacency_matrix.cpp ===

/* åŸºäºé‚»æ¥çŸ©é˜µå®ç°çš„æ— å‘å›¾ç±» */
class GraphAdjMat {
    vector<int> vertices;           // é¡¶ç‚¹åˆ—è¡¨ï¼Œå…ƒç´ ä»£è¡¨"é¡¶ç‚¹å€¼"ï¼Œç´¢å¼•ä»£è¡¨"é¡¶ç‚¹ç´¢å¼•"
    vector<vector<int>> adjMat;     // é‚»æ¥çŸ©é˜µï¼Œè¡Œåˆ—ç´¢å¼•å¯¹åº”"é¡¶ç‚¹ç´¢å¼•"

public:
    /* æ„é€ æ–¹æ³• */
    GraphAdjMat(const vector<int> &vertices, const vector<vector<int>> &edges) {
        // æ·»åŠ é¡¶ç‚¹
        for (int val : vertices) {
            addVertex(val);
        }
        // æ·»åŠ è¾¹
        // è¯·æ³¨æ„ï¼Œedges å…ƒç´ ä»£è¡¨é¡¶ç‚¹ç´¢å¼•ï¼Œå³å¯¹åº” vertices å…ƒç´ ç´¢å¼•
        for (const vector<int> &edge : edges) {
            addEdge(edge[0], edge[1]);// edge[0]å’Œedge[1]æ˜¯é¡¶ç‚¹ç´¢å¼•
        }
    }

    /* è·å–é¡¶ç‚¹æ•°é‡ */
    int size() const {
        return vertices.size();
    }

    /* æ·»åŠ é¡¶ç‚¹ */
    void addVertex(int val) {
        int n = size();
        // å‘é¡¶ç‚¹åˆ—è¡¨ä¸­æ·»åŠ æ–°é¡¶ç‚¹çš„å€¼
        vertices.push_back(val);
        // åœ¨é‚»æ¥çŸ©é˜µä¸­æ·»åŠ ä¸€è¡Œ
        adjMat.emplace_back(vector<int>(n, 0));
        // åœ¨é‚»æ¥çŸ©é˜µä¸­æ·»åŠ ä¸€åˆ—
        for (vector<int> &row : adjMat) {
            row.push_back(0);
        }
    }

    /* åˆ é™¤é¡¶ç‚¹ */
    void removeVertex(int index) {
        if (index >= size()) {
            throw out_of_range("é¡¶ç‚¹ä¸å­˜åœ¨");
        }
        // åœ¨é¡¶ç‚¹åˆ—è¡¨ä¸­ç§»é™¤ç´¢å¼• index çš„é¡¶ç‚¹
        vertices.erase(vertices.begin() + index);
        // åœ¨é‚»æ¥çŸ©é˜µä¸­åˆ é™¤ç´¢å¼• index çš„è¡Œ
        adjMat.erase(adjMat.begin() + index);
        // åœ¨é‚»æ¥çŸ©é˜µä¸­åˆ é™¤ç´¢å¼• index çš„åˆ—
        for (vector<int> &row : adjMat) {
            row.erase(row.begin() + index);
        }
    }

    /* æ·»åŠ è¾¹ */
    // å‚æ•° i, j å¯¹åº” vertices å…ƒç´ ç´¢å¼•
    void addEdge(int i, int j) {
        // ç´¢å¼•è¶Šç•Œä¸ç›¸ç­‰å¤„ç†
        if (i < 0 || j < 0 || i >= size() || j >= size() || i == j) {
            throw out_of_range("é¡¶ç‚¹ä¸å­˜åœ¨");
        }
        // åœ¨æ— å‘å›¾ä¸­ï¼Œé‚»æ¥çŸ©é˜µå…³äºä¸»å¯¹è§’çº¿å¯¹ç§°ï¼Œå³æ»¡è¶³ (i, j) == (j, i)
        adjMat[i][j] = 1;
        adjMat[j][i] = 1;
    }

    /* åˆ é™¤è¾¹ */
    // å‚æ•° i, j å¯¹åº” vertices å…ƒç´ ç´¢å¼•
    void removeEdge(int i, int j) {
        // ç´¢å¼•è¶Šç•Œä¸ç›¸ç­‰å¤„ç†
        if (i < 0 || j < 0 || i >= size() || j >= size() || i == j) {
            throw out_of_range("é¡¶ç‚¹ä¸å­˜åœ¨");
        }
        adjMat[i][j] = 0;
        adjMat[j][i] = 0;
    }

    /* æ‰“å°é‚»æ¥çŸ©é˜µ */
    void print() {
        cout << "é¡¶ç‚¹åˆ—è¡¨ = ";
        printVector(vertices);
        cout << "é‚»æ¥çŸ©é˜µ =" << endl;
        printVectorMatrix(adjMat);
    }
};
```
![[Pasted image 20251115160959.png]]
### é‚»æ¥è¡¨ï¼ˆæ¨èï¼‰ï¼ˆé“¾è¡¨/å‘é‡ï¼Œé€‚åˆç¨€ç–å›¾ï¼‰
ç©ºé—´èŠ‚çœO(n+m)ï¼Œä½†æŸ¥è¯¢ç¨æ…¢
é‚»æ¥è¡¨ç»“æ„ä¸å“ˆå¸Œè¡¨ä¸­çš„â€œé“¾å¼åœ°å€â€éå¸¸ç›¸ä¼¼ï¼Œå› æ­¤æˆ‘ä»¬ä¹Ÿå¯ä»¥é‡‡ç”¨ç±»ä¼¼çš„æ–¹æ³•æ¥ä¼˜åŒ–æ•ˆç‡ã€‚ æ¯”å¦‚å½“é“¾è¡¨è¾ƒé•¿æ—¶ï¼Œå¯ä»¥å°†é“¾è¡¨è½¬åŒ–ä¸ºAVLæ ‘æˆ–çº¢é»‘æ ‘ï¼Œä»è€Œå°†æ—¶é—´æ•ˆç‡ä»ğ‘‚(ğ‘›)ä¼˜åŒ–è‡³ğ‘‚(logğ‘›)ï¼›è¿˜å¯ ä»¥æŠŠé“¾è¡¨è½¬æ¢ä¸ºå“ˆå¸Œè¡¨ï¼Œä»è€Œå°†æ—¶é—´å¤æ‚åº¦é™è‡³ğ‘‚(1)ã€‚
- æ·»åŠ è¾¹ï¼šåœ¨é¡¶ç‚¹å¯¹åº”é“¾è¡¨çš„æœ«å°¾æ·»åŠ è¾¹å³å¯ï¼Œä½¿ç”¨ğ‘‚(1)æ—¶é—´ã€‚å› ä¸ºæ˜¯æ— å‘å›¾ï¼Œæ‰€ä»¥éœ€è¦åŒæ—¶æ·»åŠ ä¸¤ä¸ª æ–¹å‘çš„è¾¹ã€‚ 
- åˆ é™¤è¾¹ï¼šåœ¨é¡¶ç‚¹å¯¹åº”é“¾è¡¨ä¸­æŸ¥æ‰¾å¹¶åˆ é™¤æŒ‡å®šè¾¹ï¼Œä½¿ç”¨ğ‘‚(ğ‘š)æ—¶é—´ã€‚åœ¨æ— å‘å›¾ä¸­ï¼Œéœ€è¦åŒæ—¶åˆ é™¤ä¸¤ä¸ªæ–¹ å‘çš„è¾¹ã€‚ 
- æ·»åŠ é¡¶ç‚¹ï¼šåœ¨é‚»æ¥è¡¨ä¸­æ·»åŠ ä¸€ä¸ªé“¾è¡¨ï¼Œå¹¶å°†æ–°å¢é¡¶ç‚¹ä½œä¸ºé“¾è¡¨å¤´èŠ‚ç‚¹ï¼Œä½¿ç”¨ğ‘‚(1)æ—¶é—´ã€‚ 
- åˆ é™¤é¡¶ç‚¹ï¼šéœ€éå†æ•´ä¸ªé‚»æ¥è¡¨ï¼Œåˆ é™¤åŒ…å«æŒ‡å®šé¡¶ç‚¹çš„æ‰€æœ‰è¾¹ï¼Œä½¿ç”¨ğ‘‚(ğ‘›+ğ‘š)æ—¶é—´ã€‚ 
- åˆå§‹åŒ–ï¼šåœ¨é‚»æ¥è¡¨ä¸­åˆ›å»ºğ‘›ä¸ªé¡¶ç‚¹å’Œ2ğ‘šæ¡è¾¹ï¼Œä½¿ç”¨ğ‘‚(ğ‘›+ğ‘š)æ—¶é—´ã€‚
![[Pasted image 20251115160730.png]]
- **ä¸ºäº†æ–¹ä¾¿æ·»åŠ ä¸åˆ é™¤é¡¶ç‚¹ï¼Œä»¥åŠç®€åŒ–ä»£ç ï¼Œæˆ‘ä»¬ä½¿ç”¨åˆ—è¡¨ï¼ˆåŠ¨æ€æ•°ç»„ï¼‰æ¥ä»£æ›¿é“¾è¡¨ã€‚ 
- **ä½¿ç”¨å“ˆå¸Œè¡¨æ¥å­˜å‚¨é‚»æ¥è¡¨ï¼Œkeyä¸ºé¡¶ç‚¹å®ä¾‹ï¼Œ value ä¸ºè¯¥é¡¶ç‚¹çš„é‚»æ¥é¡¶ç‚¹åˆ—è¡¨ï¼ˆé“¾è¡¨ï¼‰ã€‚**
å¦å¤–ï¼Œæˆ‘ä»¬åœ¨é‚»æ¥è¡¨ä¸­ä½¿ç”¨ Vertex ç±»æ¥è¡¨ç¤ºé¡¶ç‚¹ï¼Œè¿™æ ·åšçš„åŸå› æ˜¯ï¼šå¦‚æœä¸é‚»æ¥çŸ©é˜µä¸€æ ·ï¼Œç”¨åˆ—è¡¨ç´¢å¼•æ¥åŒº åˆ†ä¸åŒé¡¶ç‚¹ï¼Œé‚£ä¹ˆå‡è®¾è¦åˆ é™¤ç´¢å¼•ä¸ºğ‘–çš„é¡¶ç‚¹ï¼Œåˆ™éœ€éå†æ•´ä¸ªé‚»æ¥è¡¨ï¼Œå°†æ‰€æœ‰å¤§äºğ‘–çš„ç´¢å¼•å…¨éƒ¨å‡1ï¼Œæ•ˆç‡ å¾ˆä½ã€‚è€Œå¦‚æœæ¯ä¸ªé¡¶ç‚¹éƒ½æ˜¯å”¯ä¸€çš„ Vertex å®ä¾‹ï¼Œåˆ é™¤æŸä¸€é¡¶ç‚¹ä¹‹åå°±æ— é¡»æ”¹åŠ¨å…¶ä»–é¡¶ç‚¹äº†ã€‚
#### ä»£ç 
```cpp
// === File: graph_adjacency_list.cpp ===

/* åŸºäºé‚»æ¥è¡¨å®ç°çš„æ— å‘å›¾ç±» */
class GraphAdjList {
public:
    // é‚»æ¥è¡¨ï¼Œkeyï¼šé¡¶ç‚¹ï¼Œvalueï¼šè¯¥é¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹
    unordered_map<Vertex*, vector<Vertex*>> adjList;

    /* åœ¨ vector ä¸­åˆ é™¤æŒ‡å®šèŠ‚ç‚¹ */
    void remove(vector<Vertex*> &vec, Vertex* vet) {
        for (int i = 0; i < vec.size(); i++) {
            if (vec[i] == vet) {
                vec.erase(vec.begin() + i);//ä»é¡¶ç‚¹åˆ—è¡¨ä¸­åˆ é™¤æŒ‡å®šçš„é¡¶ç‚¹
                break;
            }
        }
    }

    /* æ„é€ æ–¹æ³• */
    GraphAdjList(const vector<vector<Vertex*>> &edges) {
        // æ·»åŠ æ‰€æœ‰é¡¶ç‚¹å’Œè¾¹
        for (const vector<Vertex*> &edge : edges) {
            addVertex(edge[0]);
            addVertex(edge[1]);
            addEdge(edge[0], edge[1]);
        }
    }

    /* è·å–é¡¶ç‚¹æ•°é‡ */
    int size() {
        return adjList.size();
    }

    /* æ·»åŠ è¾¹ */
    void addEdge(Vertex* vet1, Vertex* vet2) {
        if (!adjList.count(vet1) || !adjList.count(vet2) || vet1 == vet2)
            throw invalid_argument("ä¸å­˜åœ¨é¡¶ç‚¹");
        // æ·»åŠ è¾¹ vet1 - vet2
        adjList[vet1].push_back(vet2);
        adjList[vet2].push_back(vet1);
    }

    /* åˆ é™¤è¾¹ */
    void removeEdge(Vertex* vet1, Vertex* vet2) {
        if (!adjList.count(vet1) || !adjList.count(vet2) || vet1 == vet2)
            throw invalid_argument("ä¸å­˜åœ¨é¡¶ç‚¹");
        // åˆ é™¤è¾¹ vet1 - vet2
        remove(adjList[vet1], vet2);
        remove(adjList[vet2], vet1);
    }

    /* æ·»åŠ é¡¶ç‚¹ */
    void addVertex(Vertex* vet) {
        if (adjList.count(vet))
            return;
        // åœ¨é‚»æ¥è¡¨ä¸­æ·»åŠ ä¸€ä¸ªæ–°é“¾è¡¨
        adjList[vet] = vector<Vertex*>();
    }

    /* åˆ é™¤é¡¶ç‚¹ */
    void removeVertex(Vertex* vet) {
        if (!adjList.count(vet))
            throw invalid_argument("ä¸å­˜åœ¨é¡¶ç‚¹");
        // åœ¨é‚»æ¥è¡¨ä¸­åˆ é™¤é¡¶ç‚¹ vet å¯¹åº”çš„é“¾è¡¨
        adjList.erase(vet);
        // éå†å…¶ä»–é¡¶ç‚¹çš„é“¾è¡¨ï¼Œåˆ é™¤æ‰€æœ‰åŒ…å« vet çš„è¾¹
        for (auto &adj : adjList) {
            remove(adj.second, vet);
        }
    }

    /* æ‰“å°é‚»æ¥è¡¨ */
    void print() {
        cout << "é‚»æ¥è¡¨ =" << endl;
        for (auto &adj : adjList) {
            const auto &key = adj.first;
            const auto &vec = adj.second;
            cout << key->val << ": ";
            printVector(vetsToVals(vec));
        }
    }
};
```
![[Pasted image 20251115161618.png]]
![[Pasted image 20251115161626.png]]
### å­˜å‚¨æ¯”è¾ƒè¡¨
| å­˜å‚¨æ–¹å¼ | ç©ºé—´     | æŸ¥è¾¹     | éå†     | é€‚ç”¨    |
| ---- | ------ | ------ | ------ | ----- |
| çŸ©é˜µ   | O(V^2) | O(1)   | O(V^2) | ç¨ å¯†ã€å°V |
| è¡¨    | O(V+E) | O(deg) | O(V+E) | ç¨€ç–ã€å¤§E |

## å›¾çš„éå†ï¼ˆéƒ½éœ€è¦ä¸€ä¸ªå“ˆå¸Œé›†åˆvisitedæ¥è®°å½•è®¿é—®è¿‡çš„å…ƒç´ ï¼‰
### å¹¿åº¦ä¼˜å…ˆéå†BFSï¼ˆé˜Ÿåˆ—ï¼‰
å±‚åºè®¿é—®ï¼Œé€‚åˆæœ€çŸ­è·¯å¾„é¢„å¤‡ã€‚
```cpp
// === File: graph_bfs.cpp ===

/* å¹¿åº¦ä¼˜å…ˆéå† */
// ä½¿ç”¨é‚»æ¥è¡¨æ¥è¡¨ç¤ºå›¾ï¼Œä»¥ä¾¿è·å–æŒ‡å®šé¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹
vector<Vertex*> graphBFS(GraphAdjList &graph, Vertex* startVet) {
    // é¡¶ç‚¹éå†åºåˆ—
    vector<Vertex*> res;
    // å“ˆå¸Œé›†åˆï¼Œç”¨äºè®°å½•å·²è¢«è®¿é—®è¿‡çš„é¡¶ç‚¹
    unordered_set<Vertex*> visited = {startVet};// å·²è®¿é—®é›†åˆï¼ˆå«èµ·ç‚¹ï¼‰
    // é˜Ÿåˆ—ç”¨äºå®ç° BFS
    queue<Vertex*> que;
    que.push(startVet);
    
    // ä»¥é¡¶ç‚¹ vet ä¸ºèµ·ç‚¹ï¼Œå¾ªç¯ç›´è‡³è®¿é—®å®Œæ‰€æœ‰é¡¶ç‚¹
    while (!que.empty()) {
        Vertex* vet = que.front();
        que.pop(); // é˜Ÿé¦–é¡¶ç‚¹å‡ºé˜Ÿ
        res.push_back(vet); // è®°å½•è®¿é—®é¡¶ç‚¹
        
        // éå†è¯¥é¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹
        for (auto adjVet : graph.adjList[vet]) {
            if (visited.count(adjVet))
                continue; // è·³è¿‡å·²è¢«è®¿é—®çš„é¡¶ç‚¹
            que.push(adjVet); // åªå…¥é˜Ÿæœªè®¿é—®çš„é¡¶ç‚¹
            visited.emplace(adjVet); // æ ‡è®°è¯¥é¡¶ç‚¹å·²è¢«è®¿é—®
        }
    }
    
    // è¿”å›é¡¶ç‚¹éå†åºåˆ—
    return res;
}
```
- **è§£é‡Š**ï¼šviså…¥é˜Ÿæ—¶æ ‡è®°ï¼Œé˜²é‡å¤ã€‚è¾“å‡ºå±‚åºã€‚
==å¹¿åº¦ä¼˜å…ˆéå†çš„åºåˆ—æ˜¯å¦å”¯ä¸€ï¼Ÿ ä¸å”¯ä¸€ã€‚å¹¿åº¦ä¼˜å…ˆéå†åªè¦æ±‚æŒ‰â€œç”±è¿‘åŠè¿œâ€çš„é¡ºåºéå†ï¼Œè€Œå¤šä¸ªç›¸åŒè·ç¦»çš„é¡¶ç‚¹çš„éå†é¡ºåºå…è®¸è¢« ä»»æ„æ‰“ä¹±ã€‚==
åœ¨BFSä¸­ä½¿ç”¨Â `unordered_set`Â ä½œä¸ºvisitedé›†åˆæ˜¯å› ä¸ºï¼š
1. **âœ… é˜²æ­¢é‡å¤è®¿é—®**Â - ç¡®ä¿æ¯ä¸ªé¡¶ç‚¹åªå¤„ç†ä¸€æ¬¡
2. **âœ… é«˜æ€§èƒ½**Â - O(1)çš„æŸ¥æ‰¾å’Œæ’å…¥
3. **âœ… çµæ´»æ€§**Â - é€‚ç”¨äºæŒ‡é’ˆç­‰å¤æ‚æ ‡è¯†ç¬¦
4. **âœ… ç®€æ´æ€§**Â - ä»£ç æ¸…æ™°æ˜“æ‡‚
5. **âœ… å®‰å…¨æ€§**Â - é¿å…æ— é™å¾ªç¯

è¿™æ˜¯å›¾éå†ç®—æ³•ä¸­çš„æ ‡å‡†åšæ³•ï¼Œä¹Ÿæ˜¯ä¿è¯ç®—æ³•æ­£ç¡®æ€§å’Œæ•ˆç‡çš„å…³é”®è®¾è®¡ï¼
### æ·±åº¦ä¼˜å…ˆéå†DFSï¼ˆé€’å½’ï¼‰ï¼ˆæ ˆï¼‰
è®¿é—®æœªè®¿é‚»æ¥ï¼Œé€‚åˆè·¯å¾„æšä¸¾ã€‚
æ·±åº¦ä¼˜å…ˆéå†æ˜¯ä¸€ç§ä¼˜å…ˆèµ°åˆ°åº•ã€æ— è·¯å¯èµ°å†å›å¤´çš„éå†æ–¹å¼
```cpp
// === File: graph_dfs.cpp ===

/* æ·±åº¦ä¼˜å…ˆéå†è¾…åŠ©å‡½æ•° */
void dfs(GraphAdjList &graph, unordered_set<Vertex*> &visited, 
         vector<Vertex*> &res, Vertex* vet) {
    res.push_back(vet);              // è®°å½•è®¿é—®é¡¶ç‚¹
    visited.emplace(vet);            // æ ‡è®°è¯¥é¡¶ç‚¹å·²è¢«è®¿é—®
    
    // éå†è¯¥é¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹
    for (Vertex* adjVet : graph.adjList[vet]) {
        if (visited.count(adjVet))
            continue;                // è·³è¿‡å·²è¢«è®¿é—®çš„é¡¶ç‚¹
        
        // é€’å½’è®¿é—®é‚»æ¥é¡¶ç‚¹
        dfs(graph, visited, res, adjVet);
    }
}

/* æ·±åº¦ä¼˜å…ˆéå† */
// ä½¿ç”¨é‚»æ¥è¡¨æ¥è¡¨ç¤ºå›¾ï¼Œä»¥ä¾¿è·å–æŒ‡å®šé¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹
vector<Vertex*> graphDFS(GraphAdjList &graph, Vertex* startVet) {
    // é¡¶ç‚¹éå†åºåˆ—
    vector<Vertex*> res;
    // å“ˆå¸Œé›†åˆï¼Œç”¨äºè®°å½•å·²è¢«è®¿é—®è¿‡çš„é¡¶ç‚¹
    unordered_set<Vertex*> visited;
    dfs(graph, visited, res, startVet);
    return res;
}
```

##  æœ€çŸ­è·¯å¾„
ç¬”è®°é‡ç‚¹ï¼šéè´Ÿæƒç”¨Dijkstraï¼Œæœ‰è´Ÿ/å…¨æºç”¨Floydã€‚å‡è®¾æ— è´Ÿç¯ã€‚
## æ‹“æ‰‘æ’åº
**æ‹“æ‰‘æ’åº**æ˜¯å¯¹æœ‰å‘æ— ç¯å›¾(DAG)çš„æ‰€æœ‰é¡¶ç‚¹è¿›è¡Œçº¿æ€§æ’åºï¼Œä½¿å¾—å¯¹äºä»»ä½•ä»é¡¶ç‚¹uåˆ°é¡¶ç‚¹vçš„æœ‰å‘è¾¹(u, v)ï¼Œåœ¨æ’åºä¸­uéƒ½åœ¨vçš„å‰é¢ã€‚
### æ–¹æ³•1ï¼šKahnç®—æ³•ï¼ˆå…¥åº¦è¡¨+BFSï¼‰
```cpp
vector<int> topologicalSort(int n, vector<vector<int>>& edges) {
    // æ„å»ºé‚»æ¥è¡¨å’Œå…¥åº¦æ•°ç»„
    vector<vector<int>> graph(n);
    vector<int> indegree(n, 0);
    
    // åˆå§‹åŒ–å›¾
    for(auto& edge : edges) {
        int u = edge[0], v = edge[1];
        graph[u].push_back(v);  // u â†’ v
        indegree[v]++;          // vçš„å…¥åº¦+1
    }
    
    // å°†æ‰€æœ‰å…¥åº¦ä¸º0çš„é¡¶ç‚¹åŠ å…¥é˜Ÿåˆ—
    queue<int> q;
    for(int i = 0; i < n; i++) {
        if(indegree[i] == 0) {
            q.push(i);
        }
    }
    
    vector<int> result;
    while(!q.empty()) {
        int u = q.front();
        q.pop();
        result.push_back(u);
        
        // å¤„ç†uçš„æ‰€æœ‰é‚»å±…
        for(int v : graph[u]) {
            indegree[v]--;          // åˆ é™¤è¾¹uâ†’vï¼Œvå…¥åº¦-1
            if(indegree[v] == 0) {  // å¦‚æœvå…¥åº¦å˜ä¸º0
                q.push(v);          // åŠ å…¥é˜Ÿåˆ—
            }
        }
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰ç¯
    if(result.size() != n) {
        return {};  // å­˜åœ¨ç¯ï¼Œæ— æ³•æ‹“æ‰‘æ’åº
    }
    return result;
}
```
### æ–¹æ³•2ï¼šDFSç®—æ³•
```cpp
vector<int> topologicalSortDFS(int n, vector<vector<int>>& edges) {
    vector<vector<int>> graph(n);
    for(auto& edge : edges) {
        graph[edge[0]].push_back(edge[1]);
    }
    
    vector<int> result;
    vector<int> visited(n, 0);  // 0:æœªè®¿é—®, 1:è®¿é—®ä¸­, 2:å·²è®¿é—®
    
    for(int i = 0; i < n; i++) {
        if(visited[i] == 0) {
            if(!dfs(i, graph, visited, result)) {
                return {};  // æœ‰ç¯
            }
        }
    }
    
    reverse(result.begin(), result.end());
    return result;
}

bool dfs(int u, vector<vector<int>>& graph, vector<int>& visited, vector<int>& result) {
    visited[u] = 1;  // æ ‡è®°ä¸ºè®¿é—®ä¸­
    
    for(int v : graph[u]) {
        if(visited[v] == 1) return false;  // å‘ç°ç¯
        if(visited[v] == 0) {
            if(!dfs(v, graph, visited, result)) return false;
        }
    }
    
    visited[u] = 2;  // æ ‡è®°ä¸ºå·²è®¿é—®
    result.push_back(u);
    return true;
}
```
### "æ‹“æ‰‘æ’åºä¸‰è¦ç´ "

1. **æœ‰å‘å›¾**Â - åªèƒ½ç”¨äºæœ‰å‘å›¾
    
2. **æ— ç¯**Â - å›¾ä¸­ä¸èƒ½æœ‰å¾ªç¯ä¾èµ–
    
3. **çº¿æ€§åº**Â - ç»“æœæ˜¯é¡¶ç‚¹çš„ä¸€ä¸ªçº¿æ€§æ’åˆ—
    

### "Kahnç®—æ³•å››æ­¥æ›²"

1. **å»ºå›¾**Â - æ„å»ºé‚»æ¥è¡¨å’Œå…¥åº¦æ•°ç»„
    
2. **æ‰¾èµ·ç‚¹**Â - æ‰€æœ‰å…¥åº¦ä¸º0çš„é¡¶ç‚¹å…¥é˜Ÿ
    
3. **å¤„ç†é˜Ÿåˆ—**Â - å‡ºé˜Ÿã€è®°å½•ã€æ›´æ–°é‚»å±…å…¥åº¦
    
4. **æ£€æŸ¥ç¯**Â - ç»“æœæ•°é‡æ˜¯å¦ç­‰äºé¡¶ç‚¹æ€»æ•°
æ‹“æ‰‘æ’åºæ˜¯å¤„ç†ä¾èµ–å…³ç³»é—®é¢˜çš„æ ¸å¿ƒç®—æ³•ï¼š

- âœ… è§£å†³"å…ˆå†³æ¡ä»¶"ç±»é—®é¢˜
- âœ… æ£€æµ‹å›¾ä¸­æ˜¯å¦æœ‰ç¯
- âœ… ä¸ºä»»åŠ¡æä¾›åˆç†çš„æ‰§è¡Œé¡ºåº
- âœ… æ—¶é—´å¤æ‚åº¦ä¼˜ç§€ O(V+E)
æŒæ¡æ‹“æ‰‘æ’åºå¯¹äºè§£å†³LeetCodeä¸­å¾ˆå¤šå›¾è®ºé—®é¢˜ï¼ˆå¦‚207, 210, 329ç­‰ï¼‰éƒ½éå¸¸æœ‰å¸®åŠ©ï¼
### å­—å…¸æ ‘
https://leetcode.cn/problems/implement-trie-prefix-tree/solutions/98390/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt
è®²çš„å¾ˆå¥½
**å­—å…¸æ ‘**ï¼ˆTrieï¼Œå‘éŸ³åŒ"try"ï¼‰æ˜¯ä¸€ç§ä¸“é—¨ç”¨äº**é«˜æ•ˆå­˜å‚¨å’Œæ£€ç´¢å­—ç¬¦ä¸²**çš„æ ‘å½¢æ•°æ®ç»“æ„ã€‚å®ƒä¹Ÿè¢«ç§°ä¸ºå‰ç¼€æ ‘ã€å•è¯æŸ¥æ‰¾æ ‘ã€‚
![[Pasted image 20251116144924.png]]
#### **èŠ‚ç‚¹å®šä¹‰**
```cpp
class TrieNode {
public:
    vector<TrieNode*> children;  // å­èŠ‚ç‚¹æ•°ç»„
    bool isEnd;                  // æ ‡è®°æ˜¯å¦ä¸ºå•è¯ç»“å°¾
    
    TrieNode() : children(26, nullptr), isEnd(false) {}
};
```
#### e.g.å­˜å‚¨å•è¯ï¼š["apple", "app", "banana", "bat"]
```cpp
æ ¹èŠ‚ç‚¹
  |
  a (26ä¸ªå­èŠ‚ç‚¹ï¼Œåªç”¨äº†aå’Œb)
  |     \
  p      b
  |       \
  p (isEnd) a
  |          \
  l (isEnd)   n
  |            \
  e (isEnd)     a
                 \
                  n
                   \
                    a (isEnd)
```
#### æ’å…¥
```cpp
void insert(string word) {
    TrieNode* node = root;
    for(char c : word) {
        int index = c - 'a';
        if(!node->children[index]) {
            node->children[index] = new TrieNode();
        }
        node = node->children[index];
    }
    node->isEnd = true;  // æ ‡è®°å•è¯ç»“æŸ
}
```
#### æœç´¢
```cpp
bool search(string word) {
    TrieNode* node = root;
    for(char c : word) {
        int index = c - 'a';
        if(!node->children[index]) {
            return false;
        }
        node = node->children[index];
    }
    return node->isEnd;  // å¿…é¡»æ­£å¥½æ˜¯å•è¯ç»“å°¾
}
```
#### å‰ç¼€æœç´¢
```cpp
bool startsWith(string prefix) {
    TrieNode* node = root;
    for(char c : prefix) {
        int index = c - 'a';
        if(!node->children[index]) {
            return false;
        }
        node = node->children[index];
    }
    return true;  // åªè¦å‰ç¼€å­˜åœ¨å°±è¿”å›true
}
```
#### æ€»ä»£ç å—
```cpp
class Trie {
private:
    struct TrieNode {
        vector<TrieNode*> children;
        bool isEnd;
        TrieNode() : children(26, nullptr), isEnd(false) {}
    };
    
    TrieNode* root;

public:
    Trie() {
        root = new TrieNode();
    }
    
    void insert(string word) {
        TrieNode* node = root;
        for(char c : word) {
            int index = c - 'a';
            if(!node->children[index]) {
                node->children[index] = new TrieNode();
            }
            node = node->children[index];
        }
        node->isEnd = true;
    }
    
    bool search(string word) {
        TrieNode* node = root;
        for(char c : word) {
            int index = c - 'a';
            if(!node->children[index]) {
                return false;
            }
            node = node->children[index];
        }
        return node->isEnd;
    }
    
    bool startsWith(string prefix) {
        TrieNode* node = root;
        for(char c : prefix) {
            int index = c - 'a';
            if(!node->children[index]) {
                return false;
            }
            node = node->children[index];
        }
        return true;
    }
};
```
#### ç”¨é€”ï¼š
**è‡ªåŠ¨è¡¥å®Œï¼Œæ‹¼å†™æ£€æŸ¥ï¼ŒIPè·¯ç”±è¡¨ï¼Œå•è¯æ¸¸æˆ**
##  Dijkstraï¼ˆå•æºï¼Œé‚»æ¥çŸ©é˜µ/è¡¨ï¼‰
è´ªå¿ƒï¼šé€‰distæœ€å°æœªè®¿èŠ‚ç‚¹ï¼Œæ¾å¼›é‚»æ¥ã€‚ç¬”è®°ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–O((V+E)logV)ã€‚

```cpp
#include <queue>
typedef pair<int, int> PII;  // dist, èŠ‚ç‚¹
const int INF = 1e9;
int dist[maxv];
bool vis[maxv] = {false};
vector<PII> adj[maxv];  // pair<èŠ‚ç‚¹,æƒ>

void dijkstra(int s, int n) {
    fill(dist, dist + n, INF);
    dist[s] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> pq;
    pq.push({0, s});
    while (!pq.empty()) {
        int u = pq.top().second; pq.pop();
        if (vis[u]) continue;
        vis[u] = true;
        for (auto [v, w] : adj[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
}
```
- **è§£é‡Š**ï¼švisé€‰æœ€å°åæ ‡è®°ï¼Œæ¾å¼›æ›´æ–°ã€‚æµ‹è¯•ï¼šèŠ‚ç‚¹0-1æƒ1,0-2æƒ3,1-2æƒ1 â†’ dist[2]=2ã€‚

##  Floydï¼ˆå…¨æºï¼ŒçŸ©é˜µï¼‰
åŠ¨æ€è§„åˆ’ï¼šdist[i][j] = min(ç›´è¾¾, ç»k)ã€‚

```cpp
int dist[maxv][maxv];
void floyd(int n) {
    for (int k = 0; k < n; k++)
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                if (dist[i][k] < INF && dist[k][j] < INF)
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
}
```
- **è§£é‡Š**ï¼šO(V^3)ï¼Œåˆå§‹åŒ–dist[i][j]=g[i][j]ã€‚ç”¨äºä¼ é€’é—­åŒ…ã€‚

## æœ€å°ç”Ÿæˆæ ‘ï¼ˆMSTï¼‰
æ— å‘è¿é€šåŠ æƒå›¾æœ€å°æƒå­å›¾ï¼ˆV-1è¾¹ï¼‰ã€‚ç¬”è®°ä¸¤æ³•ï¼šPrimï¼ˆåŠ ç‚¹ï¼‰ã€Kruskalï¼ˆåŠ è¾¹ï¼‰ã€‚

## Primï¼ˆçŸ©é˜µ/è¡¨ï¼‰
ä»ç‚¹é›†æ‰©å±•ï¼Œé€‰æœ€å°è¾¹è¿æœªå…¥ç‚¹ã€‚

```cpp
int prim(int n) {
    bool vis[maxv] = {false};
    int lowcost[maxv], total = 0;
    fill(lowcost, lowcost + n, INF);
    vis[0] = true;
    for (int i = 1; i < n; i++) lowcost[i] = g[0][i];  // å‡è®¾çŸ©é˜µg
    for (int i = 1; i < n; i++) {
        int minv = INF, u = -1;
        for (int j = 0; j < n; j++)
            if (!vis[j] && lowcost[j] < minv) { minv = lowcost[j]; u = j; }
        if (u == -1) return -1;  // éè¿é€š
        vis[u] = true; total += minv;
        for (int j = 0; j < n; j++)
            if (!vis[j] && g[u][j] < lowcost[j]) lowcost[j] = g[u][j];
    }
    return total;
}
```

## Kruskalï¼ˆè¾¹æ’åº+å¹¶æŸ¥é›†ï¼‰
ç¬”è®°éœ€å¹¶æŸ¥é›†ï¼ˆUFï¼‰é˜²ç¯ï¼šæ’åºè¾¹ï¼Œ<é˜ˆå€¼åŠ è¾¹å¹¶unionã€‚

```cpp
struct Edge { int u, v, w; } edges[maxe];
bool cmp(Edge a, Edge b) { return a.w < b.w; }
int find(int x) { /* UFæ ‡å‡†å®ç° */ }
void kruskal(int m, int n) {
    sort(edges, edges + m, cmp);
    int total = 0, cnt = 0;
    for (int i = 0; i < m; i++) {
        int u = find(edges[i].u), v = find(edges[i].v);
        if (u != v) {
            union(u, v);  // å¹¶æŸ¥
            total += edges[i].w;
            if (++cnt == n-1) break;
        }
    }
   
