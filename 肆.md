# 二分
容易混就只记住闭区间模板
```cpp
int binarySearch(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1; // [left, right] 闭区间

    while (left <= right) { // 当 left == right 时依然有效
        
        int mid = left + (right - left) / 2; // 防止溢出

        if (nums[mid] == target) {
            return mid; // 找到了
        } 
        
        else if (nums[mid] < target) {
            // 目标在右侧，且 mid 已经检查过了
            // 新区间是 [mid + 1, right]
            left = mid + 1; 
        } 
        
        else if (nums[mid] > target) {
            // 目标在左侧，且 mid 已经检查过了
            // 新区间是 [left, mid - 1]
            right = mid - 1; 
        }
    }
    
    // 循环结束，left > right，区间为空
    return -1; // 未找到
}
```
## 1.代码
==!!!!!重要！！！==[二分查找为什么总是写错？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1d54y1q7k7?buvid=XX66CC966B09DA1816FC1A3D030C87B93D3BD&from_spmid=search.search-result.0.0&is_story_h5=false&mid=BB1mlB6Sl2vTaIDqz7OMlg%3D%3D&plat_id=114&share_from=ugc&share_medium=android&share_plat=android&share_session_id=5dbe0254-98f8-458b-9efd-3e7cc9930e63&share_source=WEIXIN&share_tag=s_i&spmid=united.player-video-detail.0.0&timestamp=1763126440&unique_k=cRo83xO&up_id=643755221&vd_source=f39cf4a57a36376ce218b1d4072032c9)
![[Pasted image 20251115105611.png]]
![[Pasted image 20251115110135.png]]
![[Pasted image 20251115110618.png]]
###  基本二分查找
```cpp
int binarySearch(int A[], int left, int right, int x) {
    int mid;
    while(left <= right) {
        mid = left + (right - left) / 2;  // 避免溢出
        if(A[mid] == x) return mid;
        else if(A[mid] > x) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return -1;
}
```
- 如果找到目标值：返回该值在数组中的**索引位置**
- 如果没找到：返回 **-1**
### Lower Bound（查找第一个 ≥ x 的元素）
```cpp
// 查找第一个大于等于x的元素位置
int lower_bound(int A[], int left, int right, int x) {
    int mid;
    while(left < right) {
        mid = left + (right - left) / 2;
        if(A[mid] >= x) {
            right = mid;        // 往左子区间
        } else {
            left = mid + 1;     // 往右子区间
        }
    }
    return left;  // 或者 return right，此时 left == right
}
```
- 返回第一个**大于等于** x 的元素的**索引位置**
- 如果所有元素都小于 x，返回**数组长度**
### Upper Bound（查找第一个 > x 的元素）
```cpp
// 查找第一个大于x的元素位置
int upper_bound(int A[], int left, int right, int x) {
    int mid;
    while(left < right) {
        mid = left + (right - left) / 2;
        if(A[mid] > x) {
            right = mid;        // 往左子区间
        } else {
            left = mid + 1;     // 往右子区间
        }
    }
    return left;
}
```
- 返回第一个**大于** x 的元素的**索引位置**
- 如果所有元素都小于等于 x，返回**数组长度**
### 查找最后一个 ≤ x 的元素
```cpp
// 查找最后一个小于等于x的元素位置
int last_less_equal(int A[], int left, int right, int x) {
    int mid;
    while(left < right) {
        mid = left + (right - left + 1) / 2;  // 注意这里要+1
        if(A[mid] <= x) {
            left = mid;         // 往右子区间
        } else {
            right = mid - 1;    // 往左子区间
        }
    }
    return left;
}
```
- 返回最后一个**小于等于** x 的元素的**索引位置**
- 如果所有元素都大于 x，返回 **-1**（需要额外判断）
###  实数二分查找
```cpp
// 查找满足条件的实数
bool check(double x);  // 判断x是否满足条件
double binarySearch_double(double l, double r) {
    double eps = 1e-6;  // 精度
    while(r - l > eps) {
        double mid = (l + r) / 2;
        if(check(mid)) {
            l = mid;    // 往右子区间
        } else {
            r = mid;    // 往左子区间
        }
    }
    return l;  // 返回满足条件的解
}
```
### 重要注意事项（补充）
1. **区间选择**：
   - 闭区间 `[left, right]`：用 `while(left <= right)`，更新时 `mid ± 1`
   - 左闭右开 `[left, right)`：用 `while(left < right)`，更新时 `right = mid`
   - 详细讲讲：
### 左闭右闭  `left <= right`（闭区间）
**right = nums.size() - 1; 会对这个`left` == `right`进行判断，所以就会采用`left <= right`这个条件
**
### 左闭右开`left < right` 
**`right`作为右边界为虚值，不进行搜索 right = nums.size();最终就不需要对`left == right`这个`case`进行判断
如果判断条件是 `left < right`，那么搜索区间是左闭右开区间，即使`right = mid`，也不会判断`mid`**
1. **mid计算**：
   ```cpp
   mid = left + (right - left) / 2;  // 推荐，避免溢出
   mid = (left + right) >> 1;        // 也可以，但要注意负数情况
   ```
2. **STL中的对应函数**：
   ```cpp
   #include <algorithm>
   // 在有序范围 [first, last) 中查找
   auto it = lower_bound(arr, arr+n, x);  // 第一个 ≥ x 的元素
   auto it = upper_bound(arr, arr+n, x);  // 第一个 > x 的元素
   // 获取索引
   int idx = lower_bound(arr, arr+n, x) - arr;
   ```
## 2.洛谷 P1102 A-B 数对
**给出一串正整数数列以及一个正整数 C，要求计算出所有满足 A−B=C 的数对的个数（不同位置的数字一样的数对算不同的数对）。
输入共两行。
第一行，两个正整数 N,C。
第二行，N 个正整数，作为要求处理的那串数。
输出一行，表示该串正整数中包含的满足 A−B=C 的数对的个数。**
思路：**`lower_bound`** 找第一个等于`B+C`的位置；**`upper_bound`** 找第一个大于`B+C`的位置，两者之差即为`B+C`的出现次数。
```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int main() {
    int n, c;
    cin >> n >> c;
    vector<long long> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    sort(arr.begin(), arr.end());
    long long ans = 0;
    for (int i = 0; i < n; i++) {
        long long target = arr[i] + c;
        // 找到第一个大于等于target的位置
        auto left = lower_bound(arr.begin(), arr.end(), target);
        // 找到第一个大于target的位置
        auto right = upper_bound(arr.begin(), arr.end(), target);
        ans += (right - left);
    }
    cout << ans << endl;
    return 0;
}
```
## 3.力扣34.在排序数组中查找元素的第一个和最后一个位置
**给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 `target`，返回 `[-1, -1]`。
你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。**
思路：**`lower_bound`** 等价于查找元素的起始位置；**`upper_bound`** 查找元素的结束位置**下一个位置**，两者结合确定目标值区间。
```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if (nums.empty()) return {-1, -1};
        // 查找起始位置：第一个等于target的位置
        int start = -1, end = -1;
        int left = 0, right = nums.size() - 1;
        // 查找起始位置
        while (left <= right) {//left = right时还有一个元素需要判断
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) {
                if (nums[mid] == target) start = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        // 如果起始位置没找到，直接返回
        if (start == -1) return {-1, -1};
        // 查找结束位置
        left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] <= target) {
                if (nums[mid] == target) end = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return {start, end};
    }
};
```
## ==记这里这里！！！==
按照全闭区间查找查找左右边界的关键是`nums[mid] == target`时，如何划定新区间
全闭：
- 查找左边界：
```cpp
int binarySearch(vector<int>& nums,int target) {
        int n = nums.size();
        int left = 0,right = n - 1;
    	int ans = -1;
        while(left <= right){
            int mid = left + (right - left) / 2;
           if (nums[mid] == target){
               // 这里能判断出 mid 可能是左边界，但是对于 mid - 1 我们是无法判断的，所以
               	ans = mid;
                right = mid - 1;
            }else if (nums[mid] > target) {
           		right = mid - 1;
           	}else {
                left = mid + 1;
            }
        }
        return ans;
    }
```
- 右边界
```cpp
int binarySearch(vector<int>& nums,int target) {
        int n = nums.size();
        int left = 0,right = n - 1;
    	int ans = -1;
        while(left <= right){
            int mid = left + (right - left) / 2;
           if (nums[mid] == target){
               // 这里能判断出 mid 可能是左边界，但是对于 mid - 1 我们是无法判断的，所以
               	ans = mid;
                left = mid + 1;
            }else if (nums[mid] > target) {
           		right = mid - 1;
           	}else {
                left = mid + 1;
            }
        }
        return ans;
    }

```
最终结果都是ans。在每一次判断(nums[mid] == target)中，我们只能判断出mid 是符合要求的，而无法判断出mid - 1 或者mid + 1是否符合要求，所以ans = mid。

按照这个思路中，其实也可以不采用 ans 这个变量，而采用right + 1或者left - 1的形式，因为right + 1或者left - 1等于mid，不过这需要进一步判断right + 1 或者left - 1是否在数组范围内

如果你将nums[mid] == target 和 nums[mid] > target或者nums[mid] < target合并起来，你还需要判断nums[left - 1] 或者nums[right + 1]是否等于 target，因为当nums[mid] > target 或者nums[mid] < target时，也会给ans赋值

左闭右开：
- 右边界
```cpp
int binarySearch(vector<int>& nums,int target) {
        int n = nums.size();
        int left = 0,right = n;
        while(left < right){
            int mid = left + (right - left) / 2;
           if (nums[mid] == target){
                right = mid;
            }else if (nums[mid] > target) {
           		right = mid;
           	}else {
                left = mid + 1;
            }
        }
        return right;
    }
```
当`nums[mid] == target`时，新区间划定为`right = mid`，而结束时`left = right`，所以这里`left`或者`right`就是结果，
- 左边界
```cpp
int binarySearch(vector<int>& nums,int target) {
        int n = nums.size();
        int left = 0,right = n;
        while(left < right){
            int mid = left + (right - left) / 2;
           if (nums[mid] == target){
                left = mid + 1;
            }else if (nums[mid] > target) {
           		right = mid;
           	}else {
                left = mid + 1;
            }
        }
        return left - 1;
    }

```
**将 l ~ r 区间分为三份。如果 $f(m_1)<f(m_2)$，则极值点一定在区间 $(l,m_2)$；如果 $f(m_1)>f(m_2)$，则极值点一定在区间 $(m_1,r)$.**

（只适用于区间内为单峰的函数）
<img src="https://assets.zouht.com/img/note/7-01.webp" style="zoom: 25%;" />

### 代码

```cpp
// f(double x): 给定区间内的凹函数或凸函数
// eps: 精度（因为浮点数误差，不可直接比大小）
// BEGIN: 查找左边界
// END: 查找右边界
double f(double x);
double eps = 1e-6;
double l = BEGIN, r = END;
while(r - l > eps)
{
    double m1 = l + (r - l) / 3, m2 = r - (r - l) / 3;
    if(f(m1) > f(m2)) // 此为找最小值，若要找最大值，则改为<
        l = m1;
    else
        r = m2;
}
```
## 5.快速幂（二分幂）
![[Pasted image 20251130134801.png]]
```cpp
class Solution {
public:
    double myPow(double x, int N) {
        double ans = 1;
        long long n = N;
        if (n < 0) { // x^-n = (1/x)^n
            n = -n;
            x = 1 / x;
        }
        while (n) { // 从低到高枚举 n 的每个比特位
            if (n & 1) { // 这个比特位是 1
                ans *= x; // 把 x 乘到 ans 中
            }
            x *= x; // x 自身平方
            n >>= 1; // 继续枚举下一个比特位
        }
        return ans;
    }
};
```

快速幂（Exponentiation by squaring，平方求幂）是一种快速计算大整数幂的方法。它通过将指数进行二进制分解，从而将计算幂的次数从线性级降到对数级。
### 快速幂的原理
快速幂的基本思想是将指数表示为二进制形式，然后利用幂的乘法性质将计算分解。
![[Pasted image 20251108095547.png]]
e.g. $2^{32}=4^{16}=16^{8}=256^{4}=65536^{2}=4294967296$
### 思路
1. 初始化结果为 1。
2. 当指数 n 大于 0 时：
    - 如果 n 是奇数，则将结果乘以底数 a。    
    - 将底数 a 平方，并将指数 n 除以 2（取整）。    
3. 返回结果。    
#### 递归：(不用while)
```cpp
long long quickPow(long long a, long long n) {
    if (n == 0) return 1;
    long long half = quickPow(a, n / 2);
    if (n % 2 == 0)
        return half * half;
    else
        return half * half * a;
}
```
**递归调用树**
```cpp
quickPow(2, 13)
    │
    ├── quickPow(2, 6)  ← n=13/2=6
    │    │
    │    ├── quickPow(2, 3)  ← n=6/2=3
    │    │    │
    │    │    ├── quickPow(2, 1)  ← n=3/2=1
    │    │    │    │
    │    │    │    └── quickPow(2, 0)  ← n=1/2=0 → 返回1
    │    │    │    │
    │    │    │    └── 返回: 1×1×2 = 2
    │    │    │
    │    │    └── 返回: 2×2×2 = 8
    │    │
    │    └── 返回: 8×8 = 64
    │
    └── 返回: 64×64×2 = 8192
```
#### 迭代：（更高效）
```cpp
long long quickPow(long long a, long long n) {
    long long res = 1;
    while (n) {
        if (n & 1)  // 如果n是奇数
            res *= a;
        a *= a;     // 底数平方
        n >>= 1;    // 指数除以2
    }
    return res;
}
```
PS:`n & 1` 是一个**位运算**表达式，用于检查整数 `n` 的**最低位（最右边的位）**是否为 1。
判断奇偶性：
```cpp
if (n & 1) {
    // n 是奇数
} else {
    // n 是偶数
}
```
### 模幂运算(大数取模)
```cpp
long long quickPowMod(long long a, long long n, long long mod) {
    long long res = 1;
    a %= mod;  // 先取模，防止a过大
    while (n) {
        if (n & 1)
            res = (res * a) % mod;
        a = (a * a) % mod;
        n >>= 1;
    }
    return res;
}
```
### 力扣 50.
#### 递归
```cpp
class Solution {
public:
    double myPow(double x, int n) {
        long long N = n;
        return quickPow(x, N);
    }
private:
    double quickPow(double x, long long n) {
        if (n == 0) return 1.0;
        // 处理负数指数
        if (n < 0) {
            x = 1 / x;
            n = -n;
        }
        double half = quickPow(x, n / 2);
        if (n % 2 == 0) {
            return half * half;
        } else {
            return half * half * x;
        }
    }
};
```
#### 迭代
```cpp
class Solution {
public:
    double myPow(double x, int n) {
        // 使用long long避免整数溢出
        long long N = n;
        // 处理负数指数
        if (N < 0) {
            x = 1 / x;
            N = -N;
        }
        double result = 1.0;
        while (N > 0) {
            // 如果当前位是1，乘到结果中
            if (N & 1) {
                result *= x;
            }
            // x平方
            x *= x;
            // N右移一位
            N >>= 1;
        } 
        return result;
    }
};
```

# two pointers(双指针)
Two Pointers（双指针）是一种常用的算法技巧，它使用**两个指针**在数组、链表或其他序列数据结构中协同工作，以高效解决特定类型的问题。
## 1.(基本用法)力扣3731. 找出缺失的元素
给你一个整数数组 `nums` ，数组由若干 **互不相同** 的整数组成。
数组 `nums` 原本包含了某个范围内的 **所有整数** 。但现在，其中可能 **缺失** 部分整数。
该范围内的 **最小** 整数和 **最大** 整数仍然存在于 `nums` 中。
返回一个 **有序** 列表，包含该范围内缺失的所有整数，并 **按从小到大排序**。如果没有缺失的整数，返回一个 **空** 列表。
```cpp
class Solution {
public:
    vector<int> findMissingElements(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<int> res;
        int n = nums.size();
        for (int i = 0; i < n - 1; i++) {
            int left = nums[i] + 1;
            int right = nums[i + 1];
            for (int num = left; num < right; num++) {
                res.push_back(num);
            }
        }
        return res;
    }
};
```

## 2.对撞指针（Colliding Pointers）
两个指针从序列两端向中间移动，直到相遇。
**应用场景**：
- 两数之和（有序数组）
- 回文串判断
- 盛最多水的容器
**代码示例**
LeetCode 167. 两数之和 II:
在有序数组中，利用双指针寻找两数之和。
**有序数组的利用**，根据和与目标值的大小关系移动指针。
```cpp
vector<int> twoSum(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        int sum = nums[left] + nums[right];
        if (sum == target) return {left, right};
        else if (sum < target) left++;
        else right--;
    }
    return {};
}
```
LeetCode 11. 盛最多水的容器:
双指针从两端向中间移动，每次移动高度较小的指针。
理解**为什么移动矮指针是安全的**（贪心思想）。
**指针每一次移动，都意味着排除掉了一个柱子**。
```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int l = 0, r = height.size() - 1;
        int ans = 0;
        while (l < r) {
            ans = max(ans, min(height[l], height[r]) * (r - l));
            if (height[l] < height[r]) {
                l++;
            } else {
                r--;
            }
        }
        return ans;
    }
};
```
LeetCode 15. 三数之和:
固定一个数，转化为两数之和问题，用对撞指针求解。
**去重**是关键，需注意跳过相同元素。通常先排序
易错点：！！！`left` 和 `right` 应该是索引而不是值
```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans;
        int n = nums.size();
        if (n < 3) return ans;
        sort(nums.begin(), nums.end());  // 只在外部排序一次 
        for (int i = 0; i < n - 2; i++) {  // 注意边界条件
            // 跳过重复的固定元素
            if (i > 0 && nums[i] == nums[i - 1]) continue;    
            int left = i + 1;           // left 是索引
            int right = n - 1;          // right 是索引
            int target = -nums[i];      // 需要找的两个数之和   
            while (left < right) {
                int sum = nums[left] + nums[right];     
                if (sum == target) {
                    ans.push_back({nums[i], nums[left], nums[right]});     
                    // 跳过重复的left和right
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;    
                    left++;
                    right--;
                } else if (sum < target) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        return ans;
    }
};
```
## 3. 快慢指针（Fast-Slow Pointers）
两个指针以不同速度移动。
**应用场景**：
- 链表环检测
- 找到链表中点
- 寻找重复数
**代码示例**
LeetCode 141. 环形链表（链表环检测）：
快指针每次走两步，慢指针走一步，相遇则有环。
**Floyd判圈算法**的基础应用
```cpp
bool hasCycle(ListNode *head) {
    ListNode *slow = head, *fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    return false;
}
```
LeetCode 876. 链表的中间结点:
快指针走两步，慢指针走一步，快指针到头时慢指针在中间。
寻找链表中间节点的经典方法。
- 链表长度为奇数： 当 fast 走到链表「尾节点」时，slow 正好走到「中间节点」。
- 链表长度为偶数： 当 fast 走到「null」时（越过「尾节点」后），slow 正好走到「第二个中间节点」。

```cpp
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
};
```
LeetCode 287. 寻找重复数:
将数组视为链表，利用快慢指针寻找环的入口。
**将数组下标和值映射成链表**，思维转换。
快慢指针：(把索引转化为下一个指向的节点的下标)
```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = 0;
        int fast = 0;
        while (true) {
            // fast 前进两次，slow 前进一次
            fast = nums[fast];
            fast = nums[fast];
            slow = nums[slow];
            if (slow == fast) break;
        }
        // ptr == slow 时说明检测到重复元素，两个重复元素同时指向环的入口。
        int ptr = 0;
        while (ptr != slow) {
            ptr = nums[ptr];
            slow = nums[slow];
        }
        return ptr;
    }
};
```
二分查找：
在**数字范围 [1, n]** 上进行二分查找，利用**计数**来判断重复数字在哪一半。
**核心原理：鸽巢原理**
如果区间 `[min, mid]` 内的数字个数超过了区间长度 `(mid - min + 1)`，那么根据鸽巢原理，这个区间内至少有一个数字重复
```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int min = 1; // 所查找数字范围的最小值
        int max = nums.size(); // 所查找数字范围的最大值
        while (min < max) {
            int mid = (min + max) / 2;
            // 统计在 [min, mid] 范围内的数字个数
            int cnt = 0;
            for (int v : nums) {
                if (v >= min && v <= mid) {
                    cnt++;
                }
            }
            if (cnt > mid - min + 1) // 个数超出范围长度，即存在重复数且重复数在左半部分
                max = mid;
            else
                min = mid + 1;   // 否则在右半部分
        }
        return min;
    }
};
```
## 4 滑动窗口（Sliding Window）
随便给一个窗口，然后

窗口中的状态是什么？即窗口中的元素怎么表示可行解？

如何表示窗口中的状态？即具体怎么表示可行解？

什么时候窗口扩展？即怎么寻找可行解？窗口扩展到什么时候不扩展了？

什么时候窗口收缩？即怎么优化可行解？窗口收缩到什么时候？

基本上主要搞清楚两个点，题就能解了。一就是知道这个题能用滑动窗口解，二就是搞清楚什么时候窗口扩展和收缩。

一般来说，窗口扩展有两种方式，根据窗口是否一直满足条件。

如果窗口一直满足条件，那么扩展时，就需要进行筛选，满足条件就直接右移，这时可能可以右移很快，当时如果条件过多，会非常复杂。窗口扩展之后直到不满足条件，那么再窗口收缩，这时通常收缩后窗口就不满足条件了，是为了下次扩展做准备。

另一种就是每次直接强制扩展一次，扩展后窗口满足条件与否并不确定。扩展一次之后，窗口进行收缩直到满足条件。这是第二种伸缩方式。

具体选择哪种方式，要看具体题型，一般来说，如果扩展满足条件太复杂，就可以直接右移。

固定窗口的难点通常在于什么是否满足窗口中的条件，而变长窗口的难点则主要在于什么是否窗口伸缩。


==伪代码框架==(Eason)
```cpp
class Solution:
    def problemName(self, s: str) -> int:
        # Step 1: 定义需要维护的变量们 (对于滑动窗口类题目，这些变量通常是最小长度，最大长度，或者哈希表)
        x, y = ..., ...

        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(s)):
            # Step 3: 更新需要维护的变量, 有的变量需要一个if语句来维护 (比如最大最小长度)
            x = new_x
            if condition:
                y = new_y

            '''
            ------------- 下面是两种情况，读者请根据题意二选1 -------------
            '''
            # Step 4 - 情况1
            # 如果题目的窗口长度固定：用一个if语句判断一下当前窗口长度是否达到了限定长度 
            # 如果达到了，窗口左指针前移一个单位，从而保证下一次右指针右移时，窗口长度保持不变, 
            # 左指针移动之前, 先更新Step 1定义的(部分或所有)维护变量 
            if 窗口长度达到了限定长度:
                # 更新 (部分或所有) 维护变量 
                # 窗口左指针前移一个单位保证下一次右指针右移时窗口长度保持不变

            # Step 4 - 情况2
            # 如果题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题
            # 如果当前窗口不合法时, 用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法
            # 在左指针移动之前更新Step 1定义的(部分或所有)维护变量 
            while 不合法:
                # 更新 (部分或所有) 维护变量 
                # 不断移动窗口左指针直到窗口再次合法

        # Step 5: 返回答案
        return ...
```
两个指针维护一个窗口，根据条件调整窗口大小。
**应用场景**：
- 无重复字符的最长子串
- 最小覆盖子串
- 长度最小的子数组
**代码示例**
LeetCode 3. 无重复字符的最长子串：
维护一个不含重复字符的窗口，记录最大窗口长度。
**哈希集合**记录字符是否出现，**窗口的动态维护**。
方法一：（滑动窗口 + 哈希表）
- 哈希表 dic 统计： 指针 j 遍历字符 s ，哈希表统计字符 s[j] 最后一次出现的索引 。
- 更新左指针 i ： 根据上轮左指针 i 和 dic[s[j]] ，每轮更新左边界 i ，保证区间 [i+1,j] 内无重复字符且最大。
<center>i=max(dic[s[j]],i)</center>

- 更新结果 res ： 取上轮 res 和本轮双指针区间 [i+1,j] 的宽度（即 j−i ）中的最大值。
<center>res=max(res,j−i)</center>
来自@Krahets佬
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> dic;
        int i = -1, res = 0, len = s.size();
        for(int j = 0; j < len; j++) {
        //检查当前字符是否出现过
            if (dic.find(s[j]) != dic.end())
                i = max(i, dic.find(s[j])->second); // 更新左指针
        //记录/更新当前字符的位置
            dic[s[j]] = j; 
        //更新最大长度
            res = max(res, j - i); 
        }
        return res;
    }
};
```
更加简洁而优雅的方法二：(桶排序)来自@Kuro-0429（其实我没看懂（存疑）
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // 创建桶(数组)，设定128个元素对应0-127ASCII码值
        // 每格都存对应字符的后一个位置，比如a的位置是i，那么数组里就存i+1
        // 用来在又碰见这个字符的时候把左边界直接更新到前一个该字符的下一个位置
        vector<int> m(128, 0);
        //存最大长度
        int maxlen = 0;
        //head表示窗口左边界位置
        int head = 0;
        //遍历字符串
        for (int i = 0; i < s.size(); i++) {
            //修改左边界，每次选最大的就相当于更新了
            head = max(head, m[s[i]]);
            //当前字母对应的ASCII码桶里存下一个位置(i+1)，用于更新左边界
            m[s[i]] = i + 1;
            //更新长度
            maxlen = max(maxlen, i - head + 1);
        }
        return maxlen;
    }
};
```
LeetCode 209. 长度最小的子数组：
维护一个元素和大于等于目标的窗口，记录最小窗口长度。
**窗口内和的动态计算**，左指针的移动条件。
- `left` 和 `right` 指针定义当前窗口的边界
- 扩展右指针来增加窗口和
- 当窗口和 ≥ target 时，收缩左指针来寻找更小的窗口
```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int minLen = INT_MAX;//初始化为最大可能值, 任何实际数都会比INT_MAX小
        int sum = 0, left = 0;
        for (int right = 0; right < nums.size(); right++) {
          // 扩展窗口：右指针向右移动，加入新元素
            sum += nums[right];  
            // 当窗口和满足条件时，尝试收缩窗口         
            while (sum >= target) {
                // 更新最小长度
                minLen = min(minLen, right - left + 1);
                sum -= nums[left++];
                //相当于
                //sum -= nums[left];
                //left++;
                // 收缩窗口：左指针向右移动，移除元素
            }
        }       
        return minLen == INT_MAX ? 0 : minLen;
    }
};
```
LeetCode 76. 最小覆盖子串
维护一个包含目标字符串所有字符的窗口，找最小窗口。
**哈希字典**记录字符需求，**计数器**判断是否满足条件。（待补充）

## 推荐使用滑动窗口的情况：

1. **连续子数组/子字符串问题**：问题要求找到一个连续的区间，而不是离散的元素。
    
2. **窗口大小固定**：当问题要求固定长度的子数组时，滑动窗口非常自然。
    
    - 示例：找到长度为k的子数组的最大平均值。
        
3. **窗口大小不固定，但满足某种单调性**：通常是通过移动右指针扩大窗口，移动左指针缩小窗口，并且窗口内的状态（如元素和、不同字符数等）随着窗口的扩大而单调变化（通常是非递减或非递增）。
    
    - 示例：寻找最长/最短的满足条件的子数组（如和至少为k的最短子数组、无重复字符的最长子串）。
        
4. **问题可以转化为对窗口内元素的计数**：例如，窗口内最多包含k个不同字符，窗口内最多将k个0变成1等。
    
5. **问题要求计算满足条件的子数组个数，且可以通过“至多”相减得到**：例如，计算子数组和恰好为k的个数可以转化为“至多k”减去“至多k-1”。
    

## 不推荐使用滑动窗口的情况：

1. **子数组不要求连续**：如果问题涉及非连续的子序列，则滑动窗口不适用。
    
2. **数组中有负数**：虽然滑动窗口可以处理非负数数组的很多问题，但如果有负数，窗口扩大时和可能减小，缩小时和可能增大，这会破坏单调性，使得滑动窗口难以应用。
    
    - 注意：有些问题即使有负数，如果使用前缀和+哈希表的方法，实际上并不是典型的滑动窗口，而是利用哈希表记录前缀和。
        
3. **需要统计所有满足条件的子数组，且条件不是单调的**：例如，统计和恰好为k的子数组个数，如果直接使用滑动窗口，会因为0的存在而难以计数（因为0不会改变和，但会形成多个子数组）。这时更推荐使用前缀和+哈希表。
    
4. **问题要求多个不连续的区间**：滑动窗口通常用于单个连续区间。
    
5. **当窗口内的状态更新非常复杂**：例如，需要维护窗口内多个复杂条件，导致窗口收缩条件复杂，可能不适合滑动窗口。
    

## 滑动窗口的替代方案：

1. **前缀和 + 哈希表**：适用于求子数组和等于k的个数、和可被k整除的子数组个数等问题，特别是当数组中存在负数时。
    
2. **双指针（非滑动窗口）**：有些问题可以使用双指针，但指针移动规则不同于滑动窗口（例如，快慢指针找环，或者两个指针从两端向中间移动）。
    
3. **动态规划**：当问题不要求连续，或者有更复杂的状态转移时，动态规划可能更合适。
    
4. **分治法**：例如，求最大子数组和可以使用分治法，但滑动窗口或动态规划通常更简单。
![[image.png]]
- 如果问题涉及连续子数组且数组非负，首先考虑滑动窗口。
    
- 如果问题要求统计子数组个数且数组可能有负数，使用前缀和+哈希表。
    
- 如果问题要求固定长度，滑动窗口是首选。
    
- 如果问题要求最长/最短连续子数组，且窗口扩展和收缩具有单调性，滑动窗口通常有效。
```cpp
问题类型判断：
    ↓
是否需要连续子数组？
    ↓ 否 → 考虑动态规划/回溯
    ↓ 是
是否需要统计所有解的数量？
    ↓ 是 → 前缀和 + 哈希表
    ↓ 否
数组是否包含负数？
    ↓ 是 → 前缀和 + 哈希表
    ↓ 否
是否是最大/最小优化问题？
    ↓ 是 → 滑动窗口 ✓
    ↓ 否
滑动条件是否明确？
    ↓ 是 → 滑动窗口 ✓
    ↓ 否 → 考虑其他方法
```
## 5. 特殊应用
归并排序中的双指针
LeetCode 88. 合并两个有序数组：（倒序双指针）
将两个有序序列合并为一个非递减序列。（递增序列）
从两个数组的末尾开始，将较大元素放到合并后的末尾。
**从后往前**填充，避免覆盖原数组中有用的元素。
递归：
```cpp
void mergeSort(int A[], int left, int right) {
    if (left < right) {
        int mid = (left + right) / 2;
        mergeSort(A, left, mid);      // 递归左半部分
        mergeSort(A, mid + 1, right); // 递归右半部分
        merge(A, left, mid, mid + 1, right); // 合并
    }
}
```
灵神的解法：
```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int p1 = m - 1, p2 = n - 1, p = m + n - 1;
        //为什么是m-1? 索引从0开始原则
        while (p2 >= 0) { 
	        // nums2 还有要合并的元素
            // 如果 p1 < 0，那么走 else 分支，把 nums2 合并到 nums1 中
            if (p1 >= 0 && nums1[p1] > nums2[p2]) {
                nums1[p--] = nums1[p1--]; // 填入 nums1[p1]
            } else {
                nums1[p--] = nums2[p2--]; // 填入 nums2[p1]
            }
        }
    }
};
```
LeetCode 344. 反转字符串：
对撞指针交换对应位置的字符。
```cpp
class Solution { 
public: 
	void reverseString(vector<char>& s) { 
		int left = 0, right = s.size() - 1; 
		while(left < right){ 
		swap(s[left++], s[right--]); // 在交换的同时移动指针 
		} 
	}
};
```
LeetCode 5. 最长回文子串：（如果字符串向前和向后读都相同，则它满足 **回文性**）
从中心向两边扩展，检查回文串。
**中心扩展法**，需考虑奇偶长度。
回文中心的两侧互为镜像。因此，中心可以为一个字符，也可以只是两个字符之间的间隙
```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        if(s.size() <= 1) return s;
        int maxLen = 1, start = 0;
        for(int i = 0; i < s.size(); i++){
            int len = lenOfPalindrome(s, i);
            if(len > maxLen){
                maxLen = len;
                start = i - (maxLen - 1) / 2;
            }
        }
        return s.substr(start, maxLen);
    }
    int lenOfPalindrome(string &s, int c){
        int l, r;
        int len1 = 0, len2 = 0; // 初始化变量 
        // 奇数长度回文
        l = c, r = c;
        while(l >= 0 && r < s.size() && s[l] == s[r]) {
            l--;
            r++;
        }
        len1 = r - l - 1; 
        // 偶数长度回文
        l = c, r = c + 1;
        while(l >= 0 && r < s.size() && s[l] == s[r]) {
            l--;
            r++;
        }
        len2 = r - l - 1;
        return max(len1, len2);
    }
};
```

